[{"filePath":"/Users/m3hdi/toolbridge/src/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/genericProxy.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":86,"column":25,"nodeType":"Identifier","messageId":"neverNullish","endLine":86,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":112,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":112,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3777,3779],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5253,5256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5253,5256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5949,5952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5949,5952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createProxyMiddleware } from \"http-proxy-middleware\";\n\n\nimport { BACKEND_LLM_BASE_URL } from \"./config.js\";\nimport { buildBackendHeaders } from \"./utils/headerUtils.js\";\nimport logger from \"./utils/logger.js\";\n\nimport type { Request } from \"express\";\nimport type { ClientRequest, IncomingMessage, ServerResponse } from \"http\";\n\ninterface ProxyRequest {\n  method: string | undefined;\n  headers: Record<string, string | string[] | undefined>;\n  body: unknown;\n  ip: string | undefined;\n  originalUrl: string | undefined;\n  path: string;\n}\n\ninterface ProxyResponse extends IncomingMessage {\n  statusCode?: number;\n}\n\nconst logRequestDetails = (\n  label: string,\n  req: ProxyRequest,\n  headers: Record<string, string | string[] | undefined>,\n  body: unknown = null\n): void => {\n  logger.debug(`\n[${label}] =====================`);\n  logger.debug(`[${label}] ${req.method} ${req.originalUrl ?? req.path}`);\n  if (req.ip && req.ip !== \"\") { logger.debug(`[${label}] Client IP: ${req.ip}`); }\n  logger.debug(`[${label}] Headers:`, JSON.stringify(headers, null, 2));\n  \n  if (body && req.method !== \"GET\" && req.method !== \"HEAD\") {\n    let safeBody: unknown;\n    try {\n      safeBody = JSON.parse(JSON.stringify(body));\n      if (typeof safeBody === 'object' && safeBody !== null && 'api_key' in safeBody) {\n        (safeBody as Record<string, unknown>).api_key = \"********\";\n      }\n    } catch {\n      safeBody = \"[Unable to parse or clone body]\";\n    }\n    logger.debug(`[${label}] Body:`, JSON.stringify(safeBody, null, 2));\n  }\n  logger.debug(`[${label}] =====================\n`);\n};\n\nconst proxyOptions = {\n  target: BACKEND_LLM_BASE_URL,\n  changeOrigin: true,\n\n  pathRewrite: (path: string, req: IncomingMessage): string => {\n    const backendPath = \"/v1\" + path;\n  const reqWithUrl = req as IncomingMessage & { originalUrl?: string; url?: string };\n  const original = reqWithUrl.originalUrl ?? reqWithUrl.url ?? path;\n    logger.debug(`\\n[PROXY] Rewriting path: ${original} -> ${backendPath}`);\n    return backendPath;\n  },\n\n  on: {\n    proxyReq: (proxyReq: ClientRequest, req: IncomingMessage, _res: ServerResponse): void => {\n      const expressReq = req as Request;\n      logRequestDetails(\"CLIENT REQUEST\", {\n        method: expressReq.method,\n        headers: expressReq.headers,\n        body: expressReq.body,\n        ip: expressReq.ip,\n        originalUrl: expressReq.originalUrl,\n        path: expressReq.path,\n      }, expressReq.headers, expressReq.body);\n\n  const clientAuthHeader = expressReq.headers[\"authorization\"];\n  const backendHeaders = buildBackendHeaders(clientAuthHeader ?? \"\", expressReq.headers, \"proxy\");\n\n      Object.keys(backendHeaders).forEach((key) => {\n        const value = backendHeaders[key];\n        if (value !== undefined) {\n          proxyReq.setHeader(key, value);\n        }\n      });\n\n  const backendUrl = `${BACKEND_LLM_BASE_URL ?? \"\"}${proxyReq.path}`;\n      const actualBackendHeaders: Record<string, string | string[] | undefined> = {};\n      \n      proxyReq.getHeaderNames().forEach((name: string) => {\n        const value = proxyReq.getHeader(name);\n        actualBackendHeaders[name] = typeof value === \"number\" ? String(value) : value;\n      });\n      \n      const proxyRequestInfo: ProxyRequest = {\n        method: expressReq.method,\n        headers: expressReq.headers,\n        body: expressReq.body,\n        ip: expressReq.ip,\n        originalUrl: backendUrl,\n        path: backendUrl,\n      };\n      logRequestDetails(\n        \"PROXY REQUEST\",\n        proxyRequestInfo,\n        actualBackendHeaders,\n        expressReq.body,\n      );\n    },\n\n    proxyRes: (proxyRes: ProxyResponse, req: IncomingMessage, res: ServerResponse): void => {\n      const expressReq = req as Request;\n  const contentType = proxyRes.headers?.[\"content-type\"];\n  logger.debug(\n    `\n[PROXY RESPONSE] Status: ${proxyRes.statusCode} (${contentType ?? \"N/A\"}) for ${expressReq.method} ${expressReq.originalUrl}`,\n  );\n      logger.debug(`[PROXY RESPONSE] Headers received from backend:`);\n      logger.debug(JSON.stringify(proxyRes.headers, null, 2));\n\n  if (typeof contentType === \"string\" && contentType.includes(\"text/event-stream\")) {\n        res.setHeader(\"Content-Type\", \"text/event-stream\");\n  } else if (expressReq.path === \"/models\") {\n        let responseBody = \"\";\n        const originalWrite = res.write.bind(res);\n        const originalEnd = res.end.bind(res);\n\n        proxyRes.on(\"data\", (chunk: Buffer | string) => {\n          responseBody += typeof chunk === \"string\" ? chunk : chunk.toString(\"utf8\");\n        });\n\n  res.write = (): boolean => true;\n\n        res.end = (chunk?: unknown): ServerResponse<IncomingMessage> => {\n          if (chunk) {\n            responseBody += typeof chunk === \"string\" ? chunk : String(chunk);\n          }\n          try {\n            const parsedBody = JSON.parse(responseBody);\n            logger.debug(`[PROXY RESPONSE] Models response body:`);\n            logger.debug(JSON.stringify(parsedBody, null, 2));\n          } catch {\n            logger.debug(\n              `[PROXY RESPONSE] Raw models response body (non-JSON):`,\n              responseBody,\n            );\n          }\n\n          originalWrite(responseBody, \"utf8\");\n          originalEnd.call(res, null as any, \"utf8\", () => {});\n          return res;\n        };\n      }\n    },\n\n    error: (err: Error & { code?: string }, _req: IncomingMessage, res: ServerResponse): void => {\n      logger.error(\"Proxy error:\", err);\n      \n      if (!res.headersSent) {\n        if (err.code === \"ECONNREFUSED\") {\n          res.statusCode = 503;\n          res.end(\n            `Service Unavailable: Cannot connect to backend at ${BACKEND_LLM_BASE_URL}`,\n          );\n        } else {\n          res.statusCode = 502;\n          res.end(`Proxy Error: ${err.message}`);\n        }\n      } else if (!res.writableEnded) {\n        res.end();\n      }\n    },\n  },\n};\n\nconst genericProxy = createProxyMiddleware(proxyOptions as any);\n\nexport default genericProxy;","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/backendLLM.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/chatHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":56,"column":47,"nodeType":"TSAsExpression","messageId":"alwaysTruthy","endLine":56,"endColumn":95},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":62,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":62,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":62,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":62,"endColumn":29},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":97,"column":75,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":97,"endColumn":77,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3087,3089],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3197,3200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3197,3200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":121,"column":40,"nodeType":"ChainExpression","messageId":"alwaysTruthy","endLine":123,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":121,"column":40,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":123,"endColumn":57},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":122,"column":9,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":122,"endColumn":11,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4004,4006],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":122,"column":44,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":122,"endColumn":46,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4039,4041],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":171,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":171,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5628,5630],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { convertRequest } from \"../utils/formatConverters.js\";\nimport logger from \"../utils/logger.js\";\n\nimport { callBackendLLM } from \"./backendLLM.js\";\nimport {\n  FORMAT_OLLAMA,\n  FORMAT_OPENAI,\n  detectRequestFormat,\n} from \"./formatDetector.js\";\nimport { handleNonStreamingResponse } from \"./nonStreamingHandler.js\";\nimport { buildBackendPayload } from \"./payloadHandler.js\";\nimport { setupStreamHandler } from \"./streamingHandler.js\";\n\nimport type {\n  OpenAITool,\n  OpenAIRequest,\n  OpenAIResponse,\n  OllamaRequest,\n  OllamaResponse,\n  RequestFormat,\n  BackendError,\n  BackendPayload\n} from \"../types/index.js\";\nimport type { Request, Response } from \"express\";\nimport type { Readable } from \"stream\";\n\ninterface ChatCompletionRequest extends Request {\n  body: OpenAIRequest | OllamaRequest;\n  headers: Request['headers'] & {\n    authorization?: string | undefined;\n    'x-backend-format'?: RequestFormat | undefined;\n  };\n}\n\ninterface ChatCompletionResponse extends Response {\n  json(body: OpenAIResponse | { error: string }): this;\n}\n\nconst chatCompletionsHandler = async (\n  req: ChatCompletionRequest,\n  res: ChatCompletionResponse\n): Promise<void> => {\n  logger.debug(\"\\n--- New Chat Completions Request ---\");\n  logger.debug(\n    \"[CLIENT REQUEST] Headers:\",\n    JSON.stringify(req.headers, null, 2),\n  );\n  logger.debug(\"[CLIENT REQUEST] Body:\", JSON.stringify(req.body, null, 2));\n\n  const clientRequestFormat: RequestFormat = detectRequestFormat(req);\n  logger.debug(\n    `[FORMAT] Detected client request format: ${clientRequestFormat}`,\n  );\n\n  const backendTargetFormat: RequestFormat = (req.headers[\"x-backend-format\"] as RequestFormat) || FORMAT_OPENAI;\n  logger.debug(`[FORMAT] Target backend format: ${backendTargetFormat}`);\n\n  // Type-safe validation\n  if (clientRequestFormat === FORMAT_OPENAI) {\n    const openaiBody = req.body as OpenAIRequest;\n    if (!openaiBody.messages) {\n      res.status(400).json({ error: 'Missing \"messages\" in OpenAI request body' });\n      return;\n    }\n  } else if (clientRequestFormat === FORMAT_OLLAMA) {\n    const ollamaBody = req.body as OllamaRequest;\n    if (!ollamaBody.prompt && !ollamaBody.messages) {\n      res.status(400).json({ error: 'Missing \"prompt\" or \"messages\" in Ollama request body' });\n      return;\n    }\n  }\n\n  try {\n    let backendPayload: BackendPayload = req.body as BackendPayload;\n    \n    if (clientRequestFormat !== backendTargetFormat) {\n      logger.debug(\n        `[FORMAT] Converting request: ${clientRequestFormat} -> ${backendTargetFormat}`,\n      );\n      backendPayload = convertRequest(\n        clientRequestFormat,\n        backendTargetFormat,\n        req.body,\n      );\n      logger.debug(\n        \"[CONVERTED REQUEST] Payload for backend:\",\n        JSON.stringify(backendPayload, null, 2),\n      );\n    } else {\n      logger.debug(\n        `[FORMAT] Request format matches backend format (${clientRequestFormat}). No conversion needed.`,\n      );\n    }\n\n    // Extract tools BEFORE buildBackendPayload removes them\n    const originalTools: OpenAITool[] = (req.body as OpenAIRequest).tools || [];\n    \n    if (backendTargetFormat === FORMAT_OPENAI) {\n      const payloadWithTools = backendPayload as any;\n      payloadWithTools.tools = originalTools;\n      backendPayload = buildBackendPayload(payloadWithTools);\n    }\n\n    const clientRequestedStream: boolean = Boolean((req.body).stream);\n    const clientAuthHeader: string | undefined = req.headers.authorization;\n    const clientHeaders: Record<string, string | string[] | undefined> = req.headers;\n\n    const backendResponseOrStream: OpenAIResponse | OllamaResponse | Readable = await callBackendLLM(\n      backendPayload,\n      clientRequestedStream,\n      clientAuthHeader,\n      clientHeaders,\n      backendTargetFormat,\n    );\n\n    if (!clientRequestedStream) {\n      logger.debug(\"[RESPONSE] Received non-streaming response from backend.\");\n\n      // Extract tool names for XML parsing\n      const knownToolNames: string[] = originalTools\n        ?.map((t: OpenAITool) => t.function?.name)\n        .filter((name): name is string => Boolean(name)) || [];\n      \n      const finalResponse: OpenAIResponse = handleNonStreamingResponse(\n        backendResponseOrStream as OpenAIResponse,\n        clientRequestFormat,\n        backendTargetFormat,\n        knownToolNames,\n      );\n\n      logger.debug(\n        \"[FINAL RESPONSE] Sending to client:\",\n        JSON.stringify(finalResponse, null, 2),\n      );\n      res.json(finalResponse);\n    } else {\n      logger.debug(\n        \"[RESPONSE] Received stream from backend. Setting up stream handler.\",\n      );\n\n      res.setHeader(\"Content-Type\", \"text/event-stream\");\n      res.setHeader(\"Cache-Control\", \"no-cache\");\n      res.setHeader(\"Connection\", \"keep-alive\");\n\n      setupStreamHandler(\n        backendResponseOrStream as Readable,\n        res,\n        clientRequestFormat,\n        backendTargetFormat,\n        originalTools,\n      );\n    }\n  } catch (error: unknown) {\n    const backendError = error as BackendError;\n    \n    logger.error(\"\\n--- Error processing chat completion request ---\");\n    logger.error(\"Error Message:\", backendError.message);\n    \n    if (backendError.stack) {\n      logger.error(\"Stack Trace:\", backendError.stack);\n    }\n    if (backendError.response) {\n      logger.error(\"Backend Response Status:\", backendError.response.status);\n      logger.error(\"Backend Response Data:\", backendError.response.data);\n    } else if (backendError.request) {\n      logger.error(\"Backend Request Data:\", backendError.request);\n    }\n\n    if (!res.headersSent) {\n      const statusCode = backendError.status || 500;\n      res.status(statusCode).json({\n        error: `Failed to process chat completion. Status: ${statusCode}. Message: ${backendError.message}`,\n      });\n    } else if (!res.writableEnded) {\n      logger.error(\"[ERROR] Headers already sent, attempting to end stream.\");\n      res.end();\n    } else {\n      logger.error(\n        \"[ERROR] Headers sent and stream ended. Cannot send error response.\",\n      );\n    }\n  }\n};\n\nexport default chatCompletionsHandler;","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/formatDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":38,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":38,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":38,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":38,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":64,"column":8,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":64,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":79,"column":46,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":79,"endColumn":63}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { isOllamaFormat } from \"../utils/format/ollama/detector.js\";\nimport { isOpenAIFormat } from \"../utils/format/openai/detector.js\";\nimport logger from \"../utils/logger.js\";\n\nimport type { RequestFormat, OpenAIRequest, OllamaRequest, OpenAIResponse, OllamaResponse } from \"../types/index.js\";\nimport type { Request } from \"express\";\n\nexport const FORMAT_OPENAI: RequestFormat = \"openai\";\nexport const FORMAT_OLLAMA: RequestFormat = \"ollama\";\nexport const FORMAT_UNKNOWN = \"unknown\";\n\ninterface RequestWithFormat extends Request {\n  body: OpenAIRequest | OllamaRequest | Record<string, unknown>;\n  headers: Request['headers'] & {\n    'x-api-format'?: string;\n  };\n}\n\nexport function detectRequestFormat(req: RequestWithFormat): RequestFormat {\n  const explicitFormat = req.headers[\"x-api-format\"]?.toLowerCase() as RequestFormat;\n  \n  if (explicitFormat === FORMAT_OLLAMA) {\n    logger.debug(\n      `[FORMAT] Detected client format via header: ${FORMAT_OLLAMA}`,\n    );\n    return FORMAT_OLLAMA;\n  }\n  \n  if (explicitFormat === FORMAT_OPENAI) {\n    logger.debug(\n      `[FORMAT] Detected client format via header: ${FORMAT_OPENAI}`,\n    );\n    return FORMAT_OPENAI;\n  }\n\n  const body = req.body;\n  if (!body || typeof body !== \"object\") {\n    logger.debug(\n      \"[FORMAT] Request body is missing or not an object. Cannot infer format.\",\n    );\n    return FORMAT_OPENAI; // Default to OpenAI format instead of unknown\n  }\n\n  if (isOllamaFormat(body)) {\n    logger.debug(`[FORMAT] Inferred client format from body: ${FORMAT_OLLAMA}`);\n    return FORMAT_OLLAMA;\n  }\n  \n  if (isOpenAIFormat(body)) {\n    logger.debug(`[FORMAT] Inferred client format from body: ${FORMAT_OPENAI}`);\n    return FORMAT_OPENAI;\n  }\n\n  logger.debug(\n    \"[FORMAT] Could not confidently detect request format from header or body. Defaulting to OpenAI format.\",\n  );\n  return FORMAT_OPENAI;\n}\n\ntype ResponseFormatInput = string | OpenAIResponse | OllamaResponse | Record<string, unknown> | null | undefined;\n\nexport function detectResponseFormat(response: ResponseFormatInput): RequestFormat | typeof FORMAT_UNKNOWN {\n  if (!response) {return FORMAT_UNKNOWN;}\n\n  let parsedResponse: Record<string, unknown>;\n\n  if (typeof response === \"string\") {\n    try {\n      const jsonString = response.startsWith(\"data: \")\n        ? response.slice(6)\n        : response;\n\n      if (jsonString.trim() === \"[DONE]\") {return FORMAT_OPENAI;}\n      parsedResponse = JSON.parse(jsonString) as Record<string, unknown>;\n    } catch {\n      return FORMAT_UNKNOWN;\n    }\n  } else if (typeof response === \"object\" && response !== null) {\n    parsedResponse = response as Record<string, unknown>;\n  } else {\n    return FORMAT_UNKNOWN;\n  }\n\n  if (isOllamaFormat(parsedResponse)) {\n    return FORMAT_OLLAMA;\n  }\n  \n  if (isOpenAIFormat(parsedResponse)) {\n    return FORMAT_OPENAI;\n  }\n\n  return FORMAT_UNKNOWN;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/nonStreamingHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[607,610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[607,610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":37,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":37,"endColumn":34,"suggestions":[{"fix":{"range":[1657,1682],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":67,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":67,"endColumn":65},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":73,"column":24,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":73,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":73,"column":24,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":73,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3218,3221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3218,3221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":74,"column":36,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":74,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":74,"column":36,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":74,"endColumn":50}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { convertResponse } from \"../utils/formatConverters.js\";\nimport logger from \"../utils/logger.js\";\nimport { extractToolCallFromWrapper } from \"../utils/xmlToolParser.js\";\n\nimport { FORMAT_OLLAMA, FORMAT_OPENAI } from \"./formatDetector.js\";\n\nimport type { RequestFormat, OpenAIResponse, OllamaResponse } from \"../types/index.js\";\n\nexport function handleNonStreamingResponse(\n  backendResponse: OpenAIResponse | OllamaResponse | unknown,\n  clientFormat: RequestFormat = FORMAT_OPENAI,\n  backendFormat: RequestFormat = FORMAT_OPENAI,\n  knownToolNames: string[] = [],\n): OpenAIResponse | OllamaResponse | any {\n  logger.debug(\n    `[NON-STREAMING] Handling response. Backend format: ${backendFormat}, Client format: ${clientFormat}`,\n  );\n\n  // Check if response contains tool call XML and convert to OpenAI format\n  if (\n    clientFormat === FORMAT_OPENAI &&\n    typeof backendResponse === 'object' &&\n    backendResponse !== null &&\n    'choices' in (backendResponse as Record<string, unknown>) &&\n    Array.isArray((backendResponse as Record<string, unknown>).choices)\n  ) {\n    const br = backendResponse as Record<string, unknown>;\n    const choices = br.choices;\n    const firstChoice = Array.isArray(choices) ? (choices[0] as Record<string, unknown>) : undefined;\n    const rawContent = firstChoice?.message && typeof (firstChoice.message as Record<string, unknown>).content === 'string'\n      ? ((firstChoice.message as Record<string, unknown>).content as string)\n      : undefined;\n\n    // Try to extract tool call from wrapped XML in content (only if string)\n    const toolCall = extractToolCallFromWrapper(rawContent, knownToolNames);\n\n    if (toolCall && toolCall.name) {\n      logger.debug(`[NON-STREAMING] Detected tool call: ${toolCall.name}`);\n      \n      // Convert XML tool call to OpenAI tool_calls format\n      const toolCallId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create response with tool_calls instead of content\n      // Build a minimal, valid OpenAIResponse instead of spreading unknown values\n      const originalModel = typeof br.model === 'string' ? (br.model) : 'unknown-model';\n      const nowSec = Math.floor(Date.now() / 1000);\n      const originalChoice = Array.isArray(br.choices) ? (br.choices as unknown[])[0] as Record<string, unknown> : {} as Record<string, unknown>;\n\n      const convertedResponse: OpenAIResponse = {\n        id: `chatcmpl-proxy-${Date.now()}`,\n        object: 'chat.completion',\n        created: nowSec,\n        model: originalModel,\n  provider: typeof br.provider === 'string' ? (br.provider) : '',\n        choices: [\n          {\n            index: 0,\n            message: {\n              role: 'assistant',\n              content: null,\n              tool_calls: [\n                {\n                  id: toolCallId,\n                  type: 'function',\n                  function: {\n                    name: toolCall.name,\n                    arguments: JSON.stringify(toolCall.arguments || {}),\n                  },\n                },\n              ],\n            },\n            finish_reason: 'tool_calls',\n            logprobs: (originalChoice && 'logprobs' in originalChoice) ? (originalChoice.logprobs as any) : undefined,\n            native_finish_reason: (originalChoice && 'native_finish_reason' in originalChoice) ? (originalChoice.native_finish_reason as string) : '',\n          },\n        ],\n        usage: {\n          prompt_tokens: 0,\n          completion_tokens: 0,\n          total_tokens: 0,\n        },\n      };\n      \n  logger.debug(\"[NON-STREAMING] Converted XML to tool_calls format\");\n  return convertedResponse;\n    }\n  }\n\n  if (clientFormat === backendFormat) {\n    logger.debug(\n      \"[NON-STREAMING] Formats match. Returning backend response directly.\",\n    );\n    return backendResponse as OpenAIResponse | OllamaResponse;\n  } else {\n    logger.debug(\n      `[NON-STREAMING] Converting response: ${backendFormat} -> ${clientFormat}`,\n    );\n    try {\n      const converted = convertResponse(\n        backendFormat,\n        clientFormat,\n        backendResponse as OpenAIResponse | OllamaResponse,\n      );\n      logger.debug(\"[NON-STREAMING] Conversion successful.\");\n      return converted;\n  } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(\n        `[NON-STREAMING] Error converting response from ${backendFormat} to ${clientFormat}:`,\n        errorMessage,\n      );\n\n      const errorPayload = {\n        error: `Failed to convert backend response from ${backendFormat} to ${clientFormat}. Details: ${errorMessage}`,\n      };\n\n      if (clientFormat === FORMAT_OPENAI) {\n        return {\n          object: \"error\",\n          message: errorPayload.error,\n          type: \"proxy_conversion_error\",\n          code: null,\n          param: null,\n        };\n      } else if (clientFormat === FORMAT_OLLAMA) {\n        return {\n          error: errorPayload.error,\n          done: true,\n        };\n      }\n\n      return errorPayload;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/payloadHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/stream/formatConvertingStreamProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[670,673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[670,673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[826,829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[826,829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":72,"column":7,"nodeType":"ChainExpression","messageId":"alwaysTruthy","endLine":72,"endColumn":90},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":72,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":72,"endColumn":90},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":72,"column":12,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":72,"endColumn":14,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2166,2168],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":72,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":72,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2189,2191],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":122,"column":53,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":122,"endColumn":55,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3841,3843],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":259,"column":38,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":259,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8672,8674],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":267,"column":69,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":267,"endColumn":96},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":281,"column":38,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":281,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9524,9526],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":308,"column":38,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":308,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[10486,10488],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":389,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":389,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13215,13218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13215,13218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":455,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":455,"endColumn":26},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":455,"column":13,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":455,"endColumn":26}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { convertResponse } from \"../../utils/formatConverters.js\";\nimport logger from \"../../utils/logger.js\";\nimport { formatSSEChunk } from \"../../utils/sseUtils.js\";\nimport { extractToolCallXMLParser } from \"../../utils/xmlUtils.js\";\nimport { FORMAT_OLLAMA, FORMAT_OPENAI } from \"../formatDetector.js\";\nimport { detectPotentialToolCall } from \"../toolCallHandler.js\";\n\nimport type {\n  RequestFormat,\n  OpenAITool,\n  StreamProcessor,\n  ExtractedToolCall,\n  ToolCallDetectionResult,\n  OpenAIStreamChunk,\n  OllamaResponse\n} from \"../../types/index.js\";\nimport type { Response } from \"express\";\n\ninterface ReferenceChunk {\n  model?: string | undefined;\n  [key: string]: any;\n}\n\ninterface OllamaToolCallResponse extends OllamaResponse {\n  tool_calls: Array<{\n    function: {\n      name: string;\n      arguments: Record<string, any>;\n    };\n  }>;\n  response: string;\n}\n\nexport class FormatConvertingStreamProcessor implements StreamProcessor {\n  public res: Response;\n  private readonly sourceFormat: RequestFormat;\n  private readonly targetFormat: RequestFormat;\n  private buffer: string = \"\";\n  private streamClosed: boolean = false;\n  private isPotentialToolCall: boolean = false;\n  private toolCallBuffer: string = \"\";\n  private knownToolNames: string[] = [];\n  private model: string | null = null;\n\n  constructor(res: Response, sourceFormat: RequestFormat, targetFormat: RequestFormat) {\n    this.res = res;\n    this.sourceFormat = sourceFormat;\n    this.targetFormat = targetFormat;\n    this.buffer = \"\";\n    this.streamClosed = false;\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n    this.knownToolNames = [];\n    this.model = null;\n    \n    logger.debug(\n      `[STREAM PROCESSOR] Initialized FormatConvertingStreamProcessor (${sourceFormat} -> ${targetFormat})`,\n    );\n\n    const contentType =\n      targetFormat === FORMAT_OPENAI\n        ? \"text/event-stream\"\n        : \"application/x-ndjson\";\n    this.res.setHeader(\"Content-Type\", contentType);\n    this.res.setHeader(\"Cache-Control\", \"no-cache\");\n    this.res.setHeader(\"Connection\", \"keep-alive\");\n  }\n\n  setTools(tools: OpenAITool[]): void {\n    this.knownToolNames =\n      tools?.map((t) => t.function?.name).filter((name): name is string => Boolean(name)) || [];\n    logger.debug(\n      \"[STREAM PROCESSOR] FormatConverter known tool names set:\",\n      this.knownToolNames,\n    );\n  }\n\n  processChunk(chunk: Buffer | string): void {\n    if (this.streamClosed) {return;}\n\n    const chunkStr = chunk.toString();\n    logger.debug(\n      `[STREAM PROCESSOR] FormatConverter processing chunk (${chunkStr.length} bytes)`,\n    );\n\n    if (\n      this.sourceFormat === FORMAT_OPENAI &&\n      this.targetFormat === FORMAT_OLLAMA\n    ) {\n      const lines = chunkStr.split(\"\\n\").filter((line) => line.trim() !== \"\");\n      for (const line of lines) {\n        if (line.startsWith(\"data: \")) {\n          const data = line.substring(6).trim();\n\n          if (data === \"[DONE]\") {\n            if (this.isPotentialToolCall && this.toolCallBuffer) {\n              logger.debug(\n                \"[STREAM PROCESSOR] FC: Received [DONE] while buffering potential tool call.\",\n              );\n              this.handleEndOfStreamWhileBufferingXML();\n            }\n\n            if (!this.isPotentialToolCall) {\n              this.res.write(\n                JSON.stringify({\n                  model: this.model ?? \"unknown-model\",\n                  created_at: new Date().toISOString(),\n                  response: \"\",\n                  done: true,\n                }) + \"\\n\",\n              );\n            }\n            this.end();\n            return;\n          }\n\n          try {\n            const parsedChunk = JSON.parse(data) as OpenAIStreamChunk;\n            if (parsedChunk.model) {this.model = parsedChunk.model;}\n\n            const contentDelta = parsedChunk.choices?.[0]?.delta?.content;\n\n            if (contentDelta) {\n              const updatedBuffer = this.toolCallBuffer + contentDelta;\n              const potential: ToolCallDetectionResult = detectPotentialToolCall(\n                updatedBuffer,\n                this.knownToolNames,\n              );\n\n              if (\n                (potential.isPotential) ||\n                this.isPotentialToolCall\n              ) {\n                this.isPotentialToolCall = true;\n                this.toolCallBuffer += contentDelta;\n                logger.debug(\n                  `[STREAM PROCESSOR] FC: Buffering potential tool (${potential.rootTagName}) - Buffer size: ${this.toolCallBuffer.length} chars`,\n                );\n\n                if (potential.isCompletedXml) {\n                  logger.debug(\n                    \"[STREAM PROCESSOR] FC: Completed XML detected. Attempting parsing...\",\n                  );\n\n                  try {\n                    const handled =\n                      this.handleDetectedXMLToolCallForOllama(parsedChunk);\n                    if (handled) {\n                      this.resetToolCallState();\n                      continue;\n                    } else {\n                      logger.debug(\n                        \"[STREAM PROCESSOR] FC: Failed to handle detected tool call, flushing as text\",\n                      );\n                      this.flushXMLBufferAsTextForOllama(parsedChunk);\n                    }\n                  } catch (xmlError: unknown) {\n                    const errorMessage = xmlError instanceof Error ? xmlError.message : 'Unknown XML error';\n                    logger.debug(\n                      \"[STREAM PROCESSOR] FC: XML parsing error:\",\n                      errorMessage,\n                    );\n                    this.flushXMLBufferAsTextForOllama(parsedChunk);\n                  }\n                } else {\n                  logger.debug(\n                    \"[STREAM PROCESSOR] FC: XML not yet complete, continuing to buffer\",\n                  );\n                  continue;\n                }\n              } else {\n                this.buffer += line + \"\\n\\n\";\n              }\n            } else {\n              if (this.isPotentialToolCall && this.toolCallBuffer) {\n                logger.debug(\n                  \"[STREAM PROCESSOR] FC: Non-content chunk received while buffering. Attempting parse.\",\n                );\n                const handled =\n                  this.handleDetectedXMLToolCallForOllama(parsedChunk);\n                if (handled) {\n                  this.resetToolCallState();\n                  continue;\n                } else {\n                  this.flushXMLBufferAsTextForOllama(parsedChunk);\n                }\n              }\n\n              if (!this.isPotentialToolCall) {\n                this.buffer += line + \"\\n\\n\";\n              }\n            }\n          } catch (error: unknown) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            logger.error(\n              \"[STREAM PROCESSOR] FC: Error parsing OpenAI SSE chunk data:\",\n              errorMessage,\n              \"Data:\",\n              data,\n            );\n\n            this.buffer += line + \"\\n\\n\";\n          }\n        } else if (line.trim()) {\n          logger.debug(\n            \"[STREAM PROCESSOR] FC: Received non-SSE line from OpenAI source:\",\n            line,\n          );\n          this.buffer += line + \"\\n\\n\";\n        }\n      }\n\n      this.processBuffer();\n      return;\n    }\n\n    this.buffer += chunkStr;\n    this.processBuffer();\n  }\n\n  private handleDetectedXMLToolCallForOllama(referenceChunk: ReferenceChunk): boolean {\n    logger.debug(\n      \"[STREAM PROCESSOR] FC: Attempting to handle detected tool call XML for Ollama:\",\n      this.toolCallBuffer,\n    );\n    try {\n      const potential: ToolCallDetectionResult = detectPotentialToolCall(\n        this.toolCallBuffer,\n        this.knownToolNames,\n      );\n      if (!potential.isPotential) {\n        logger.debug(\n          \"[STREAM PROCESSOR] FC: Not a valid tool call according to detector\",\n        );\n        return false;\n      }\n\n      // This can now handle code blocks with ```xml and leading non-XML content\n      // Pass knownToolNames to enforce strict matching\n      const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(\n        this.toolCallBuffer,\n        this.knownToolNames,\n      );\n\n      if (!toolCall?.name) {\n        logger.debug(\n          \"[STREAM PROCESSOR] FC: Failed to parse buffered XML as tool call.\",\n        );\n        return false;\n      }\n\n      logger.debug(\n        `[STREAM PROCESSOR] FC: Successfully parsed XML tool call: ${toolCall.name}`,\n      );\n\n      // Create the Ollama tool call structure\n      const ollamaToolCall: OllamaToolCallResponse = {\n  model: this.model ?? referenceChunk?.model ?? \"unknown-model\",\n        created_at: new Date().toISOString(),\n        response: \"\", // No regular response text\n        done: false, // Indicate stream continues (or will be ended by a done message)\n        tool_calls: [\n          {\n            function: {\n              name: toolCall.name,\n              arguments: (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) \n                ? toolCall.arguments\n                : {},\n            },\n          },\n        ],\n      };\n\n      // Write the tool call in Ollama ndjson format\n      this.res.write(JSON.stringify(ollamaToolCall) + \"\\n\");\n      logger.debug(\"[STREAM PROCESSOR] FC: Sent Ollama tool_call chunk.\");\n\n      // Send a follow-up 'done' message immediately to end the stream\n      const doneMessage: OllamaResponse = {\n  model: this.model ?? referenceChunk?.model ?? \"unknown-model\",\n        created_at: new Date().toISOString(),\n        response: \"\",\n        done: true,\n      };\n      this.res.write(JSON.stringify(doneMessage) + \"\\n\");\n      logger.debug(\"[STREAM PROCESSOR] FC: Sent Ollama done message.\");\n\n      return true; // Indicate success\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(\n        \"[STREAM PROCESSOR] FC: Error handling XML tool call for Ollama:\",\n        errorMessage,\n      );\n      return false;\n    }\n  }\n\n  // Flushes the XML buffer as regular text content for Ollama client\n  private flushXMLBufferAsTextForOllama(referenceChunk: ReferenceChunk): void {\n    logger.debug(\n      \"[STREAM PROCESSOR] FC: Flushing XML tool call buffer as text for Ollama:\",\n      this.toolCallBuffer,\n    );\n    if (this.toolCallBuffer) {\n      const textChunk: OllamaResponse = {\n  model: this.model ?? referenceChunk?.model ?? \"unknown-model\",\n        created_at: new Date().toISOString(),\n        response: this.toolCallBuffer, // Send the raw buffer content\n        done: false,\n      };\n      this.res.write(JSON.stringify(textChunk) + \"\\n\");\n    }\n    this.resetToolCallState();\n  }\n\n  // Handles end of stream when buffering XML for Ollama target\n  private handleEndOfStreamWhileBufferingXML(): void {\n    logger.debug(\n      \"[STREAM PROCESSOR] FC: Stream ended while buffering XML. Final check.\",\n    );\n\n    try {\n      // Try to handle the XML now that we have the complete buffer\n      // Our extractToolCallXMLParser can now handle code fences, leading text, etc.\n      const handled = this.handleDetectedXMLToolCallForOllama({\n        model: this.model ?? undefined,\n      });\n      if (handled) {\n        logger.debug(\n          \"[STREAM PROCESSOR] FC: Successfully handled tool call at end of stream.\",\n        );\n        this.resetToolCallState();\n        return; // Handled\n      }\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.debug(\n        \"[STREAM PROCESSOR] FC: Error processing XML at end of stream:\",\n        errorMessage,\n      );\n    }\n\n    // If validation or handling failed, flush as text\n    logger.debug(\n      \"[STREAM PROCESSOR] FC: Failed to handle/validate XML at end of stream, flushing as text.\",\n    );\n    this.flushXMLBufferAsTextForOllama({ model: this.model ?? undefined });\n    // Send final done message after flushing text\n    this.res.write(\n      JSON.stringify({\n  model: this.model ?? \"unknown-model\",\n        created_at: new Date().toISOString(),\n        response: \"\",\n        done: true,\n      }) + \"\\n\",\n    );\n  }\n\n  private resetToolCallState(): void {\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n    logger.debug(\"[STREAM PROCESSOR] FC: Tool call state reset.\");\n  }\n\n  // --- Generic Buffer Processing ---\n  private processBuffer(): void {\n    // Only process if not currently buffering an XML tool call for Ollama\n    if (this.isPotentialToolCall && this.targetFormat === FORMAT_OLLAMA) {\n      logger.debug(\n        \"[STREAM PROCESSOR] FC: Holding buffer processing while accumulating XML.\",\n      );\n      return;\n    }\n\n    let boundary;\n    // Determine the separator based on the SOURCE format\n    const separator = this.sourceFormat === FORMAT_OPENAI ? \"\\n\\n\" : \"\\n\";\n\n    while ((boundary = this.buffer.indexOf(separator)) !== -1) {\n      const piece = this.buffer.substring(0, boundary);\n      this.buffer = this.buffer.substring(boundary + separator.length);\n\n      if (piece.trim() === \"\") {continue;}\n\n      try {\n        let parsedPiece = piece;\n        let sourceJson: any;\n\n        // OpenAI SSE needs special handling for \"data: \" prefix and \"[DONE]\"\n        if (this.sourceFormat === FORMAT_OPENAI) {\n          if (piece.startsWith(\"data: \")) {\n            parsedPiece = piece.slice(6).trim();\n            if (parsedPiece === \"[DONE]\") {\n              logger.debug(\n                \"[STREAM PROCESSOR] Detected [DONE] signal from OpenAI source.\",\n              );\n              // Handle [DONE] based on target format\n              if (this.targetFormat === FORMAT_OLLAMA) {\n                // Send a final \"done\": true message for Ollama\n                this.res.write(\n                  JSON.stringify({\n                    model: this.model ?? \"unknown-model\",\n                    created_at: new Date().toISOString(),\n                    response: \"\",\n                    done: true,\n                  }) + \"\\n\",\n                );\n              } else {\n                // Forward the [DONE] signal for OpenAI target\n                this.res.write(\"data: [DONE]\\n\\n\");\n              }\n              continue; // Skip further processing for [DONE]\n            }\n            // If it's data but not [DONE], parse JSON\n            sourceJson = JSON.parse(parsedPiece);\n            if (sourceJson.model) {this.model = sourceJson.model;} // Store model\n          } else {\n            // Ignore lines not starting with 'data: ' in OpenAI stream\n            logger.debug(\n              \"[STREAM PROCESSOR] Ignoring non-data line from OpenAI source:\",\n              piece,\n            );\n            continue; // Skip non-data lines\n          }\n        } else {\n          // Source is Ollama (ndjson)\n          sourceJson = JSON.parse(parsedPiece);\n          if (sourceJson.model) {this.model = sourceJson.model;} // Store model\n          if (sourceJson.done === true) {\n            logger.debug(\n              \"[STREAM PROCESSOR] Detected 'done: true' from Ollama source.\",\n            );\n            // Handle 'done' based on target format\n            if (this.targetFormat === FORMAT_OPENAI) {\n              // Send [DONE] signal for OpenAI target\n              this.res.write(\"data: [DONE]\\n\\n\");\n            } else {\n              // Forward the 'done' message for Ollama target\n              this.res.write(JSON.stringify(sourceJson) + \"\\n\");\n            }\n            continue; // Skip further processing for done message\n          }\n        }\n\n        // Convert the parsed chunk to the target format\n        const convertedJson = convertResponse(\n          this.sourceFormat,\n          this.targetFormat,\n          sourceJson,\n          true,\n        ); // Indicate it's a stream chunk\n\n        if (convertedJson) {\n          // Write the converted chunk in the target format\n          if (this.targetFormat === FORMAT_OPENAI) {\n            this.res.write(formatSSEChunk(convertedJson)); // Format as SSE\n          } else {\n            // Target is Ollama (ndjson)\n            this.res.write(JSON.stringify(convertedJson) + \"\\n\"); // Format as JSON line\n          }\n        } else {\n          logger.debug(\n            \"[STREAM PROCESSOR] Conversion resulted in null/undefined chunk, skipping write.\",\n          );\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error(\n          `[STREAM PROCESSOR] Error processing/converting chunk (${this.sourceFormat} -> ${this.targetFormat}):`,\n          errorMessage,\n        );\n        logger.error(\"[STREAM PROCESSOR] Failed Chunk Data:\", piece);\n        this.sendErrorToClient(`Error processing stream chunk: ${errorMessage}`);\n      }\n    }\n  }\n\n  end(): void {\n    if (this.streamClosed) {return;}\n    logger.debug(\n      `[STREAM PROCESSOR] Backend stream ended (${this.sourceFormat}). Processing remaining buffer.`,\n    );\n\n    // If we were buffering XML for Ollama when the stream ended, handle it\n    if (\n      this.isPotentialToolCall &&\n      this.toolCallBuffer &&\n      this.targetFormat === FORMAT_OLLAMA\n    ) {\n      this.handleEndOfStreamWhileBufferingXML();\n    }\n    // Process any remaining non-XML data in the main buffer\n    else if (this.buffer.trim()) {\n      logger.debug(\n        \"[STREAM PROCESSOR] Processing final buffer content:\",\n        this.buffer,\n      );\n      // Add a final separator to ensure the last piece is processed\n      const finalSeparator =\n        this.sourceFormat === FORMAT_OPENAI ? \"\\n\\n\" : \"\\n\";\n      this.buffer += finalSeparator;\n      this.processBuffer(); // Process remaining buffer content\n    }\n\n    logger.debug(\"[STREAM PROCESSOR] Finalizing client stream.\");\n    if (!this.res.writableEnded) {\n      // Send final termination signal if not already sent by buffer processing\n      if (\n        this.targetFormat === FORMAT_OPENAI &&\n        !this.buffer.includes(\"data: [DONE]\")\n      ) {\n        this.res.write(\"data: [DONE]\\n\\n\");\n      } else if (\n        this.targetFormat === FORMAT_OLLAMA &&\n        !this.buffer.includes('\"done\":true')\n      ) {\n        // Ensure a final done:true is sent for Ollama if not already handled\n        this.res.write(\n          JSON.stringify({\n            model: this.model ?? \"unknown-model\",\n            created_at: new Date().toISOString(),\n            response: \"\",\n            done: true,\n          }) + \"\\n\",\n        );\n      }\n      this.res.end();\n    }\n    this.streamClosed = true;\n  }\n\n\n  private sendErrorToClient(errorMessage: string): void {\n    if (this.res.headersSent && !this.res.writableEnded) {\n      try {\n        if (this.targetFormat === FORMAT_OPENAI) {\n          const errorChunk = {\n            error: { message: errorMessage, code: \"STREAM_ERROR\" },\n          };\n          this.res.write(formatSSEChunk(errorChunk));\n        } else {\n          // Ollama target\n          const errorPayload = {\n            error: errorMessage,\n            code: \"STREAM_ERROR\",\n            done: true,\n          }; // Mark as done on error\n          this.res.write(JSON.stringify(errorPayload) + \"\\n\");\n        }\n      } catch (writeError: unknown) {\n        const writeErrorMessage = writeError instanceof Error ? writeError.message : 'Unknown write error';\n        logger.error(\n          \"[STREAM PROCESSOR] Failed to write error chunk to client:\",\n          writeErrorMessage,\n        );\n      }\n    } else if (!this.res.headersSent) {\n      // If headers haven't been sent, we can send a proper JSON error response\n      try {\n        this.res.status(500).json({\n          error: { message: errorMessage, code: \"STREAM_INIT_ERROR\" },\n        });\n      } catch (jsonError: unknown) {\n        const jsonErrorMessage = jsonError instanceof Error ? jsonError.message : 'Unknown JSON error';\n        logger.error(\n          \"[STREAM PROCESSOR] Failed to send JSON error response:\",\n          jsonErrorMessage,\n        );\n        // Fallback if JSON fails\n        this.res.status(500).send(`Stream Error: ${errorMessage}`);\n      }\n      this.streamClosed = true; // Ensure stream is marked closed after sending error\n    }\n  }\n\n  closeStream(message: string | null = null): void {\n    if (!this.streamClosed) {\n      if (message) {\n        logger.debug(`[STREAM PROCESSOR] Closing stream: ${message}`);\n      }\n      if (!this.res.writableEnded) {\n        this.res.end();\n      }\n      this.streamClosed = true;\n    }\n  }\n\n  closeStreamWithError(errorMessage: string): void {\n    this.sendErrorToClient(errorMessage);\n    this.closeStream();\n  }\n\n  handleDone(): void {\n    this.end();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/stream/ollamaStreamProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[523,526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[523,526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":56,"column":7,"nodeType":"ChainExpression","messageId":"alwaysTruthy","endLine":56,"endColumn":90},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":56,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":56,"endColumn":90},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":56,"column":12,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":56,"endColumn":14,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1599,1601],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":56,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":56,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1622,1624],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":96,"column":19,"nodeType":null,"messageId":"preferOptionalChain","endLine":96,"endColumn":44,"suggestions":[{"fix":{"range":[2873,2898],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":116,"column":79,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":116,"endColumn":106},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":168,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":168,"endColumn":54},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":169,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":169,"endColumn":43,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5489,5490],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":251,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":251,"endColumn":38,"suggestions":[{"fix":{"range":[7974,7999],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":263,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":263,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":268,"column":73,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":268,"endColumn":100}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport logger from \"../../utils/logger.js\";\nimport { extractToolCallXMLParser } from \"../../utils/xmlUtils.js\";\nimport { detectPotentialToolCall } from \"../toolCallHandler.js\";\n\nimport type {\n  OpenAITool,\n  StreamProcessor,\n  ExtractedToolCall,\n  ToolCallDetectionResult,\n  OllamaResponse\n} from \"../../types/index.js\";\nimport type { Response } from \"express\";\n\ninterface OllamaChunk extends OllamaResponse {\n  response?: string;\n  tool_calls?: Array<{\n    function: {\n      name: string;\n      arguments: Record<string, any>;\n    };\n  }>;\n}\n\nexport class OllamaStreamProcessor implements StreamProcessor {\n  public res: Response;\n  private streamClosed: boolean = false;\n  private knownToolNames: string[] = [];\n  private isPotentialToolCall: boolean = false;\n  private toolCallBuffer: string = \"\";\n  private accumulatedContent: string = \"\";\n  private toolCallDetectedAndHandled: boolean = false;\n  private lastChunk: OllamaChunk | null = null;\n\n  constructor(res: Response) {\n    this.res = res;\n    this.streamClosed = false;\n    this.knownToolNames = [];\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n    this.accumulatedContent = \"\";\n    this.toolCallDetectedAndHandled = false;\n    this.lastChunk = null;\n\n    logger.debug(\n      \"[STREAM PROCESSOR] Initialized OllamaStreamProcessor with tool call buffering\"\n    );\n\n    this.res.setHeader(\"Content-Type\", \"application/x-ndjson\");\n    this.res.setHeader(\"Cache-Control\", \"no-cache\");\n    this.res.setHeader(\"Connection\", \"keep-alive\");\n  }\n\n  setTools(tools: OpenAITool[]): void {\n    this.knownToolNames =\n      tools?.map((t) => t.function?.name).filter((name): name is string => Boolean(name)) || [];\n    logger.debug(\n      \"[STREAM PROCESSOR] Known tool names set:\",\n      this.knownToolNames\n    );\n  }\n\n  processChunk(chunk: Buffer | string): void {\n    if (this.streamClosed || this.toolCallDetectedAndHandled) {return;}\n\n    const chunkStr = chunk.toString();\n\n    try {\n      const chunkJson = JSON.parse(chunkStr) as OllamaChunk;\n      this.lastChunk = chunkJson;\n\n      if (chunkJson.response) {\n        if (this.isPotentialToolCall) {\n          this.toolCallBuffer += chunkJson.response;\n\n          const potential: ToolCallDetectionResult = detectPotentialToolCall(\n            this.toolCallBuffer,\n            this.knownToolNames\n          );\n\n          logger.debug(\n            `[STREAM PROCESSOR] Buffering potential tool - Buffer size: ${this.toolCallBuffer.length} chars`\n          );\n\n          if (potential.isCompletedXml) {\n            logger.debug(\n              \"[STREAM PROCESSOR] Completed potential tool XML detected in Ollama response\"\n            );\n\n            try {\n              const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(\n                this.toolCallBuffer,\n                this.knownToolNames\n              );\n\n              if (toolCall && toolCall.name) {\n                logger.debug(\n                  `[STREAM PROCESSOR] Successfully parsed Ollama tool call: ${toolCall.name}`\n                );\n\n                if (this.accumulatedContent) {\n                  const contentChunk: OllamaChunk = {\n                    ...this.lastChunk,\n                    response: this.accumulatedContent,\n                  };\n                  this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n                  this.accumulatedContent = \"\";\n                }\n\n                const ollamaToolCall: OllamaChunk = {\n                  ...this.lastChunk,\n                  tool_calls: [\n                    {\n                      function: {\n                        name: toolCall.name,\n                        arguments: (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) \n                          ? toolCall.arguments\n                          : {},\n                      },\n                    },\n                  ],\n                  response: \"\",\n                };\n\n                this.res.write(JSON.stringify(ollamaToolCall) + \"\\n\");\n\n                this.resetToolCallState();\n                this.toolCallDetectedAndHandled = true;\n                \n              } else {\n                logger.debug(\n                  \"[STREAM PROCESSOR] Not a valid tool call, flushing buffer as text\"\n                );\n                this.flushBufferAsText();\n              }\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n              logger.debug(\n                \"[STREAM PROCESSOR] Error parsing tool call XML:\",\n                errorMessage\n              );\n              this.flushBufferAsText();\n            }\n          } else {\n            \n          }\n        } else {\n          const xmlIndex = chunkJson.response.indexOf(\"<\");\n\n          if (xmlIndex !== -1) {\n            const textBeforeXml = chunkJson.response.substring(0, xmlIndex);\n            const xmlPortion = chunkJson.response.substring(xmlIndex);\n\n            if (textBeforeXml) {\n              this.accumulatedContent += textBeforeXml;\n            }\n\n            const potential: ToolCallDetectionResult = detectPotentialToolCall(\n              xmlPortion,\n              this.knownToolNames\n            );\n\n            if (\n              potential.isPotential ||\n              (potential.rootTagName &&\n                this.knownToolNames.some(\n                  (t) =>\n                    t.includes(potential.rootTagName!) ||\n                    potential.rootTagName!.includes(\"_\")\n                ))\n            ) {\n              this.isPotentialToolCall = true;\n              this.toolCallBuffer = xmlPortion;\n              logger.debug(\n                `[STREAM PROCESSOR] Started buffering potential Ollama tool call - Buffer: ${xmlPortion}`\n              );\n              \n            } else {\n              this.accumulatedContent += chunkJson.response;\n              const contentChunk: OllamaChunk = {\n                ...chunkJson,\n                response: this.accumulatedContent,\n              };\n              this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n              this.accumulatedContent = \"\";\n            }\n          } else {\n            this.accumulatedContent += chunkJson.response;\n            const contentChunk: OllamaChunk = {\n              ...chunkJson,\n              response: this.accumulatedContent,\n            };\n            this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n            this.accumulatedContent = \"\";\n          }\n        }\n      } else {\n        this.res.write(chunkStr);\n        if (!chunkStr.endsWith(\"\\n\")) {\n          this.res.write(\"\\n\");\n        }\n      }\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.debug(\"Error parsing Ollama response:\", errorMessage);\n\n      this.res.write(chunkStr);\n      if (!chunkStr.endsWith(\"\\n\")) {\n        this.res.write(\"\\n\");\n      }\n    }\n  }\n\n  private flushBufferAsText(): void {\n    if (this.toolCallBuffer) {\n      logger.debug(\"[STREAM PROCESSOR] Flushing tool call buffer as text\");\n      this.accumulatedContent += this.toolCallBuffer;\n\n      const lastChunkSafe = this.lastChunk ?? ({} as OllamaChunk);\n\n      const contentChunk: OllamaChunk = {\n        ...lastChunkSafe,\n        response: this.accumulatedContent,\n      };\n\n      this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n      this.accumulatedContent = \"\";\n    }\n    this.resetToolCallState();\n  }\n\n  private resetToolCallState(): void {\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n  }\n\n  end(): void {\n    if (this.streamClosed) {return;}\n\n    if (this.isPotentialToolCall && this.toolCallBuffer) {\n      logger.debug(\n        \"[STREAM PROCESSOR] Processing buffered tool call at stream end\"\n      );\n\n      try {\n        const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(\n          this.toolCallBuffer,\n          this.knownToolNames\n        );\n\n        if (toolCall && toolCall.name) {\n          if (this.accumulatedContent) {\n            const lastChunkSafe = this.lastChunk ?? ({} as OllamaChunk);\n            const contentChunk: OllamaChunk = {\n              ...lastChunkSafe,\n              response: this.accumulatedContent,\n            };\n            this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n            this.accumulatedContent = \"\";\n          }\n\n          const ollamaToolCall: OllamaChunk = {\n            ...this.lastChunk!,\n            tool_calls: [\n              {\n                function: {\n                  name: toolCall.name,\n                  arguments: (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) \n                    ? toolCall.arguments\n                    : {},\n                },\n              },\n            ],\n            response: \"\",\n          };\n\n          this.res.write(JSON.stringify(ollamaToolCall) + \"\\n\");\n        } else {\n          this.flushBufferAsText();\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.debug(\n          \"[STREAM PROCESSOR] Error parsing final tool call:\",\n          errorMessage\n        );\n        this.flushBufferAsText();\n      }\n    } else if (this.accumulatedContent) {\n      const lastChunkSafe = this.lastChunk ?? ({} as OllamaChunk);\n      const contentChunk: OllamaChunk = {\n        ...lastChunkSafe,\n        response: this.accumulatedContent,\n      };\n      this.res.write(JSON.stringify(contentChunk) + \"\\n\");\n    }\n\n    logger.debug(\"[STREAM PROCESSOR] Ollama backend stream ended.\");\n    if (!this.res.writableEnded) {\n      this.res.end();\n    }\n    this.streamClosed = true;\n  }\n\n\n  closeStreamWithError(errorMessage: string): void {\n    logger.error(\n      `[STREAM PROCESSOR] Closing stream with error: ${errorMessage}`\n    );\n    if (!this.streamClosed && !this.res.writableEnded) {\n      if (!this.res.headersSent) {\n        this.res.status(500).json({\n          error: {\n            message: errorMessage,\n            code: \"STREAM_ERROR\",\n          },\n        });\n      } else {\n        this.res.end();\n      }\n      this.streamClosed = true;\n      logger.debug(\"[STREAM PROCESSOR] Client stream closed due to error.\");\n    }\n  }\n\n  closeStream(message: string | null = null): void {\n    if (!this.streamClosed) {\n      if (message) {\n        logger.debug(`[STREAM PROCESSOR] Closing stream: ${message}`);\n      }\n      if (!this.res.writableEnded) {\n        this.res.end();\n      }\n      this.streamClosed = true;\n    }\n  }\n\n  handleDone(): void {\n    this.end();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/stream/openaiStreamProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":128,"column":26,"nodeType":"Identifier","messageId":"neverNullish","endLine":128,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":128,"column":60,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":128,"endColumn":62,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3788,3790],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":146,"column":11,"nodeType":"MemberExpression","messageId":"alwaysFalsy","endLine":146,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":179,"column":11,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":179,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":179,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":179,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":185,"column":61,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":185,"endColumn":63,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5627,5629],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":188,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":188,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[5784,5817],"text":"(contentDelta?.includes('data: {')) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[5784,5817],"text":"(contentDelta?.includes('data: {')) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":222,"column":47,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":222,"endColumn":49,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7265,7267],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":282,"column":34,"nodeType":"Identifier","messageId":"neverNullish","endLine":282,"endColumn":46},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":315,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":315,"endColumn":38,"suggestions":[{"fix":{"range":[10849,10874],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":320,"column":34,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":320,"endColumn":36,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11109,11111],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":321,"column":18,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":321,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":321,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":321,"endColumn":36},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":321,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":321,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11143,11145],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":364,"column":13,"nodeType":"UnaryExpression","messageId":"alwaysTruthy","endLine":364,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":365,"column":44,"nodeType":"MemberExpression","messageId":"alwaysFalsy","endLine":365,"endColumn":75},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":409,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":409,"endColumn":38,"suggestions":[{"fix":{"range":[13732,13757],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":421,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":421,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[14157,14159],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":456,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":456,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[15019,15021],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":514,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":514,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[16710,16712],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":520,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":520,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[16844,16846],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":521,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":521,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[16861,16891],"text":"(this.model ?? lastChunk?.model)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":521,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":521,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[16892,16894],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":558,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":558,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[17957,17959],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":559,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":559,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[17979,18014],"text":"(this.model ?? referenceChunk?.model)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":559,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":559,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[18007,18009],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import logger from \"../../utils/logger.js\";\nimport {\n  createChatStreamChunk,\n  createFunctionCallStreamChunks,\n  formatSSEChunk,\n} from \"../../utils/sseUtils.js\";\nimport { extractToolCallXMLParser } from \"../../utils/xmlUtils.js\";\nimport { detectPotentialToolCall } from \"../toolCallHandler.js\";\n\nimport type {\n  OpenAITool,\n  OpenAIStreamChunk,\n} from \"../../types/openai.js\";\nimport type {\n  StreamProcessor,\n  ToolCallDetectionResult,\n  ExtractedToolCall,\n} from \"../../types/toolbridge.js\";\nimport type { Response } from \"express\";\n\ntype JsonParseCallback = (json: unknown) => void;\n\nclass JsonStreamParser {\n  private buffer: string;\n  private readonly onParse: JsonParseCallback;\n\n  constructor(onParse: JsonParseCallback) {\n    this.buffer = \"\";\n    this.onParse = onParse;\n  }\n\n  write(chunk: string): void {\n    this.buffer += chunk;\n    this.tryParse();\n  }\n\n  private tryParse(): void {\n    if (this.buffer.trim() !== \"\") {\n      try {\n        const json = JSON.parse(this.buffer);\n        this.onParse(json);\n        this.buffer = \"\";\n        return;\n      } catch (_e) {\n        // fallthrough to heuristic recovery\n      }\n    }\n\n    if (this.buffer.startsWith(\"t.completion.chunk\")) {\n      this.buffer = '{\"objec' + this.buffer;\n    } else if (this.buffer.startsWith(\"pletion.chunk\")) {\n      this.buffer = '{\"object\":\"chat.com' + this.buffer;\n    } else if (this.buffer.startsWith(\"ion.chunk\")) {\n      this.buffer = '{\"object\":\"chat.complet' + this.buffer;\n    } else if (this.buffer.startsWith(',\"object\"')) {\n      this.buffer = '{\"id\":\"fragment\"' + this.buffer;\n    } else if (this.buffer.startsWith('odel\":')) {\n      this.buffer = '{\"m' + this.buffer;\n    } else if (this.buffer.startsWith('oning-plus\"')) {\n      this.buffer = '{\"model\":\"microsoft/Phi-4-reas' + this.buffer;\n    } else if (this.buffer.startsWith(\"plet\")) {\n      this.buffer = '{\"object\":\"chat.com' + this.buffer;\n    }\n\n    try {\n      const json = JSON.parse(this.buffer);\n      this.onParse(json);\n      this.buffer = \"\";\n    } catch (_e) {\n      logger.debug(\"[STREAM PARSER] Incomplete JSON, waiting for more data\");\n    }\n  }\n\n  end(): void {\n    if (this.buffer.trim() !== \"\") {\n      try {\n        const json = JSON.parse(this.buffer);\n        this.onParse(json);\n      } catch (_e) {\n        logger.warn(\n          \"[STREAM PARSER] Discarding incomplete JSON at end of stream:\",\n          this.buffer.length > 50 ? this.buffer.substring(0, 50) + \"...\" : this.buffer,\n        );\n      }\n      this.buffer = \"\";\n    }\n  }\n}\n\ninterface LastChunk {\n  id?: string | null | undefined;\n  model?: string | undefined;\n  xmlContent?: string | undefined;\n  toolCall?: ExtractedToolCall | undefined;\n}\n\nexport class OpenAIStreamProcessor implements StreamProcessor {\n  public res: Response;\n  private streamClosed: boolean;\n  private model: string | null;\n  private knownToolNames: string[];\n  private isPotentialToolCall: boolean;\n  private toolCallBuffer: string;\n  private accumulatedContentBeforeToolCall: string;\n  private toolCallDetectedAndHandled: boolean;\n  private readonly jsonParser: JsonStreamParser;\n\n  constructor(res: Response) {\n    this.res = res;\n    this.streamClosed = false;\n    this.model = null;\n    this.knownToolNames = [];\n\n    logger.debug(\"[STREAM PROCESSOR] Initialized OpenAIStreamProcessor\");\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n    this.accumulatedContentBeforeToolCall = \"\";\n    this.toolCallDetectedAndHandled = false;\n\n    this.jsonParser = new JsonStreamParser((json: unknown) => {\n      this.handleParsedChunk(json as OpenAIStreamChunk);\n    });\n\n    logger.debug(\"[STREAM PROCESSOR] Initialized custom JSON stream parser\");\n  }\n\n  setTools(tools: OpenAITool[]): void {\n  this.knownToolNames = (tools ?? []).map((t) => t.function?.name).filter((n): n is string => Boolean(n));\n    logger.debug(\n      \"[STREAM PROCESSOR] Known tool names set:\",\n      this.knownToolNames\n    );\n  }\n\n  processChunk(chunk: Buffer | string): void {\n    if (this.streamClosed || this.toolCallDetectedAndHandled) {return;}\n\n    const chunkString = chunk.toString(\"utf-8\");\n    logger.debug(\n      `[STREAM PROCESSOR] Processing chunk (${chunkString.length} bytes)`\n    );\n\n    const lines = chunkString.split(\"\\n\").filter((line) => line.trim() !== \"\");\n\n    for (const line of lines) {\n      if (this.toolCallDetectedAndHandled) {break;}\n\n      if (line.startsWith(\"data: \")) {\n        const data = line.substring(6).trim();\n\n        if (data === \"[DONE]\") {\n          logger.debug(\"[STREAM PROCESSOR] Received [DONE] signal\");\n          this.handleDone();\n          continue;\n        }\n\n        this.jsonParser.write(data);\n      } else if (line.startsWith(\": \")) {\n        // SSE comment - ignore per SSE specification (OpenRouter timeout prevention)\n        logger.debug(\"[STREAM PROCESSOR] Ignoring SSE comment:\", line.substring(0, 50));\n        continue;\n      } else if (line.trim()) {\n        logger.debug(\"[STREAM PROCESSOR] Received non-SSE line:\", line);\n        this.jsonParser.write(line);\n      }\n    }\n  }\n\n  private handleParsedChunk(parsedChunk: OpenAIStreamChunk): void {\n    if (this.streamClosed || this.toolCallDetectedAndHandled) {return;}\n\n    logger.debug(\"[STREAM PROCESSOR] Successfully parsed JSON chunk\");\n\n    try {\n      if (parsedChunk.model) {\n        this.model = parsedChunk.model;\n      }\n\n      if (!parsedChunk.choices || parsedChunk.choices.length === 0) {\n        logger.warn(\"[STREAM PROCESSOR] Response contained no choices\");\n        this.handleNoChoicesError();\n        return;\n      }\n\n  let contentDelta: string | undefined = parsedChunk.choices?.[0]?.delta?.content as unknown as string | undefined;\n      \n      // Handle nested SSE format from OpenRouter - content contains \"data: {json}\"\n      if (contentDelta?.includes('data: {')) {\n        try {\n          let extractedContent = '';\n          \n          // Split by SSE data lines and extract content from each\n          const dataLines = contentDelta.split('\\n\\n').filter(line => line.startsWith('data: '));\n          \n          for (const dataLine of dataLines) {\n            try {\n              const nestedJsonStr = dataLine.substring(6); // Remove \"data: \" prefix\n              const nestedJson = JSON.parse(nestedJsonStr);\n              \n              if (nestedJson.choices?.[0]?.delta?.content !== undefined) {\n                extractedContent += nestedJson.choices[0].delta.content;\n                \n                // Update model if available in nested response\n                if (nestedJson.model && !this.model) {\n                  this.model = nestedJson.model;\n                }\n              }\n            } catch (_e) {\n              logger.debug(\"[STREAM PROCESSOR] Failed to parse nested JSON line:\", (_e as Error).message);\n            }\n          }\n          \n          if (extractedContent) {\n            logger.debug(\"[STREAM PROCESSOR] Extracted content from nested SSE format:\", extractedContent);\n            contentDelta = extractedContent;\n          }\n  } catch (_e) {\n          logger.debug(\"[STREAM PROCESSOR] Failed to parse nested SSE format, using content as-is\");\n          // If nested parsing fails, use the original content\n        }\n      }\n      const finishReason = parsedChunk.choices?.[0]?.finish_reason;\n\n      if (contentDelta) {\n        const xmlStartInDelta = contentDelta.indexOf(\"<\");\n        const hasPotentialStartTag = xmlStartInDelta !== -1;\n\n        if (!this.isPotentialToolCall && hasPotentialStartTag) {\n          const textBeforeXml = contentDelta.substring(0, xmlStartInDelta);\n          const xmlPortion = contentDelta.substring(xmlStartInDelta);\n\n          if (textBeforeXml && textBeforeXml.length > 0) {\n            logger.debug(\n              \"[STREAM PROCESSOR] Found text before potential XML:\",\n              textBeforeXml\n            );\n            this.accumulatedContentBeforeToolCall += textBeforeXml;\n            logger.debug(\n              \"[STREAM PROCESSOR] Buffering text before XML, will send if needed\"\n            );\n          }\n\n          this.toolCallBuffer = xmlPortion;\n\n          const isLikelyPartialTag = !xmlPortion.includes(\">\") || (xmlPortion.includes(\"<\") && xmlPortion.includes(\"_\"));\n\n          if (isLikelyPartialTag) {\n            logger.debug(\n              \"[STREAM PROCESSOR] Detected likely partial XML tag - buffering without validation\"\n            );\n            this.isPotentialToolCall = true;\n            return;\n          }\n\n          const potential: ToolCallDetectionResult = detectPotentialToolCall(\n            xmlPortion,\n            this.knownToolNames\n          );\n\n          const rootTag = potential.rootTagName ?? \"\";\n\n          if (\n            (potential.isPotential && potential.mightBeToolCall) ||\n            (rootTag && this.knownToolNames.some((t) => t.includes(rootTag) || rootTag.includes(\"_\")))\n          ) {\n            this.isPotentialToolCall = true;\n            logger.debug(\n              `[STREAM PROCESSOR] Started buffering potential tool (${rootTag}) - Buffer size: ${this.toolCallBuffer.length} chars`\n            );\n            return;\n          } else {\n            logger.debug(\n              \"[STREAM PROCESSOR] XML content does not match known tools, treating as regular content\"\n            );\n            this.accumulatedContentBeforeToolCall += xmlPortion;\n            this.sendSseChunk(parsedChunk);\n            return;\n          }\n        }\n\n        if (this.isPotentialToolCall) {\n          this.toolCallBuffer += contentDelta ?? \"\";\n          const potential: ToolCallDetectionResult = detectPotentialToolCall(\n            this.toolCallBuffer,\n            this.knownToolNames\n          );\n\n          logger.debug(\n            `[STREAM PROCESSOR] Buffering potential tool - Buffer size: ${this.toolCallBuffer.length} chars`\n          );\n\n          if (potential.isCompletedXml) {\n            logger.debug(\n              \"[STREAM PROCESSOR] Completed potential tool XML detected. Extracting...\"\n            );\n\n            const xmlStartIndex = this.toolCallBuffer.indexOf(\"<\");\n            let xmlContent = this.toolCallBuffer;\n            let textBeforeXml = \"\";\n\n            if (xmlStartIndex > 0) {\n              textBeforeXml = this.toolCallBuffer.substring(0, xmlStartIndex);\n              xmlContent = this.toolCallBuffer.substring(xmlStartIndex);\n              logger.debug(\"[STREAM PROCESSOR] Found text before XML in buffer:\", textBeforeXml);\n\n              if (textBeforeXml && textBeforeXml.length > 0) {\n                this.accumulatedContentBeforeToolCall += textBeforeXml;\n                logger.debug(\"[STREAM PROCESSOR] Added text before XML to accumulated buffer\");\n              }\n            }\n\n            try {\n                const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(xmlContent, this.knownToolNames);\n\n        if (toolCall && toolCall.name) {\n                logger.debug(\n                  `[STREAM PROCESSOR] Successfully parsed tool call: ${toolCall.name}`\n                );\n                const handled = this.handleDetectedToolCall({\n                  id: parsedChunk?.id,\n          model: parsedChunk?.model ?? this.model ?? undefined,\n                  xmlContent,\n                  toolCall,\n                });\n                if (handled) {\n                  \n                } else {\n                  this.flushBufferAsText(parsedChunk);\n                  \n                }\n              } else {\n                logger.debug(\n                  \"[STREAM PROCESSOR] Failed to parse as tool call, flushing as text\"\n                );\n                this.flushBufferAsText(parsedChunk);\n                \n              }\n            } catch (error) {\n              logger.debug(\n                \"[STREAM PROCESSOR] Error parsing tool call:\",\n                error\n              );\n              this.flushBufferAsText(parsedChunk);\n              \n            }\n          }\n\n          \n        } else {\n          this.accumulatedContentBeforeToolCall += contentDelta;\n          this.sendSseChunk(parsedChunk);\n        }\n      } else {\n        if (this.isPotentialToolCall && this.toolCallBuffer) {\n          const handled = this.handleDetectedToolCall(parsedChunk);\n          if (handled) {\n            this.toolCallDetectedAndHandled = true;\n            return;\n          } else {\n            this.flushBufferAsText(parsedChunk);\n          }\n        }\n\n        if (!this.toolCallDetectedAndHandled) {\n          if (!(finishReason === \"stop\" && this.toolCallDetectedAndHandled)) {\n            this.sendSseChunk(parsedChunk);\n          }\n        }\n      }\n    } catch (error) {\n      logger.error(\"[STREAM PROCESSOR] Error handling parsed chunk:\", error);\n    }\n  }\n\n  private sendSseChunk(chunk: OpenAIStreamChunk): void {\n    const sseString = formatSSEChunk(chunk);\n    this.res.write(sseString);\n  }\n\n  handleDone(): void {\n    logger.debug(\"[STREAM PROCESSOR] Processing [DONE] signal\");\n\n    this.jsonParser.end();\n\n    if (this.isPotentialToolCall && this.toolCallBuffer) {\n      logger.debug(\n        \"[STREAM PROCESSOR] Received [DONE] while buffering potential tool call.\"\n      );\n\n      const xmlStartIndex = this.toolCallBuffer.indexOf(\"<\");\n      let xmlContent = this.toolCallBuffer;\n      let textBeforeXml = \"\";\n\n      if (xmlStartIndex > 0) {\n        textBeforeXml = this.toolCallBuffer.substring(0, xmlStartIndex);\n        xmlContent = this.toolCallBuffer.substring(xmlStartIndex);\n        logger.debug(\n          \"[STREAM PROCESSOR] Found text before XML:\",\n          textBeforeXml\n        );\n      }\n\n      try {\n        const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(\n          xmlContent,\n          this.knownToolNames\n        );\n\n        if (toolCall && toolCall.name) {\n          logger.debug(\n            `[STREAM PROCESSOR] Valid tool call found at end of stream: ${toolCall.name}`\n          );\n\n          if (textBeforeXml) {\n            this.accumulatedContentBeforeToolCall += textBeforeXml;\n            this.flushAccumulatedTextAsChunk();\n          }\n\n          const handled = this.handleDetectedToolCall({\n            id: null,\n            model: this.model || undefined,\n            xmlContent: xmlContent,\n            toolCall: toolCall,\n          });\n\n          if (handled) {\n            this.res.write(\"data: [DONE]\\n\\n\");\n            this.end();\n            return;\n          }\n        }\n      } catch (error) {\n        logger.debug(\n          \"[STREAM PROCESSOR] Error parsing XML at end of stream:\",\n          error\n        );\n      }\n    }\n\n    if (this.accumulatedContentBeforeToolCall) {\n      logger.debug(\n        \"[STREAM PROCESSOR] Flushing accumulated text before DONE:\",\n        this.accumulatedContentBeforeToolCall\n      );\n      this.flushAccumulatedTextAsChunk();\n    }\n\n    if (!this.toolCallDetectedAndHandled) {\n      this.res.write(\"data: [DONE]\\n\\n\");\n    }\n\n    this.end();\n  }\n\n  private handleDetectedToolCall(lastChunk?: LastChunk): boolean {\n    const xmlToProcess = lastChunk?.xmlContent || this.toolCallBuffer;\n\n    logger.debug(\n      \"[STREAM PROCESSOR] Attempting to handle detected tool call XML:\",\n      xmlToProcess\n    );\n\n    try {\n      const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(\n        xmlToProcess,\n        this.knownToolNames\n      );\n\n      if (!toolCall?.name) {\n        logger.warn(\n          \"[STREAM PROCESSOR] Failed to parse buffered XML as tool call - parser returned:\",\n          toolCall\n        );\n        return false;\n      }\n\n      logger.debug(\n        `[STREAM PROCESSOR] Successfully parsed XML tool call: ${toolCall.name}`\n      );\n      logger.debug(\n        `[STREAM PROCESSOR] Tool call arguments:`,\n        JSON.stringify(toolCall.arguments, null, 2)\n      );\n\n      if (this.accumulatedContentBeforeToolCall) {\n        const prefacePatterns = [\n          \"I'll\",\n          \"I will\",\n          \"Let me\",\n          \"Here's\",\n          \"Here is\",\n          \"I'm going to\",\n          \"Let's\",\n          \"I can\",\n          \"I am going to\",\n        ];\n\n        const isLikelyToolCallPreface = prefacePatterns.some((pattern) =>\n          this.accumulatedContentBeforeToolCall.includes(pattern)\n        );\n\n        if (isLikelyToolCallPreface) {\n          logger.debug(\n            \"[STREAM PROCESSOR] Detected likely tool call preface text, not sending separately:\",\n            this.accumulatedContentBeforeToolCall\n          );\n\n          this.accumulatedContentBeforeToolCall = \"\";\n        } else {\n          logger.debug(\n            \"[STREAM PROCESSOR] Sending accumulated text before tool call:\",\n            this.accumulatedContentBeforeToolCall\n          );\n          this.flushAccumulatedTextAsChunk(lastChunk?.id || null);\n        }\n      }\n\n      const functionCallChunks = createFunctionCallStreamChunks(\n        toolCall,\n        lastChunk?.id || null,\n        this.model || lastChunk?.model || null\n      );\n\n      functionCallChunks.forEach((chunk) => {\n        const sseString = formatSSEChunk(chunk);\n        logger.debug(\n          \"[STREAM PROCESSOR] Sending Tool Call Chunk:\",\n          JSON.stringify(chunk, null, 2)\n        );\n        this.res.write(sseString);\n      });\n\n      this.res.write(\"data: [DONE]\\n\\n\");\n      logger.debug(\n        \"[STREAM PROCESSOR] Sent final [DONE] signal after tool call\"\n      );\n\n      this.resetToolCallState();\n      this.toolCallDetectedAndHandled = true;\n      this.end();\n      logger.debug(\n        \"[STREAM PROCESSOR] Tool call successfully handled, stream closed.\"\n      );\n      return true;\n    } catch (error) {\n      logger.error(\"[STREAM PROCESSOR] Error handling tool call:\", error);\n      return false;\n    }\n  }\n\n  private flushBufferAsText(referenceChunk: OpenAIStreamChunk): void {\n    logger.warn(\n      \"[STREAM PROCESSOR] Flushing tool call buffer as text:\",\n      this.toolCallBuffer\n    );\n    if (this.toolCallBuffer) {\n      const textChunk = createChatStreamChunk(\n        referenceChunk?.id || null,\n        this.model || referenceChunk?.model || null,\n        this.toolCallBuffer,\n        null\n      );\n      const sseString = formatSSEChunk(textChunk);\n\n      this.res.write(sseString);\n\n      this.accumulatedContentBeforeToolCall += this.toolCallBuffer;\n    }\n    this.resetToolCallState();\n  }\n\n  private flushAccumulatedTextAsChunk(id: string | null = null): void {\n    if (this.accumulatedContentBeforeToolCall) {\n      const textChunk = createChatStreamChunk(\n        id,\n        this.model,\n        this.accumulatedContentBeforeToolCall,\n        null\n      );\n      const sseString = formatSSEChunk(textChunk);\n      this.res.write(sseString);\n      this.accumulatedContentBeforeToolCall = \"\";\n    }\n  }\n\n  private resetToolCallState(): void {\n    this.isPotentialToolCall = false;\n    this.toolCallBuffer = \"\";\n  }\n\n  private resetAllBuffers(): void {\n    this.resetToolCallState();\n    this.accumulatedContentBeforeToolCall = \"\";\n  }\n\n  end(): void {\n    if (!this.streamClosed && !this.res.writableEnded) {\n      this.resetAllBuffers();\n      logger.debug(\"[STREAM PROCESSOR] OpenAI backend stream ended normally.\");\n      this.closeStream();\n    }\n  }\n\n  closeStream(message: string | null = null): void {\n    if (!this.streamClosed && !this.res.writableEnded) {\n      if (message) {\n        const errorPayload =\n          typeof message === \"object\" ? message : { error: message };\n        this.res.write(formatSSEChunk(errorPayload));\n      }\n      this.res.end();\n      this.streamClosed = true;\n      logger.debug(\"[STREAM PROCESSOR] Client stream closed.\");\n    }\n  }\n\n  closeStreamWithError(errorMessage: string): void {\n    logger.error(\n      `[STREAM PROCESSOR] Closing stream with error: ${errorMessage}`\n    );\n    if (!this.streamClosed && !this.res.writableEnded) {\n      this.closeStream(JSON.stringify({\n        object: \"error\",\n        message: errorMessage,\n        type: \"proxy_stream_error\",\n        code: null,\n        param: null,\n      }));\n    }\n  }\n\n  private handleNoChoicesError(): void {\n    logger.warn(\n      \"[STREAM PROCESSOR] Response contained no choices error detected\"\n    );\n\n    if (!this.accumulatedContentBeforeToolCall && !this.toolCallBuffer) {\n      const syntheticResponse: OpenAIStreamChunk = {\n        id: \"synthetic_response\",\n        object: \"chat.completion.chunk\",\n        created: Math.floor(Date.now() / 1000),\n  model: this.model ?? \"unknown\",\n        choices: [\n          {\n            index: 0,\n            delta: {\n              content:\n                \"I received your message but could not generate a response. Please try again.\",\n            },\n            finish_reason: null,\n          },\n        ],\n      };\n\n      const sseString = `data: ${JSON.stringify(syntheticResponse)}\\n\\n`;\n      this.res.write(sseString);\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/stream/wrapperAwareStreamProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":39,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":39,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1339,1341],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":50,"column":26,"nodeType":"Identifier","messageId":"neverNullish","endLine":50,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":50,"column":60,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":50,"endColumn":62,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1676,1678],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":53,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":53,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1852,1854],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":148,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":148,"endColumn":38,"suggestions":[{"fix":{"range":[5699,5724],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":168,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":168,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":168,"column":17,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":168,"endColumn":39},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":168,"column":17,"nodeType":null,"messageId":"preferOptionalChain","endLine":168,"endColumn":69,"suggestions":[{"fix":{"range":[6416,6468],"text":"this.originalProcessor?.end"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":168,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":168,"endColumn":69},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":168,"column":43,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":168,"endColumn":69},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":207,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":207,"endColumn":34,"suggestions":[{"fix":{"range":[7803,7828],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":227,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":227,"endColumn":35},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":227,"column":13,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":227,"endColumn":35},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":227,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":227,"endColumn":65,"suggestions":[{"fix":{"range":[8430,8482],"text":"this.originalProcessor?.end"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":227,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":227,"endColumn":65},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":227,"column":39,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":227,"endColumn":65},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":304,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":304,"endColumn":34,"suggestions":[{"fix":{"range":[10927,10952],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":316,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":316,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11384,11386],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":322,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":322,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11535,11537],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":338,"column":54,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":338,"endColumn":56,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[12043,12045],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":365,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":365,"endColumn":38,"suggestions":[{"fix":{"range":[13018,13043],"text":"toolCall?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":377,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":377,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13465,13467],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":383,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":383,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":383,"column":9,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":383,"endColumn":31},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":383,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":383,"endColumn":61,"suggestions":[{"fix":{"range":[13559,13611],"text":"this.originalProcessor?.end"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":383,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":383,"endColumn":61},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":383,"column":35,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":383,"endColumn":61},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":389,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":389,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13745,13747],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":395,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":395,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13907,13909],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport logger from \"../../utils/logger.js\";\nimport {\n  createChatStreamChunk,\n  createFunctionCallStreamChunks,\n  formatSSEChunk,\n} from \"../../utils/sseUtils.js\";\nimport { extractToolCallFromWrapper } from \"../../utils/xmlToolParser.js\";\nimport { extractToolCallXMLParser } from \"../../utils/xmlUtils.js\";\nimport { detectPotentialToolCall } from \"../toolCallHandler.js\";\n\nimport type {\n  OpenAITool,\n  StreamProcessor,\n  ExtractedToolCall,\n  ToolCallDetectionResult,\n} from \"../../types/index.js\";\nimport type { Response } from \"express\";\nimport type { Readable } from \"stream\";\n\n// Wrapper tags to look for\nconst WRAPPER_START = '<toolbridge:calls>';\nconst WRAPPER_END = '</toolbridge:calls>';\nconst MAX_UNWRAPPED_BUFFER_SIZE = 5000; // Buffer size for unwrapped XML detection\n\nexport class WrapperAwareStreamProcessor implements StreamProcessor {\n  public originalProcessor: StreamProcessor;\n  public res?: Response | undefined;\n  public buffer: string = \"\";\n  public inWrapper: boolean = false;\n  public wrapperContent: string = \"\";\n  public beforeWrapperContent: string = \"\";\n  public knownToolNames: string[] = [];\n  public unwrappedBuffer: string = \"\";\n  public checkingUnwrapped: boolean = false;\n\n  constructor(originalProcessor: StreamProcessor) {\n    this.originalProcessor = originalProcessor;\n    this.res = originalProcessor?.res ?? undefined;\n    this.buffer = \"\";\n    this.inWrapper = false;\n    this.wrapperContent = \"\";\n    this.beforeWrapperContent = \"\";\n    this.knownToolNames = [];\n    this.unwrappedBuffer = \"\";\n    this.checkingUnwrapped = false;\n  }\n\n  setTools(tools: OpenAITool[]): void {\n  this.knownToolNames = (tools ?? []).map((t) => t.function?.name).filter((name): name is string => Boolean(name));\n    logger.debug(\"[WRAPPER PROCESSOR] Known tool names set:\", this.knownToolNames);\n    \n    if (this.originalProcessor?.setTools) {\n      this.originalProcessor.setTools(tools);\n    }\n  }\n\n  processChunk(chunk: Buffer | string): void {\n    let chunkString = chunk.toString(\"utf-8\");\n    \n    // Filter out SSE comments first (per SSE specification)\n    const lines = chunkString.split('\\n');\n    const filteredLines = lines.filter(line => {\n      if (line.startsWith(': ')) {\n        logger.debug(\"[WRAPPER PROCESSOR] Ignoring SSE comment:\", line.substring(0, 50));\n        return false;\n      }\n      return true;\n    });\n    chunkString = filteredLines.join('\\n');\n    \n    // Handle nested SSE format from OpenRouter - content contains \"data: {json}\"\n    if (chunkString.includes('data: {')) {\n      let extractedContent = '';\n      \n      // Split by SSE data lines and extract content from each\n      const dataLines = chunkString.split('\\n\\n').filter(line => line.startsWith('data: '));\n      \n      for (const dataLine of dataLines) {\n        try {\n          const nestedJsonStr = dataLine.substring(6); // Remove \"data: \" prefix\n          const nestedJson = JSON.parse(nestedJsonStr);\n          \n          if (nestedJson.choices?.[0]?.delta?.content !== undefined) {\n            extractedContent += nestedJson.choices[0].delta.content;\n          }\n        } catch (error: unknown) {\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          logger.debug(\"[WRAPPER PROCESSOR] Failed to parse nested JSON line:\", errorMessage);\n        }\n      }\n      \n      if (extractedContent) {\n        logger.debug(\"[WRAPPER PROCESSOR] Extracted content from nested SSE format:\", extractedContent);\n        chunkString = extractedContent;\n      }\n    }\n    \n    this.buffer += chunkString;\n    \n    // Check if we have a complete wrapper (use clean version for checking)\n    while (this.checkForCompleteWrapper()) {\n      // Process the complete wrapped tool call\n      this.processWrappedToolCall();\n    }\n    \n    // If no wrapper detected, check for unwrapped XML\n    if (!this.inWrapper && !this.buffer.includes(WRAPPER_START)) {\n      this.processUnwrappedContent();\n    }\n  }\n\n  private processUnwrappedContent(): void {\n    // Add current buffer to unwrapped buffer\n    this.unwrappedBuffer += this.buffer;\n    this.buffer = \"\";\n    \n    logger.debug(`[TOOL DETECTOR] Checking content (${this.unwrappedBuffer.length} chars): ${this.unwrappedBuffer.substring(0, 100)}...`);\n    \n    // Check if we have potential unwrapped tool calls\n    if (this.knownToolNames.length > 0) {\n      const potential: ToolCallDetectionResult = detectPotentialToolCall(this.unwrappedBuffer, this.knownToolNames);\n      \n      if (potential.isPotential) {\n        this.checkingUnwrapped = true;\n        logger.debug(`[WRAPPER PROCESSOR] Detected potential unwrapped tool: ${potential.rootTagName}`);\n        \n        if (potential.isCompletedXml) {\n          logger.debug(\"[WRAPPER PROCESSOR] Complete unwrapped XML detected, attempting extraction\");\n          this.processUnwrappedToolCall();\n          return;\n        }\n        \n        // Continue buffering if XML looks incomplete but promising\n        if (this.unwrappedBuffer.length < MAX_UNWRAPPED_BUFFER_SIZE) {\n          logger.debug(\"[WRAPPER PROCESSOR] Buffering incomplete unwrapped XML\");\n          return;\n        }\n      }\n      \n      // Also check if we can detect wrapper tags in the accumulated buffer\n      const cleanBuffer = this.getCleanBufferForParsing(this.unwrappedBuffer);\n      if (cleanBuffer.includes('<toolbridge:calls>') && cleanBuffer.includes('</toolbridge:calls>')) {\n        logger.debug(\"[WRAPPER PROCESSOR] Found complete wrapper tags in unwrapped buffer!\");\n        \n        // Extract the wrapped content and process it\n        const toolCall: ExtractedToolCall | null = extractToolCallFromWrapper(this.unwrappedBuffer, this.knownToolNames);\n        if (toolCall && toolCall.name) {\n          logger.debug(`[WRAPPER PROCESSOR] Valid tool call found in unwrapped buffer: ${toolCall.name}`);\n          \n          // Send tool call chunks\n          const functionCallChunks = createFunctionCallStreamChunks(\n            toolCall,\n            null, // id will be generated\n            null  // model will be added later\n          );\n          \n          functionCallChunks.forEach(chunk => {\n            const sseString = formatSSEChunk(chunk);\n            if (this.res) {\n              this.res.write(sseString);\n            }\n          });\n          \n          // Send [DONE] signal\n          if (this.res) {\n            this.res.write(\"data: [DONE]\\n\\n\");\n            if (this.originalProcessor && this.originalProcessor.end) {\n              this.originalProcessor.end();\n            }\n          }\n          \n          // Reset state\n          this.unwrappedBuffer = \"\";\n          this.checkingUnwrapped = false;\n          return;\n        }\n      }\n    }\n    \n  // If buffer is getting too large or no potential tool detected, flush as regular content\n  if (this.unwrappedBuffer.length > MAX_UNWRAPPED_BUFFER_SIZE || (!this.checkingUnwrapped && this.unwrappedBuffer.length > 500)) {\n      this.flushUnwrappedAsText();\n    }\n  }\n  \n  private getCleanBufferForParsing(buffer?: string): string {\n  let cleanBuffer = buffer ?? this.buffer;\n    \n    // Remove thinking tags only for parsing check\n    if (cleanBuffer.includes('think') && cleanBuffer.includes('/think')) {\n      cleanBuffer = cleanBuffer.replace(/think[\\s\\S]*?\\/think/g, '');\n    }\n    if (cleanBuffer.includes('<thinking>') && cleanBuffer.includes('</thinking>')) {\n      cleanBuffer = cleanBuffer.replace(/<thinking>[\\s\\S]*?<\\/thinking>/gi, '');\n    }\n    \n    return cleanBuffer;\n  }\n\n  private processUnwrappedToolCall(): void {\n    logger.debug(\"[WRAPPER PROCESSOR] Processing unwrapped tool call\");\n    \n    // Try to extract tool call from unwrapped XML\n    const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(this.unwrappedBuffer, this.knownToolNames);\n    \n    if (toolCall && toolCall.name) {\n      logger.debug(`[WRAPPER PROCESSOR] Valid unwrapped tool call found: ${toolCall.name}`);\n      \n      // Send tool call chunks\n      const functionCallChunks = createFunctionCallStreamChunks(\n        toolCall,\n        null, // id will be generated\n        null  // model will be added later\n      );\n      \n      functionCallChunks.forEach(chunk => {\n        const sseString = formatSSEChunk(chunk);\n        if (this.res) {\n          this.res.write(sseString);\n        }\n      });\n      \n      // Send [DONE] signal\n      if (this.res) {\n        this.res.write(\"data: [DONE]\\n\\n\");\n        if (this.originalProcessor && this.originalProcessor.end) {\n          this.originalProcessor.end();\n        }\n      }\n    } else {\n      logger.debug(\"[WRAPPER PROCESSOR] Failed to extract unwrapped tool call, flushing as text\");\n      this.flushUnwrappedAsText();\n    }\n    \n    // Reset unwrapped state\n    this.unwrappedBuffer = \"\";\n    this.checkingUnwrapped = false;\n  }\n\n  private flushUnwrappedAsText(): void {\n    if (this.unwrappedBuffer.length > 0) {\n      logger.debug(\"[WRAPPER PROCESSOR] Flushing unwrapped buffer as regular text\");\n      this.sendTextContent(this.unwrappedBuffer);\n      this.unwrappedBuffer = \"\";\n      this.checkingUnwrapped = false;\n    }\n  }\n\n  private checkForCompleteWrapper(): boolean {\n    // Use clean buffer for checking wrapper tags (strips thinking tags)\n    const cleanBuffer = this.getCleanBufferForParsing();\n    const startIndex = cleanBuffer.indexOf(WRAPPER_START);\n    \n    // No wrapper start found\n    if (startIndex === -1) {\n      return false;\n    }\n    \n    // Found wrapper start, look for end\n    const endIndex = cleanBuffer.indexOf(WRAPPER_END, startIndex);\n    \n    if (endIndex === -1) {\n      // Start found but no end yet, enter buffering mode\n      this.inWrapper = true;\n      \n      // Save content before wrapper (from original buffer, preserving thinking)\n      if (startIndex > 0) {\n        this.beforeWrapperContent = this.buffer.substring(0, startIndex);\n        this.sendTextContent(this.beforeWrapperContent);\n      }\n      \n      // Buffer from wrapper start\n      this.wrapperContent = this.buffer.substring(startIndex);\n      this.buffer = \"\";\n      return false;\n    }\n    \n    // Complete wrapper found!\n    const wrapperEndPos = endIndex + WRAPPER_END.length;\n    \n    // Extract content before wrapper\n    if (startIndex > 0) {\n      const beforeContent = this.buffer.substring(0, startIndex);\n      this.sendTextContent(beforeContent);\n    }\n    \n    // Extract wrapped content\n    const wrappedContent = this.buffer.substring(startIndex, wrapperEndPos);\n    this.wrapperContent = wrappedContent;\n    \n    // Keep remaining content in buffer\n    this.buffer = this.buffer.substring(wrapperEndPos);\n    \n    return true;\n  }\n\n  private processWrappedToolCall(): void {\n    logger.debug(\"[WRAPPER PROCESSOR] Processing complete wrapped tool call\");\n    \n    // Extract tool call from wrapper\n    const toolCall: ExtractedToolCall | null = extractToolCallFromWrapper(this.wrapperContent, this.knownToolNames);\n    \n    if (toolCall && toolCall.name) {\n      logger.debug(`[WRAPPER PROCESSOR] Valid tool call found: ${toolCall.name}`);\n      \n      // Send tool call chunks\n      const functionCallChunks = createFunctionCallStreamChunks(\n        toolCall,\n        null, // id will be generated\n        null  // model will be added later\n      );\n      \n      functionCallChunks.forEach(chunk => {\n        const sseString = formatSSEChunk(chunk);\n        if (this.originalProcessor?.res) {\n          this.originalProcessor.res.write(sseString);\n        }\n      });\n      \n      // Send [DONE] signal\n      if (this.originalProcessor?.res) {\n        this.originalProcessor.res.write(\"data: [DONE]\\n\\n\");\n        this.originalProcessor.end();\n      }\n    } else {\n      logger.warn(\"[WRAPPER PROCESSOR] Invalid or unrecognized tool in wrapper\");\n      // Send the content as regular text\n      this.sendTextContent(this.wrapperContent);\n    }\n    \n    // Reset wrapper state\n    this.wrapperContent = \"\";\n    this.inWrapper = false;\n  }\n\n  private sendTextContent(content: string): void {\n  if (content.length === 0 || !this.originalProcessor?.res) { return; }\n    \n    const textChunk = createChatStreamChunk(\n      null, // id\n      null, // model\n      content,\n      null  // finish reason\n    );\n    \n    const sseString = formatSSEChunk(textChunk);\n  this.originalProcessor.res.write(sseString);\n  }\n\n  handleDone(): void {\n    // Check if we have incomplete wrapper content\n    if (this.inWrapper && this.wrapperContent) {\n      logger.warn(\"[WRAPPER PROCESSOR] Stream ended with incomplete wrapper\");\n      // Send the incomplete content as regular text\n      this.sendTextContent(this.wrapperContent);\n    }\n    \n  // Check if we have unwrapped buffer content\n  if (this.unwrappedBuffer.length > 0) {\n      logger.debug(\"[WRAPPER PROCESSOR] Stream ended, checking unwrapped buffer for tool calls\");\n      \n      if (this.checkingUnwrapped && this.knownToolNames.length > 0) {\n        const toolCall: ExtractedToolCall | null = extractToolCallXMLParser(this.unwrappedBuffer, this.knownToolNames);\n        if (toolCall && toolCall.name) {\n          logger.debug(`[WRAPPER PROCESSOR] Final unwrapped tool call found: ${toolCall.name}`);\n          this.processUnwrappedToolCall();\n          return; // Don't call original processor's handleDone if we processed a tool call\n        }\n      }\n      \n  // Flush remaining unwrapped content as text\n  this.flushUnwrappedAsText();\n    }\n    \n    // Pass through to original processor\n    if (this.originalProcessor?.handleDone) {\n      this.originalProcessor.handleDone();\n    }\n  }\n\n  end(): void {\n    if (this.originalProcessor && this.originalProcessor.end) {\n      this.originalProcessor.end();\n    }\n  }\n\n  closeStream(message: string | null = null): void {\n    if (this.originalProcessor?.closeStream) {\n      this.originalProcessor.closeStream(message);\n    }\n  }\n\n  closeStreamWithError(errorMessage: string): void {\n    if (this.originalProcessor?.closeStreamWithError) {\n      this.originalProcessor.closeStreamWithError(errorMessage);\n    }\n  }\n\n  pipeFrom(stream: Readable): void {\n    // Set up stream processing\n    stream.on('data', (chunk: Buffer | string) => {\n      this.processChunk(chunk);\n    });\n\n    stream.on('end', () => {\n      this.handleDone();\n    });\n\n    stream.on('error', (error: Error) => {\n      logger.error(\"[WRAPPER PROCESSOR] Stream error:\", error);\n      this.closeStreamWithError(error.message);\n    });\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/streamingHandler.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":40,"column":44,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":40,"endColumn":49},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":40,"column":44,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":40,"endColumn":49},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":87,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":123,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2832,4126],"text":"Processor.prototype.pipeFrom ??= function(sourceStream: Readable): void {\n      sourceStream.on(\"data\", (chunk: Buffer | string) => {\n        try {\n          this.processChunk(chunk);\n        } catch (error: unknown) {\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          logger.error(\n            `[STREAM] Error processing chunk in ${this.constructor.name}:`,\n            error,\n          );\n          this.closeStreamWithError(\n            `Error processing stream chunk: ${errorMessage}`,\n          );\n          sourceStream.destroy();\n        }\n      });\n\n      sourceStream.on(\"end\", () => {\n        try {\n          this.end();\n        } catch (error: unknown) {\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          logger.error(\n            `[STREAM] Error finalizing stream in ${this.constructor.name}:`,\n            error,\n          );\n          this.closeStreamWithError(`Error finalizing stream: ${errorMessage}`);\n        }\n      });\n\n      sourceStream.on(\"error\", (error: Error) => {\n        logger.error(\"[STREAM] Backend stream error:\", error);\n        this.closeStreamWithError(`Stream error from backend: ${error.message}`);\n      });\n    };"},"desc":"Fix to nullish coalescing operator (`??=`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport logger from \"../utils/logger.js\";\n\nimport { FORMAT_OLLAMA, FORMAT_OPENAI } from \"./formatDetector.js\";\nimport { FormatConvertingStreamProcessor } from \"./stream/formatConvertingStreamProcessor.js\";\nimport { OllamaStreamProcessor } from \"./stream/ollamaStreamProcessor.js\";\nimport { OpenAIStreamProcessor } from \"./stream/openaiStreamProcessor.js\";\nimport { WrapperAwareStreamProcessor } from \"./stream/wrapperAwareStreamProcessor.js\";\n\nimport type {\n  RequestFormat,\n  OpenAITool,\n  StreamProcessor\n} from \"../types/index.js\";\nimport type { Response } from \"express\";\nimport type { Readable } from \"stream\";\n\n// Augment the stream processor prototypes with pipeFrom method\ninterface StreamProcessorConstructor {\n  new(...args: unknown[]): StreamProcessor;\n  prototype: StreamProcessor & {\n    pipeFrom?: (sourceStream: Readable) => void;\n    processChunk: (chunk: Buffer | string) => void;\n    end: () => void;\n    closeStreamWithError: (errorMessage: string) => void;\n    constructor: { name: string };\n  };\n}\n\nexport function setupStreamHandler(\n  backendStream: Readable,\n  res: Response,\n  clientRequestFormat: RequestFormat = FORMAT_OPENAI,\n  backendFormat: RequestFormat = FORMAT_OPENAI,\n  tools: OpenAITool[] = [],\n): void {\n  logger.debug(\n    `[STREAM] Setting up handler: client=${clientRequestFormat}, backend=${backendFormat}`,\n  );\n  logger.debug(`[STREAM] Tools received:`, tools ? tools.length : 0, tools);\n\n  let processor: StreamProcessor;\n\n  if (\n    clientRequestFormat === FORMAT_OPENAI &&\n    backendFormat === FORMAT_OPENAI\n  ) {\n    logger.debug(\"[STREAM] Using OpenAI-to-OpenAI with wrapper-aware processor.\");\n    const baseProcessor = new OpenAIStreamProcessor(res);\n    processor = new WrapperAwareStreamProcessor(baseProcessor);\n    if (processor.setTools) {\n      processor.setTools(tools);\n    }\n  } else if (\n    clientRequestFormat === FORMAT_OLLAMA &&\n    backendFormat === FORMAT_OLLAMA\n  ) {\n    logger.debug(\"[STREAM] Using Ollama-to-Ollama pass-through processor.\");\n    processor = new OllamaStreamProcessor(res);\n  } else {\n    logger.debug(\n      `[STREAM] Using format converting processor (${backendFormat} -> ${clientRequestFormat}).`,\n    );\n    processor = new FormatConvertingStreamProcessor(\n      res,\n      backendFormat,\n      clientRequestFormat,\n    );\n    if (processor.setTools) {\n      processor.setTools(tools);\n    }\n  }\n\n  if (processor.pipeFrom) {\n    processor.pipeFrom(backendStream);\n  }\n}\n\n// Add pipeFrom method to stream processors that don't have it\nconst streamProcessors: StreamProcessorConstructor[] = [\n  OpenAIStreamProcessor as StreamProcessorConstructor,\n  OllamaStreamProcessor as StreamProcessorConstructor,\n  FormatConvertingStreamProcessor as StreamProcessorConstructor,\n];\n\nstreamProcessors.forEach((Processor: StreamProcessorConstructor) => {\n  if (!Processor.prototype.pipeFrom) {\n    Processor.prototype.pipeFrom = function(sourceStream: Readable): void {\n      sourceStream.on(\"data\", (chunk: Buffer | string) => {\n        try {\n          this.processChunk(chunk);\n        } catch (error: unknown) {\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          logger.error(\n            `[STREAM] Error processing chunk in ${this.constructor.name}:`,\n            error,\n          );\n          this.closeStreamWithError(\n            `Error processing stream chunk: ${errorMessage}`,\n          );\n          sourceStream.destroy();\n        }\n      });\n\n      sourceStream.on(\"end\", () => {\n        try {\n          this.end();\n        } catch (error: unknown) {\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          logger.error(\n            `[STREAM] Error finalizing stream in ${this.constructor.name}:`,\n            error,\n          );\n          this.closeStreamWithError(`Error finalizing stream: ${errorMessage}`);\n        }\n      });\n\n      sourceStream.on(\"error\", (error: Error) => {\n        logger.error(\"[STREAM] Backend stream error:\", error);\n        this.closeStreamWithError(`Stream error from backend: ${error.message}`);\n      });\n    };\n  }\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/handlers/toolCallHandler.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":9,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":9,"endColumn":19},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":9,"column":7,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":9,"endColumn":19},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":42,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":42,"endColumn":77,"suggestions":[{"fix":{"range":[1039,1109],"text":"codeBlockMatch?.[1]?.includes(\"<\")"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":81,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":81,"endColumn":38,"suggestions":[{"fix":{"range":[2095,2126],"text":"rootTagMatch?.[1]"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":172,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":172,"endColumn":26},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":182,"column":23,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":182,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":185,"column":5,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":185,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":189,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":189,"endColumn":18},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":191,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":191,"endColumn":28},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":195,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":195,"endColumn":18},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":203,"column":3,"nodeType":"Identifier","messageId":"neverNullish","endLine":203,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":214,"column":14,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":214,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":215,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":215,"endColumn":25},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":215,"column":29,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":215,"endColumn":49}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import logger from \"../utils/logger.js\";\n\nimport type { ToolCallDetectionResult } from \"../types/index.js\";\n\nexport function detectPotentialToolCall(\n  content: string,\n  knownToolNames: string[] = []\n): ToolCallDetectionResult {\n  if (logger.debug && content) {\n    const contentPreview =\n      content.length > 200\n        ? content.substring(0, 100) +\n          \"...\" +\n          content.substring(content.length - 100)\n        : content;\n    logger.debug(\n      `[TOOL DETECTOR] Checking content (${content.length} chars): ${contentPreview}`,\n    );\n\n    if (content.includes(\"ToolCalls\")) {\n      logger.debug(\"[TOOL DETECTOR] Found 'ToolCalls' marker in content\");\n    }\n  }\n\n  if (!content) {\n    return {\n      isPotential: false,\n      isCompletedXml: false,\n      rootTagName: null,\n      confidence: 0,\n      mightBeToolCall: false,\n    };\n  }\n\n  const trimmed = content.trim();\n\n  let contentToCheck = trimmed;\n  let isCodeBlock = false;\n\n  const codeBlockMatch = trimmed.match(/```(?:xml)[\\s\\n]?([\\s\\S]*?)[\\s\\n]?```/);\n\n  if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].includes(\"<\")) {\n    contentToCheck = codeBlockMatch[1];\n    isCodeBlock = true;\n  }\n\n  const hasOpeningAngle = contentToCheck.includes(\"<\");\n  if (!hasOpeningAngle) {\n    return {\n      isPotential: false,\n      isCompletedXml: false,\n      rootTagName: null,\n      confidence: 0,\n      mightBeToolCall: false,\n    };\n  }\n\n  const xmlStartIndex = contentToCheck.indexOf(\"<\");\n  const potentialXml = contentToCheck.substring(xmlStartIndex);\n\n  const properXmlTagRegex =\n    /<[a-zA-Z0-9_.-]+(?:(?:\\s+[a-zA-Z0-9_.-]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+))?)*\\s*|\\s*)(?:\\/?>|$)/;\n  const hasProperXmlTag = properXmlTagRegex.test(potentialXml);\n\n  if (!hasProperXmlTag) {\n    return {\n      isPotential: false,\n      isCompletedXml: false,\n      rootTagName: null,\n      confidence: 0,\n      mightBeToolCall: false,\n    };\n  }\n\n  let rootTagName: string | null = null;\n\n  const rootTagMatch = potentialXml.match(\n    /<(?:[a-zA-Z0-9_.-]+:)?([a-zA-Z0-9_.-]+(?:_[a-zA-Z0-9_.-]+)*)(?:[\\s/>])/,\n  );\n\n  if (rootTagMatch && rootTagMatch[1]) {\n    rootTagName = rootTagMatch[1];\n\n    const commonHtmlTags = [\n      \"div\",\n      \"span\",\n      \"p\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"ul\",\n      \"ol\",\n      \"li\",\n      \"table\",\n      \"tr\",\n      \"td\",\n      \"th\",\n      \"a\",\n      \"img\",\n      \"style\",\n      \"script\",\n      \"link\",\n      \"meta\",\n      \"title\",\n      \"head\",\n      \"body\",\n      \"html\",\n      \"form\",\n      \"input\",\n      \"button\",\n      \"textarea\",\n      \"select\",\n      \"option\",\n    ] as const;\n\n    if (commonHtmlTags.includes(rootTagName.toLowerCase() as typeof commonHtmlTags[number])) {\n      logger.debug(\n        `[TOOL DETECTOR] Detected common HTML tag \"${rootTagName}\" - immediately rejecting as tool call`,\n      );\n      return {\n        isPotential: false,\n        isCompletedXml: false,\n        rootTagName: rootTagName,\n        confidence: 0,\n        mightBeToolCall: false,\n      };\n    }\n\n    if (!knownToolNames.includes(rootTagName)) {\n      logger.debug(\n        `[TOOL DETECTOR] XML tag \"${rootTagName}\" is not a recognized tool name - ignoring as potential tool call`,\n      );\n    }\n  } else {\n    return {\n      isPotential: false,\n      isCompletedXml: false,\n      rootTagName: null,\n      confidence: 0,\n      mightBeToolCall: false,\n    };\n  }\n\n  const exactMatchKnownTool = knownToolNames.includes(rootTagName);\n\n  const matchesKnownTool = exactMatchKnownTool;\n\n  if (isCodeBlock) {\n    logger.debug(\n      `[TOOL DETECTOR] Content in code block - requiring exact match: ${matchesKnownTool}`,\n    );\n  } else {\n    logger.debug(\n      `[TOOL DETECTOR] Requiring exact tool name match: ${matchesKnownTool ? \"matched\" : \"no match\"}`,\n    );\n  }\n\n  if (!matchesKnownTool) {\n    return {\n      isPotential: false,\n      isCompletedXml: false,\n      rootTagName: rootTagName,\n      confidence: 0,\n      mightBeToolCall: false,\n    };\n  }\n\n  let hasMatchingClosingTag = false;\n  if (exactMatchKnownTool) {\n    hasMatchingClosingTag = trimmed.includes(`</${rootTagName}>`);\n  } else {\n    hasMatchingClosingTag = knownToolNames.some((tool) =>\n      trimmed.includes(`</${tool}>`),\n    );\n  }\n\n  const isSelfClosing = potentialXml.includes(\"/>\") && !hasMatchingClosingTag;\n\n  const isPotential = hasProperXmlTag && matchesKnownTool;\n\n  const isCompleteXml =\n    exactMatchKnownTool && (hasMatchingClosingTag || isSelfClosing);\n\n  // Calculate confidence score\n  let confidence = 0;\n  if (isPotential) {\n    confidence = 0.5;\n    if (exactMatchKnownTool) {confidence += 0.3;}\n    if (isCompleteXml) {confidence += 0.2;}\n  }\n\n  if (isPotential) {\n    logger.debug(\n      `[TOOL DETECTOR] Content sample: \"${trimmed.substring(0, 50)}...\" (${\n        trimmed.length\n      } chars)`,\n    );\n    logger.debug(\n      `[TOOL DETECTOR] Root tag: \"${\n  rootTagName ?? \"unknown\"\n      }\", Matches known tool: ${matchesKnownTool}, In code block: ${isCodeBlock}`,\n    );\n    if (rootTagName) {\n      logger.debug(\n        `[TOOL DETECTOR] Has closing tag: ${hasMatchingClosingTag}, Self-closing: ${isSelfClosing}`,\n      );\n    }\n    logger.debug(\n      `[TOOL DETECTOR] Is potential: ${isPotential}, Is complete: ${isCompleteXml}`,\n    );\n  } else if (hasOpeningAngle && rootTagName) {\n    if (matchesKnownTool && !exactMatchKnownTool) {\n      logger.debug(\n        `[TOOL DETECTOR] Tag \"${rootTagName}\" could be part of known tool - buffering for complete tag`,\n      );\n    } else {\n      logger.debug(\n        `[TOOL DETECTOR] Tag \"${rootTagName}\" doesn't match any known tool - treating as regular content`,\n      );\n    }\n  }\n\n  return {\n    isPotential: isPotential,\n    isCompletedXml: isCompleteXml,\n    rootTagName: rootTagName,\n    confidence: confidence,\n    mightBeToolCall: isPotential,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/index.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":42,"column":134,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":42,"endColumn":136,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1116,1122],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":45,"endColumn":19},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":45,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1640,1643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1640,1643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3333,3336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3333,3336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-use-before-define","severity":2,"message":"'getNetworkIP' was used before it was defined.","line":207,"column":64,"nodeType":"Identifier","messageId":"noUseBeforeDefine","endLine":207,"endColumn":76}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport os from \"os\";\n\nimport chalk from \"chalk\";\nimport express from \"express\";\nimport stringWidth from \"string-width\";\n\nimport {\n  BACKEND_LLM_BASE_URL,\n  CHAT_COMPLETIONS_FULL_URL,\n  OLLAMA_DEFAULT_CONTEXT_LENGTH,\n  PROXY_HOST,\n  PROXY_PORT,\n  validateConfig,\n} from \"./config.js\";\nimport genericProxy from \"./genericProxy.js\";\nimport chatCompletionsHandler from \"./handlers/chatHandler.js\";\nimport logger from \"./utils/logger.js\";\nimport { logRequest, logResponse } from \"./utils/requestLogger.js\";\n\n// Import types\nimport type { OllamaRequest, OllamaShowResponse } from \"./types/index.js\";\nimport type { Request, Response } from \"express\";\nimport type { Server } from \"http\";\nimport type { AddressInfo } from \"net\";\n\nvalidateConfig();\n\nconst app = express();\n\napp.get(\"/\", (_req: Request, res: Response) => {\n  res.json({\n    message: \"OpenAI Tool Proxy Server is running.\",\n    status: \"OK\",\n    chat_endpoint: \"/v1/chat/completions\",\n    generic_proxy_base: \"/v1\",\n    target_backend: BACKEND_LLM_BASE_URL,\n    target_chat_endpoint: CHAT_COMPLETIONS_FULL_URL,\n  });\n});\n\napp.post(\"/api/show\", express.json(), async (req: Request<{}, OllamaShowResponse, OllamaRequest>, res: Response<OllamaShowResponse>) => {\n  logRequest(req, \"OLLAMA SHOW\");\n\n  if (logger.debug) {\n    logger.debug(\"[OLLAMA SHOW] Body:\", JSON.stringify(req.body, null, 2));\n    logger.debug(\n      \"[OLLAMA SHOW] Headers:\",\n      JSON.stringify(req.headers, null, 2)\n    );\n  }\n\n  const startTime = Date.now();\n  try {\n    const name: string = req.body.model;\n\n    if (!name) {\n      res.status(400).json({\n        error: \"Missing required field: model\"\n      } as any);\n      return;\n    }\n\n    const modelResponse: OllamaShowResponse = {\n      license: \"Apache 2.0 License\",\n      modelfile: `FROM ${name}\\\\nTEMPLATE \\\"{{.System}}\\\\n\\\\n{{.Prompt}}\\\"\\\\nPARAMETER temperature 0.7\\\\nPARAMETER top_p 0.9`,\n      template: \"{{.System}}\\\\n\\\\n{{.Prompt}}\",\n      details: {\n        parent_model: \"\",\n        format: \"gguf\",\n        family: \"llama\",\n        families: [\"llama\"],\n        parameter_size: \"7B\",\n        quantization_level: \"Q4_0\",\n      },\n      model_info: {\n        \"general.architecture\": \"llama\",\n        \"general.file_type\": 2,\n        \"general.parameter_count\": 6738415616,\n        \"general.quantization_version\": 2,\n        \"llama.attention.head_count\": 32,\n        \"llama.attention.head_count_kv\": 32,\n        \"llama.attention.layer_norm_rms_epsilon\": 0.000001,\n        \"llama.block_count\": 32,\n        \"llama.context_length\": OLLAMA_DEFAULT_CONTEXT_LENGTH,\n        \"llama.embedding_length\": 4096,\n        \"llama.feed_forward_length\": 11008,\n        \"llama.rope.dimension_count\": 128,\n        \"llama.rope.freq_base\": 10000,\n        \"llama.vocab_size\": 32000,\n        \"tokenizer.ggml.bos_token_id\": 1,\n        \"tokenizer.ggml.eos_token_id\": 2,\n        \"tokenizer.ggml.model\": \"llama\",\n        \"tokenizer.ggml.padding_token_id\": 0,\n        \"tokenizer.ggml.unknown_token_id\": 0,\n      },\n    };\n\n    res.json(modelResponse);\n    logResponse(200, \"OLLAMA SHOW\", Date.now() - startTime);\n  } catch (error: unknown) {\n    logger.error(\"[OLLAMA SHOW] Error:\", error);\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    res.status(500).json({\n      error: `Error processing show request: ${errorMessage}`\n    } as any);\n  }\n});\n\n// Chat completions endpoint\napp.post(\"/v1/chat/completions\", express.json({ limit: \"50mb\" }), chatCompletionsHandler);\n\n// Generic proxy for all other endpoints\napp.use(\"/v1\", genericProxy);\n\n// 404 handler\napp.use(\"*\", (_req: Request, res: Response) => {\n  res.status(404).json({\n    error: \"Endpoint not found\",\n    message: \"This route is not handled by the proxy server.\",\n  });\n});\n\nconst server: Server = app.listen(PROXY_PORT, PROXY_HOST, () => {\n  const addressInfo = server.address() as AddressInfo | null;\n  \n  if (!addressInfo) {\n    logger.error('[SERVER] Failed to get server address information');\n    process.exit(1);\n  }\n  \n  const actualPort = addressInfo.port;\n  const host = addressInfo.address;\n\n  const displayHost = host === \"0.0.0.0\" ? \"localhost\" : host;\n\n  const BOX_WIDTH = 51;\n\n  const BOX_CHAR = {\n    topLeft: \"\",\n    topRight: \"\",\n    bottomLeft: \"\",\n    bottomRight: \"\",\n    horizontal: \"\",\n    vertical: \"\",\n    leftT: \"\",\n    rightT: \"\",\n    topT: \"\",\n    bottomT: \"\",\n    cross: \"\",\n  };\n\n  function createAlignedLine(text: string): string {\n    const plainText = text.replace(/\\x1b\\[[0-9;]*m/g, \"\");\n    const textWidth = stringWidth(plainText);\n    const padding = Math.max(0, BOX_WIDTH - 2 - textWidth);\n    const leftPadding = Math.floor(padding / 2);\n    const rightPadding = padding - leftPadding;\n\n    return (\n      chalk.bold.blue(BOX_CHAR.vertical) +\n      \" \".repeat(leftPadding) +\n      text +\n      \" \".repeat(rightPadding) +\n      chalk.bold.blue(BOX_CHAR.vertical)\n    );\n  }\n\n  const topBorder = chalk.bold.blue(\n    BOX_CHAR.topLeft +\n      BOX_CHAR.horizontal.repeat(BOX_WIDTH - 2) +\n      BOX_CHAR.topRight\n  );\n\n  const middleSeparator = chalk.bold.blue(\n    BOX_CHAR.leftT + BOX_CHAR.horizontal.repeat(BOX_WIDTH - 2) + BOX_CHAR.rightT\n  );\n\n  const bottomBorder = chalk.bold.blue(\n    BOX_CHAR.bottomLeft +\n      BOX_CHAR.horizontal.repeat(BOX_WIDTH - 2) +\n      BOX_CHAR.bottomRight\n  );\n\n  // Use logger to avoid direct console usage and satisfy ESLint no-console\n  logger.info(\"\");\n  logger.info(topBorder);\n  logger.info(\n    createAlignedLine(chalk.bold.green(\" ToolBridge\") + chalk.dim(\" - LLM Function Calling Proxy\"))\n  );\n  logger.info(createAlignedLine(chalk.dim(`   Running on port: ${actualPort}`)));\n  logger.info(createAlignedLine(chalk.dim(`   Binding address: ${host}`)));\n  logger.info(\n    createAlignedLine(\n      chalk.yellow(\" \") + chalk.cyan(`Proxying to:  `) + chalk.green(`${BACKEND_LLM_BASE_URL}`)\n    )\n  );\n\n  if (!process.env.OLLAMA_BASE_URL) {\n    logger.warn(createAlignedLine(chalk.yellow(\" \") + chalk.yellow.dim(\"OLLAMA_BASE_URL not set\")));\n  }\n\n  logger.info(middleSeparator);\n  logger.info(createAlignedLine(chalk.magenta(\"Available at:\")));\n  logger.info(createAlignedLine(chalk.cyan(`  http://${displayHost}:${actualPort}/v1/chat/completions`)));\n  logger.info(createAlignedLine(chalk.cyan(`  http://localhost:${actualPort}/`)));\n  logger.info(createAlignedLine(chalk.dim(`  Network: http://${getNetworkIP()}:${actualPort}/`)));\n  logger.info(bottomBorder + \"\\n\");\n});\n\nserver.on(\"error\", (error: NodeJS.ErrnoException) => {\n  if (error.syscall !== \"listen\") {\n    throw error;\n  }\n\n  const bind = typeof PROXY_PORT === \"string\" \n    ? \"Pipe \" + PROXY_PORT \n    : \"Port \" + PROXY_PORT;\n\n  switch (error.code) {\n    case \"EACCES\":\n      logger.error(`\\n[ERROR] ${bind} requires elevated privileges.`);\n      process.exit(1);\n      break;\n    case \"EADDRINUSE\":\n      logger.error(`\\n[ERROR] ${bind} is already in use.`);\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n});\n\nfunction getNetworkIP(): string {\n  const interfaces = os.networkInterfaces();\n  for (const name of Object.keys(interfaces)) {\n    const networkInterface = interfaces[name];\n    if (networkInterface) {\n      for (const net of networkInterface) {\n        if (net.family === \"IPv4\" && !net.internal) {\n          return net.address;\n        }\n      }\n    }\n  }\n  return \"localhost\";\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/challenges/generateTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/integration/concurrentRequests.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/integration/general.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ExtractedToolCall' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[725,728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[725,728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[944,947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[944,947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1036,1039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1036,1039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":68,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":68,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1605,1623],"text":"requestBody.stream ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1605,1623],"text":"requestBody.stream === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2039,2042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2039,2042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":150,"column":61,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":150,"endColumn":63,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4012,4014],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":170,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":170,"endColumn":37,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4463,4464],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":171,"column":13,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":171,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":182,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":182,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4739,4740],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":211,"column":13,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":211,"endColumn":20},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":268,"column":16,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":268,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":306,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":306,"endColumn":30,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8572,8573],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":307,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":307,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8629,8630],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8659,8662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8659,8662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { createServer } from \"http\";\n\nimport { expect } from \"chai\";\nimport express from \"express\";\nimport { after, before, describe, it } from \"mocha\";\n\nimport chatCompletionsHandler from \"../../handlers/chatHandler.js\";\nimport { detectPotentialToolCall } from \"../../handlers/toolCallHandler.js\";\nimport { attemptPartialToolCallExtraction } from \"../../utils/xmlUtils.js\";\n\nimport type { \n  ExtractedToolCall, \n  ToolCallDetectionResult, \n  PartialExtractionResult \n} from \"../../types/index.js\";\nimport type { Application, Request, Response } from \"express\";\nimport type { Server } from \"http\";\n\ninterface MockRequest {\n  messages: Array<{ role: string; content: string }>;\n  model: string;\n  stream?: boolean;\n  tools?: any[];\n}\n\ninterface MockResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    message?: {\n      role: string;\n      content: string;\n      tool_calls?: any[];\n    };\n    delta?: {\n      role?: string;\n      content?: string;\n      tool_calls?: any[];\n    };\n    finish_reason: string | null;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nclass MockLLMServer {\n  private readonly app: Application;\n  private server: Server | null = null;\n  public port: number = 0;\n\n  constructor() {\n    this.app = express();\n    this.app.use(express.json());\n    this.setupRoutes();\n  }\n\n  private setupRoutes(): void {\n    this.app.post(\"/v1/chat/completions\", (req: Request, res: Response) => {\n      const requestBody = req.body as MockRequest;\n      \n      if (requestBody.stream) {\n        this.handleStreamingRequest(req, res);\n      } else {\n        this.handleNonStreamingRequest(req, res);\n      }\n    });\n  }\n\n  private handleNonStreamingRequest(req: Request, res: Response): void {\n    const requestBody = req.body as MockRequest;\n    const lastMessage = requestBody.messages[requestBody.messages.length - 1];\n    \n    let responseContent = \"I'm a mock LLM response.\";\n    let toolCalls: any[] | undefined;\n\n    if (lastMessage.content.includes(\"search for\")) {\n      responseContent = \"Let me search for that information.\";\n      toolCalls = [{\n        id: \"call_123\",\n        type: \"function\",\n        function: {\n          name: \"search\",\n          arguments: JSON.stringify({ query: \"test query\" })\n        }\n      }];\n    } else if (lastMessage.content.includes(\"tool call\")) {\n      responseContent = \"<search><query>test search</query></search>\";\n    }\n\n    const response: MockResponse = {\n      id: \"chatcmpl-123\",\n      object: \"chat.completion\",\n      created: Date.now(),\n      model: requestBody.model,\n      choices: [{\n        index: 0,\n        message: {\n          role: \"assistant\",\n          content: responseContent,\n          ...(toolCalls && { tool_calls: toolCalls })\n        },\n        finish_reason: \"stop\"\n      }],\n      usage: {\n        prompt_tokens: 50,\n        completion_tokens: 20,\n        total_tokens: 70\n      }\n    };\n\n    res.json(response);\n  }\n\n  private handleStreamingRequest(req: Request, res: Response): void {\n    const requestBody = req.body as MockRequest;\n    \n    res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\"\n    });\n\n    const chunks = [\n      { delta: { role: \"assistant\", content: \"\" } },\n      { delta: { content: \"I'm \" } },\n      { delta: { content: \"a mock \" } },\n      { delta: { content: \"streaming \" } },\n      { delta: { content: \"response.\" } },\n      { delta: {}, finish_reason: \"stop\" }\n    ];\n\n    let chunkIndex = 0;\n    const sendChunk = (): void => {\n      if (chunkIndex < chunks.length) {\n        const chunk: MockResponse = {\n          id: \"chatcmpl-123\",\n          object: \"chat.completion.chunk\",\n          created: Date.now(),\n          model: requestBody.model,\n          choices: [{\n            index: 0,\n            ...chunks[chunkIndex],\n            finish_reason: chunks[chunkIndex].finish_reason || null\n          }]\n        };\n\n        res.write(`data: ${JSON.stringify(chunk)}\\n\\n`);\n        chunkIndex++;\n        setTimeout(sendChunk, 50);\n      } else {\n        res.write(\"data: [DONE]\\n\\n\");\n        res.end();\n      }\n    };\n\n    sendChunk();\n  }\n\n  public async start(): Promise<void> {\n    return new Promise((resolve) => {\n      this.server = createServer(this.app);\n      this.server.listen(0, () => {\n        const address = this.server!.address();\n        if (address && typeof address === \"object\") {\n          this.port = address.port;\n        }\n        resolve();\n      });\n    });\n  }\n\n  public async stop(): Promise<void> {\n    if (this.server) {\n      return new Promise((resolve) => {\n        this.server!.close(() => resolve());\n      });\n    }\n  }\n}\n\ndescribe(\"Integration Tests\", function () {\n  this.timeout(10000);\n  \n  let mockServer: MockLLMServer;\n  let proxyApp: Application;\n  let proxyServer: Server;\n  let proxyPort: number;\n\n  before(async function () {\n    mockServer = new MockLLMServer();\n    await mockServer.start();\n\n    process.env.UPSTREAM_HOST = \"localhost\";\n    process.env.UPSTREAM_PORT = mockServer.port.toString();\n\n    proxyApp = express();\n    proxyApp.use(express.json());\n    proxyApp.post(\"/v1/chat/completions\", chatCompletionsHandler);\n\n    proxyServer = createServer(proxyApp);\n    await new Promise<void>((resolve) => {\n      proxyServer.listen(0, () => {\n        const address = proxyServer.address();\n        if (address && typeof address === \"object\") {\n          proxyPort = address.port;\n        }\n        resolve();\n      });\n    });\n  });\n\n  after(async function () {\n    await mockServer.stop();\n    await new Promise<void>((resolve) => {\n      proxyServer.close(() => resolve());\n    });\n  });\n\n  describe(\"Non-streaming completions\", function () {\n    it(\"should proxy non-streaming requests correctly\", async function () {\n      const response = await fetch(`http://localhost:${proxyPort}/v1/chat/completions`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          messages: [{ role: \"user\", content: \"Hello\" }],\n          model: \"test-model\",\n          stream: false\n        })\n      });\n\n      expect(response.ok).to.be.true;\n      const data = await response.json() as MockResponse;\n      expect(data.choices[0].message?.content).to.include(\"mock LLM response\");\n    });\n  });\n\n  describe(\"Streaming completions\", function () {\n    it(\"should handle streaming responses\", async function () {\n      const response = await fetch(`http://localhost:${proxyPort}/v1/chat/completions`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          messages: [{ role: \"user\", content: \"Hello\" }],\n          model: \"test-model\",\n          stream: true\n        })\n      });\n\n      expect(response.ok).to.be.true;\n      expect(response.headers.get(\"content-type\")).to.include(\"text/event-stream\");\n      \n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error(\"No reader available\");\n      }\n\n      let chunks: string[] = [];\n      const decoder = new TextDecoder();\n      \n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {break;}\n          \n          const chunk = decoder.decode(value);\n          chunks.push(chunk);\n          \n          if (chunk.includes(\"[DONE]\")) {break;}\n        }\n      } finally {\n        reader.releaseLock();\n      }\n\n      expect(chunks.length).to.be.greaterThan(0);\n      const fullResponse = chunks.join(\"\");\n      expect(fullResponse).to.include(\"streaming\");\n    });\n  });\n\n  describe(\"Tool call detection\", function () {\n    it(\"should detect potential tool calls in streaming content\", function () {\n      const knownTools = [\"search\", \"calculate\", \"think\"];\n      const content = \"<search><query>test\";\n      \n      const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownTools);\n      \n      expect(result.isPotential).to.be.true;\n      expect(result.rootTag).to.equal(\"search\");\n    });\n\n    it(\"should extract complete tool calls\", function () {\n      const knownTools = [\"search\", \"calculate\", \"think\"];\n      const content = \"<search><query>test query</query></search>\";\n      \n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownTools);\n      \n      expect(result.complete).to.be.true;\n      expect(result.toolCall).to.not.be.null;\n      expect(result.toolCall!.name).to.equal(\"search\");\n      expect((result.toolCall!.arguments as Record<string, any>).query).to.equal(\"test query\");\n    });\n  });\n\n  describe(\"Error handling\", function () {\n    it(\"should handle malformed requests gracefully\", async function () {\n      const response = await fetch(`http://localhost:${proxyPort}/v1/chat/completions`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          messages: \"invalid format\"\n        })\n      });\n\n      expect(response.status).to.be.oneOf([400, 500]);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/integration/htmlTool.test.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":81,"column":56,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":81,"endColumn":71,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2200,2206],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2966,2969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2966,2969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3101,3104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3101,3104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3261,3264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3261,3264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3431,3434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3431,3434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function has no 'await' expression.","line":118,"column":73,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":118,"endColumn":88,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3700,3706],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":128,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":128,"endColumn":30,"suggestions":[{"fix":{"range":[4080,4097],"text":"match?.[1]"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5772,5775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5772,5775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5915,5918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5915,5918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6077,6080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6077,6080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { before, describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../types/index.js\";\n\nconst htmlToolContent: string = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <!-- Comments with < and > characters -->\n    <script>\n        if (x < 10 && y > 5) {\n            console.log(\"This would break XML validation\");\n        }\n    </script>\n    <style>\n        body > div {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n    <img src=\"image.jpg\">\n    <br>\n    <input type=\"text\">\n</body>\n</html>`;\n\nfunction createOpenAIDeltaChunk(content: string): string {\n  return `data: ${JSON.stringify({\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: Date.now(),\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: { content },\n        finish_reason: null,\n      },\n    ],\n  })}\\n\\n`;\n}\n\ndescribe(\"HTML in Tool Parameters Tests\", function () {\n  const chunks: string[] = [];\n\n  before(function () {\n    chunks.push(createOpenAIDeltaChunk(\"<insert_edit_into_file>\\n\"));\n    chunks.push(\n      createOpenAIDeltaChunk(\n        \"  <explanation>Add HTML content to the file</explanation>\\n\",\n      ),\n    );\n    chunks.push(\n      createOpenAIDeltaChunk(\"  <filePath>/path/to/file.html</filePath>\\n\"),\n    );\n    chunks.push(createOpenAIDeltaChunk(\"  <code>\"));\n\n    const chunkSize = 50;\n    for (let i = 0; i < htmlToolContent.length; i += chunkSize) {\n      const contentPiece = htmlToolContent.substring(\n        i,\n        Math.min(i + chunkSize, htmlToolContent.length),\n      );\n      chunks.push(createOpenAIDeltaChunk(contentPiece));\n    }\n\n    chunks.push(createOpenAIDeltaChunk(\"</code>\\n\"));\n    chunks.push(createOpenAIDeltaChunk(\"</insert_edit_into_file>\"));\n\n    chunks.push(\"data: [DONE]\\n\\n\");\n  });\n\n  describe(\"XML Parser with HTML in tool\", function () {\n    it(\"should correctly parse XML with HTML content\", async function () {\n      let completeXml = \"<insert_edit_into_file>\\n\";\n      completeXml +=\n        \"  <explanation>Add HTML content to the file</explanation>\\n\";\n      completeXml += \"  <filePath>/path/to/file.html</filePath>\\n\";\n      completeXml += \"  <code>\" + htmlToolContent + \"</code>\\n\";\n      completeXml += \"</insert_edit_into_file>\";\n\n      const knownToolNames: string[] = [\"insert_edit_into_file\"];\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(completeXml, knownToolNames);\n\n      assert.ok(result, \"Result should not be null\");\n      assert.strictEqual(\n        result.name,\n        \"insert_edit_into_file\",\n        \"Tool name should match\",\n      );\n      assert.ok(\n        Object.keys(result.arguments as Record<string, any>).includes(\"code\"),\n        \"Arguments should include code\",\n      );\n      assert.ok(\n        (result.arguments as Record<string, any>).code.includes(\"<!DOCTYPE html>\"),\n        \"HTML in code param should be preserved\",\n      );\n      assert.ok(\n        (result.arguments as Record<string, any>).code.includes(\"if (x < 10 && y > 5)\"),\n        \"JS comparison operators should be preserved\",\n      );\n      assert.ok(\n        (result.arguments as Record<string, any>).code.includes('<img src=\"image.jpg\">'),\n        \"Self-closing HTML tags should be preserved\",\n      );\n    });\n  });\n\n  describe(\"Accumulated buffer parsing with HTML in tool\", function () {\n    it(\"should correctly process and accumulate XML with HTML content\", async function () {\n      const knownToolNames: string[] = [\"insert_edit_into_file\"];\n      let buffer = \"\";\n      let isComplete = false;\n      let isPotential = false;\n      let toolCallResult: ExtractedToolCall | null = null;\n\n      for (let i = 0; i < chunks.length - 1; i++) {\n        const chunk = chunks[i];\n        const match = chunk.match(/data: (.*)\\n\\n/);\n        if (match && match[1]) {\n          try {\n            const data = JSON.parse(match[1]);\n            const contentDelta = data.choices?.[0]?.delta?.content;\n            if (contentDelta) {\n              buffer += contentDelta;\n\n              const potential: ToolCallDetectionResult = detectPotentialToolCall(buffer, knownToolNames);\n              isPotential = potential.isPotential;\n\n              if (potential.isCompletedXml) {\n                isComplete = true;\n                try {\n                  toolCallResult = extractToolCallXMLParser(\n                    buffer,\n                    knownToolNames,\n                  );\n                  break;\n                } catch (_err: unknown) {\n                  const errorMessage = _err instanceof Error ? _err.message : 'Unknown error';\n                  console.log(\n                    \"Expected parse error during test:\",\n                    errorMessage,\n                  );\n                }\n              }\n            }\n          } catch (_err: unknown) {\n            const errorMessage = _err instanceof Error ? _err.message : 'Unknown error';\n            console.log(\"Error during HTML tool test:\", errorMessage);\n          }\n        }\n      }\n\n      assert.ok(buffer.length > 0, \"Buffer should accumulate content\");\n      assert.ok(isPotential, \"Should detect potential tool call\");\n      assert.ok(isComplete, \"Should detect completed XML\");\n      assert.ok(toolCallResult, \"Should successfully parse tool call\");\n      assert.strictEqual(\n        toolCallResult.name,\n        \"insert_edit_into_file\",\n        \"Tool name should match\",\n      );\n      assert.ok(\n        Object.keys(toolCallResult.arguments as Record<string, any>).includes(\"code\"),\n        \"Arguments should include code\",\n      );\n      assert.ok(\n        (toolCallResult.arguments as Record<string, any>).code.includes(\"<!DOCTYPE html>\"),\n        \"HTML content should be preserved\",\n      );\n      assert.ok(\n        (toolCallResult.arguments as Record<string, any>).code.includes(\"if (x < 10 && y > 5)\"),\n        \"JS comparison operators should be preserved\",\n      );\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/integration/openai-sdk-function-execution.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ChatCompletionMessageToolCall' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ChatCompletionChunk' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":60},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":98,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":98,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1985,1987],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'get_weather' has no 'await' expression.","line":107,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":107,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2383,2458],"text":"({ location, unit = \"celsius\" }: WeatherArgs): WeatherResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":116,"column":18,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":116,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":116,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":116,"endColumn":39},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'calculate' has no 'await' expression.","line":129,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":129,"endColumn":20,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3327,3401],"text":"({ expression, operation }: CalculateArgs): CalculateResult"},"desc":"Remove 'async'."}]},{"ruleId":"no-new-func","severity":2,"message":"The Function constructor is eval.","line":134,"column":22,"nodeType":"CallExpression","messageId":"noFunctionConstructor","endLine":134,"endColumn":69},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":138,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":138,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3730,3732],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":140,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":19},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":144,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":144,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3888,3890],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'search_database' has no 'await' expression.","line":149,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":149,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3947,4018],"text":"({ query, table, limit = 10 }: SearchArgs): SearchResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":164,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":164,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4402,4404],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'create_file' has no 'await' expression.","line":170,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":170,"endColumn":22,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4512,4584],"text":"({ filename, content }: CreateFileArgs): CreateFileResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'send_email' has no 'await' expression.","line":181,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":181,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4850,4920],"text":"({ to, subject, body }: SendEmailArgs): SendEmailResult"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'body' is defined but never used. Allowed unused args must match /^_/u.","line":181,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":304,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":304,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":304,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":304,"endColumn":21},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":410,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":410,"endColumn":49},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":415,"column":13,"nodeType":null,"messageId":"preferOptionalChain","endLine":415,"endColumn":47,"suggestions":[{"fix":{"range":[12487,12521],"text":"content?.includes(\"970\")"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'toolCalls' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":590,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":590,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":590,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":590,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18549,18552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18549,18552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { spawn } from \"child_process\";\n\nimport { expect } from \"chai\";\nimport dotenv from \"dotenv\";\nimport { describe, it, before, after } from \"mocha\";\nimport OpenAI from \"openai\";\nimport { ChatCompletionMessageToolCall, ChatCompletionChunk } from \"openai/resources/chat/completions\";\n\nimport type { ChildProcess } from \"child_process\";\n\ndotenv.config();\n\n// Type definitions\ninterface WeatherArgs {\n  location: string;\n  unit?: \"celsius\" | \"fahrenheit\";\n}\n\ninterface WeatherResult {\n  location: string;\n  temperature: string;\n  condition: string;\n  humidity: string;\n  forecast: string;\n}\n\ninterface CalculateArgs {\n  expression: string;\n  operation?: string;\n}\n\ninterface CalculateResult {\n  expression: string;\n  result?: string;\n  error?: string;\n  operation: string;\n}\n\ninterface SearchArgs {\n  query: string;\n  table?: string;\n  limit?: number;\n}\n\ninterface SearchResult {\n  query: string;\n  table: string;\n  total_results: number;\n  results: Array<{\n    id: number;\n    name: string;\n    email: string;\n    joined: string;\n    matched: string;\n  }>;\n}\n\ninterface CreateFileArgs {\n  filename: string;\n  content: string;\n}\n\ninterface CreateFileResult {\n  success: boolean;\n  filename: string;\n  size: number;\n  created_at: string;\n  path: string;\n}\n\ninterface SendEmailArgs {\n  to: string;\n  subject: string;\n  body?: string;\n}\n\ninterface SendEmailResult {\n  success: boolean;\n  message_id: string;\n  to: string;\n  subject: string;\n  sent_at: string;\n  status: string;\n}\n\n// Function type definitions\ntype AvailableFunction = \n  | ((args: WeatherArgs) => Promise<WeatherResult>)\n  | ((args: CalculateArgs) => Promise<CalculateResult>)\n  | ((args: SearchArgs) => Promise<SearchResult>)\n  | ((args: CreateFileArgs) => Promise<CreateFileResult>)\n  | ((args: SendEmailArgs) => Promise<SendEmailResult>);\n\n// Test configuration from environment\nconst PROXY_PORT: string | number = process.env.PROXY_PORT || 3000;\nconst TEST_MODEL: string = process.env.TEST_MODEL || \"mistralai/mistral-small-3.2-24b-instruct:free\";\nconst API_KEY: string | undefined = process.env.BACKEND_LLM_API_KEY;\n\nconsole.log(\"\\n OPENAI SDK FUNCTION EXECUTION TEST\");\nconsole.log(\"Testing real function execution with OpenAI SDK\");\nconsole.log(\"=\".repeat(60));\n\n// Define REAL functions that will be executed\nconst availableFunctions: Record<string, AvailableFunction> = {\n  get_weather: async ({ location, unit = \"celsius\" }: WeatherArgs): Promise<WeatherResult> => {\n    // Simulate weather API call\n    const weatherData: Record<string, { temp: number; condition: string; humidity: number }> = {\n      Tokyo: { temp: 22, condition: \"partly cloudy\", humidity: 65 },\n      London: { temp: 15, condition: \"rainy\", humidity: 80 },\n      \"New York\": { temp: 18, condition: \"sunny\", humidity: 55 },\n      Paris: { temp: 17, condition: \"cloudy\", humidity: 70 },\n    };\n    \n    const data = weatherData[location] || { temp: 20, condition: \"unknown\", humidity: 60 };\n    const tempUnit = unit === \"fahrenheit\" ? \"F\" : \"C\";\n    const tempValue = unit === \"fahrenheit\" ? Math.round(data.temp * 9/5 + 32) : data.temp;\n    \n    return {\n      location,\n      temperature: `${tempValue}${tempUnit}`,\n      condition: data.condition,\n      humidity: `${data.humidity}%`,\n      forecast: \"Stable for next 24 hours\"\n    };\n  },\n  \n  calculate: async ({ expression, operation }: CalculateArgs): Promise<CalculateResult> => {\n    // Real calculator function\n    try {\n      // Safe evaluation for simple math\n      const cleanExpr = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n      const result = Function(`\"use strict\"; return (${cleanExpr})`)();\n      return {\n        expression,\n        result: result.toString(),\n        operation: operation || \"calculation\"\n      };\n    } catch (error: unknown) {\n      return {\n        expression,\n        error: \"Invalid expression\",\n        operation: operation || \"calculation\"\n      };\n    }\n  },\n  \n  search_database: async ({ query, table, limit = 10 }: SearchArgs): Promise<SearchResult> => {\n    // Simulate database search\n    const mockResults = [];\n    for (let i = 1; i <= Math.min(limit, 5); i++) {\n      mockResults.push({\n        id: i,\n        name: `User ${i}`,\n        email: `user${i}@example.com`,\n        joined: \"2024-01-\" + String(i).padStart(2, \"0\"),\n        matched: query.toLowerCase()\n      });\n    }\n    \n    return {\n      query,\n      table: table || \"users\",\n      total_results: mockResults.length,\n      results: mockResults\n    };\n  },\n  \n  create_file: async ({ filename, content }: CreateFileArgs): Promise<CreateFileResult> => {\n    // Simulate file creation (don't actually create files in tests)\n    return {\n      success: true,\n      filename,\n      size: content.length,\n      created_at: new Date().toISOString(),\n      path: `/virtual/test/${filename}`\n    };\n  },\n  \n  send_email: async ({ to, subject, body }: SendEmailArgs): Promise<SendEmailResult> => {\n    // Simulate email sending\n    return {\n      success: true,\n      message_id: `msg_${Date.now()}`,\n      to,\n      subject,\n      sent_at: new Date().toISOString(),\n      status: \"queued\"\n    };\n  }\n};\n\n// Convert functions to OpenAI tools format\nconst tools: OpenAI.Chat.ChatCompletionTool[] = [\n  {\n    type: \"function\",\n    function: {\n      name: \"get_weather\",\n      description: \"Get weather information for a location\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          location: { type: \"string\", description: \"City name\" },\n          unit: { type: \"string\", enum: [\"celsius\", \"fahrenheit\"], description: \"Temperature unit\" }\n        },\n        required: [\"location\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"calculate\",\n      description: \"Perform mathematical calculations\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          expression: { type: \"string\", description: \"Mathematical expression\" },\n          operation: { type: \"string\", description: \"Type of operation\" }\n        },\n        required: [\"expression\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"search_database\",\n      description: \"Search the database\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          query: { type: \"string\", description: \"Search query\" },\n          table: { type: \"string\", description: \"Database table\" },\n          limit: { type: \"number\", description: \"Maximum results\" }\n        },\n        required: [\"query\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"create_file\",\n      description: \"Create a new file with content\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          filename: { type: \"string\", description: \"Name of the file\" },\n          content: { type: \"string\", description: \"File content\" }\n        },\n        required: [\"filename\", \"content\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"send_email\",\n      description: \"Send an email\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          to: { type: \"string\", description: \"Recipient email\" },\n          subject: { type: \"string\", description: \"Email subject\" },\n          body: { type: \"string\", description: \"Email body\" }\n        },\n        required: [\"to\", \"subject\"]\n      }\n    }\n  }\n];\n\ndescribe(\" OpenAI SDK with Real Function Execution\", function() {\n  this.timeout(60000);\n  let proxyProcess: ChildProcess;\n  let openai: OpenAI;\n\n  before(async function() {\n    console.log(\"\\nStarting ToolBridge proxy server...\");\n    \n    // Start proxy server\n    proxyProcess = spawn(\"npm\", [\"start\"], {\n      env: { ...process.env },\n      stdio: process.env.DEBUG_MODE === \"true\" ? \"inherit\" : \"ignore\",\n    });\n\n    // Wait for server to start\n    await new Promise<void>(resolve => setTimeout(resolve, 3000));\n    \n    // Initialize OpenAI client pointing to ToolBridge\n    openai = new OpenAI({\n      baseURL: `http://localhost:${PROXY_PORT}/v1`,\n      apiKey: API_KEY,\n    });\n\n    console.log(` Proxy running on port ${PROXY_PORT}`);\n    console.log(` Using model: ${TEST_MODEL}`);\n    console.log(` API Key: ${API_KEY ? \"Configured\" : \"Missing!\"}`);\n  });\n\n  after(function() {\n    if (proxyProcess) {\n      console.log(\"\\nStopping proxy server...\");\n      proxyProcess.kill();\n    }\n  });\n\n  describe(\"1 Single Function Execution\", function() {\n    it(\"should execute weather function and return actual results\", async function() {\n      console.log(\"\\n Test: Weather function execution\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"What's the weather like in Tokyo?\"\n        }\n      ];\n\n      // Step 1: Get initial response with tool call\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1,\n        max_tokens: 500\n      });\n\n      const message = response.choices[0].message;\n      console.log(\"   Response type:\", message.tool_calls ? \"tool_calls\" : \"content\");\n\n      // Check if tool was called\n      if (message.tool_calls && message.tool_calls.length > 0) {\n        expect(message.tool_calls).to.have.length.greaterThan(0);\n        const toolCall = message.tool_calls[0];\n        \n        console.log(`    Tool called: ${toolCall.function.name}`);\n        console.log(`   Arguments: ${toolCall.function.arguments}`);\n        \n        // Step 2: Execute the actual function\n        const functionName = toolCall.function.name;\n        const functionArgs = JSON.parse(toolCall.function.arguments) as WeatherArgs;\n        \n        expect(functionName).to.equal(\"get_weather\");\n        expect(functionArgs).to.have.property(\"location\");\n        expect(functionArgs.location.toLowerCase()).to.include(\"tokyo\");\n        \n        const functionResult = await (availableFunctions[functionName] as (args: WeatherArgs) => Promise<WeatherResult>)(functionArgs);\n        console.log(\"   Function result:\", JSON.stringify(functionResult, null, 2));\n        \n        // Step 3: Send function result back to model\n        messages.push(message); // Add assistant's tool call\n        messages.push({\n          role: \"tool\",\n          tool_call_id: toolCall.id,\n          content: JSON.stringify(functionResult)\n        });\n        \n        const finalResponse = await openai.chat.completions.create({\n          model: TEST_MODEL,\n          messages,\n          temperature: 0.1,\n          max_tokens: 500\n        });\n        \n        const finalContent = finalResponse.choices[0].message.content;\n        console.log(\"   Final response:\", finalContent?.substring(0, 200) + \"...\");\n        \n        // Verify the model used the function results\n        expect(finalContent?.toLowerCase()).to.include(\"tokyo\");\n        expect(finalContent).to.match(/22|partly cloudy|65/i); // Check for actual data\n        console.log(\"    Model successfully used function results!\");\n      } else {\n        throw new Error(\"No tool call generated when expected\");\n      }\n    });\n\n    it(\"should execute calculation function with actual math\", async function() {\n      console.log(\"\\n Test: Calculator function execution\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"Calculate 42 * 17 + 256\"\n        }\n      ];\n\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      const message = response.choices[0].message;\n      \n      if (message.tool_calls && message.tool_calls.length > 0) {\n        const toolCall = message.tool_calls[0];\n        console.log(`    Tool called: ${toolCall.function.name}`);\n        \n        const functionName = toolCall.function.name;\n        const functionArgs = JSON.parse(toolCall.function.arguments) as CalculateArgs;\n        \n        expect(functionName).to.equal(\"calculate\");\n        \n        const functionResult = await (availableFunctions[functionName] as (args: CalculateArgs) => Promise<CalculateResult>)(functionArgs);\n        console.log(\"   Calculation result:\", functionResult.result);\n        \n        expect(parseFloat(functionResult.result!)).to.equal(970);\n        console.log(\"    Correct calculation performed!\");\n      } else {\n        // Model might calculate directly\n        const content = message.content;\n        if (content && content.includes(\"970\")) {\n          console.log(\"     Model calculated directly without tool\");\n        } else {\n          throw new Error(\"No tool call or correct answer\");\n        }\n      }\n    });\n  });\n\n  describe(\"2 Multiple Function Executions\", function() {\n    it(\"should handle multiple function calls in a conversation\", async function() {\n      console.log(\"\\n Test: Multiple function executions\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"First, check the weather in London. Then search the database for users who joined in January.\"\n        }\n      ];\n\n      let functionsExecuted: string[] = [];\n\n      // First completion\n      const response1 = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1,\n        max_tokens: 800\n      });\n\n      const message1 = response1.choices[0].message;\n      messages.push(message1);\n\n      // Execute all tool calls from first response\n      if (message1.tool_calls) {\n        for (const toolCall of message1.tool_calls) {\n          const functionName = toolCall.function.name;\n          const functionArgs = JSON.parse(toolCall.function.arguments);\n          \n          console.log(`   Executing: ${functionName}`);\n          const result = await availableFunctions[functionName](functionArgs);\n          functionsExecuted.push(functionName);\n          \n          messages.push({\n            role: \"tool\",\n            tool_call_id: toolCall.id,\n            content: JSON.stringify(result)\n          });\n        }\n      }\n\n      // Get final response after function execution\n      const response2 = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1,\n        max_tokens: 800\n      });\n\n      const message2 = response2.choices[0].message;\n\n      // Check if more tools were called\n      if (message2.tool_calls) {\n        for (const toolCall of message2.tool_calls) {\n          const functionName = toolCall.function.name;\n          console.log(`   Executing: ${functionName}`);\n          functionsExecuted.push(functionName);\n        }\n      }\n\n      console.log(`   Functions executed: ${functionsExecuted.join(\", \")}`);\n      expect(functionsExecuted).to.include.members([\"get_weather\", \"search_database\"]);\n      console.log(\"    Multiple functions executed successfully!\");\n    });\n  });\n\n  describe(\"3 Complex Function Parameters\", function() {\n    it(\"should handle complex nested parameters\", async function() {\n      console.log(\"\\n Test: Complex function parameters\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: 'Create a file called report.txt with content \"Q4 2024 Financial Report\\\\n\\\\nRevenue: $1.2M\\\\nExpenses: $800K\"'\n        }\n      ];\n\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      const message = response.choices[0].message;\n      \n      if (message.tool_calls && message.tool_calls.length > 0) {\n        const toolCall = message.tool_calls[0];\n        const functionName = toolCall.function.name;\n        const functionArgs = JSON.parse(toolCall.function.arguments) as CreateFileArgs;\n        \n        expect(functionName).to.equal(\"create_file\");\n        expect(functionArgs.filename).to.include(\"report\");\n        expect(functionArgs.content).to.include(\"Financial\");\n        \n        const result = await (availableFunctions[functionName] as (args: CreateFileArgs) => Promise<CreateFileResult>)(functionArgs);\n        console.log(\"   File creation result:\", result);\n        \n        expect(result.success).to.be.true;\n        expect(result.filename).to.include(\"report\");\n        console.log(\"    Complex parameters handled correctly!\");\n      } else {\n        throw new Error(\"No file creation tool call\");\n      }\n    });\n\n    it(\"should handle email with structured content\", async function() {\n      console.log(\"\\n Test: Email function with structured content\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: 'Send an email to john@example.com with subject \"Meeting Tomorrow\" and body \"Hi John,\\\\n\\\\nLet\\'s meet at 2 PM.\\\\n\\\\nBest regards\"'\n        }\n      ];\n\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      const message = response.choices[0].message;\n      \n      if (message.tool_calls && message.tool_calls.length > 0) {\n        const toolCall = message.tool_calls[0];\n        const functionArgs = JSON.parse(toolCall.function.arguments) as SendEmailArgs;\n        \n        expect(functionArgs.to).to.include(\"@example.com\");\n        expect(functionArgs.subject.toLowerCase()).to.include(\"meeting\");\n        \n        const result = await (availableFunctions.send_email as (args: SendEmailArgs) => Promise<SendEmailResult>)(functionArgs);\n        console.log(\"   Email result:\", result);\n        \n        expect(result.success).to.be.true;\n        expect(result.message_id).to.exist;\n        console.log(\"    Email function executed successfully!\");\n      } else {\n        throw new Error(\"No email tool call\");\n      }\n    });\n  });\n\n  describe(\"4 Streaming with Function Execution\", function() {\n    it(\"should handle function calls in streaming mode\", async function() {\n      console.log(\"\\n Test: Streaming with function execution\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"What's the weather in Paris?\"\n        }\n      ];\n\n      const stream = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        stream: true,\n        temperature: 0.1\n      });\n\n      let toolCalls: any[] = [];\n      let functionName: string | null = null;\n      let functionArguments = \"\";\n\n      for await (const chunk of stream) {\n        if (chunk.choices[0]?.delta?.tool_calls) {\n          for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {\n            if (toolCallDelta.function?.name) {\n              functionName = toolCallDelta.function.name;\n            }\n            if (toolCallDelta.function?.arguments) {\n              functionArguments += toolCallDelta.function.arguments;\n            }\n          }\n        }\n      }\n\n      if (functionName) {\n        console.log(`   Stream generated tool call: ${functionName}`);\n        const args = JSON.parse(functionArguments) as WeatherArgs;\n        console.log(`   Arguments: ${JSON.stringify(args)}`);\n        \n        const result = await (availableFunctions[functionName] as (args: WeatherArgs) => Promise<WeatherResult>)(args);\n        console.log(\"   Function result:\", result);\n        \n        expect(functionName).to.equal(\"get_weather\");\n        expect(args.location.toLowerCase()).to.include(\"paris\");\n        expect(result.location).to.equal(\"Paris\");\n        console.log(\"    Streaming function execution works!\");\n      } else {\n        throw new Error(\"No tool call in stream\");\n      }\n    });\n  });\n\n  describe(\"5 Error Handling\", function() {\n    it(\"should handle invalid function arguments gracefully\", async function() {\n      console.log(\"\\n Test: Invalid function arguments\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"Calculate this invalid expression: 5 / / / 3\"\n        }\n      ];\n\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      const message = response.choices[0].message;\n      \n      if (message.tool_calls && message.tool_calls.length > 0) {\n        const toolCall = message.tool_calls[0];\n        const functionArgs = JSON.parse(toolCall.function.arguments) as CalculateArgs;\n        \n        const result = await (availableFunctions.calculate as (args: CalculateArgs) => Promise<CalculateResult>)(functionArgs);\n        console.log(\"   Function handled error:\", result);\n        \n        expect(result).to.have.property(\"error\");\n        console.log(\"    Error handled gracefully!\");\n      } else {\n        console.log(\"     Model avoided using tool for invalid input\");\n      }\n    });\n\n    it(\"should work when no tools are needed\", async function() {\n      console.log(\"\\n Test: Response without tools\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"user\",\n          content: \"Just say hello!\"\n        }\n      ];\n\n      const response = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      const message = response.choices[0].message;\n      \n      expect(message.content).to.exist;\n      expect(message.tool_calls).to.not.exist;\n      console.log(\"   Response:\", message.content?.substring(0, 50));\n      console.log(\"    Works without tool calls!\");\n    });\n  });\n\n  describe(\"6 Full Conversation Flow\", function() {\n    it(\"should handle complete multi-turn conversation with functions\", async function() {\n      console.log(\"\\n Test: Complete conversation flow\");\n      \n      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [\n        {\n          role: \"system\",\n          content: \"You are a helpful assistant with access to various tools.\"\n        },\n        {\n          role: \"user\",\n          content: \"I need to plan a trip to Tokyo. Check the weather there first.\"\n        }\n      ];\n\n      // Turn 1: Weather check\n      console.log(\"   Turn 1: Weather check\");\n      const response1 = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n\n      messages.push(response1.choices[0].message);\n      \n      if (response1.choices[0].message.tool_calls) {\n        const toolCall = response1.choices[0].message.tool_calls[0];\n        const args = JSON.parse(toolCall.function.arguments) as WeatherArgs;\n        const result = await (availableFunctions.get_weather as (args: WeatherArgs) => Promise<WeatherResult>)(args);\n        \n        messages.push({\n          role: \"tool\",\n          tool_call_id: toolCall.id,\n          content: JSON.stringify(result)\n        });\n        \n        console.log(`   Weather retrieved: ${result.temperature}, ${result.condition}`);\n      }\n\n      // Turn 2: Follow-up\n      const response2 = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        temperature: 0.1\n      });\n      \n      messages.push(response2.choices[0].message);\n      \n      // Turn 3: User asks for email\n      messages.push({\n        role: \"user\",\n        content: \"Great! Now send an email to travel@agency.com about this trip plan.\"\n      });\n      \n      console.log(\"   Turn 3: Email request\");\n      const response3 = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        tools,\n        temperature: 0.1\n      });\n      \n      if (response3.choices[0].message.tool_calls) {\n        const toolCall = response3.choices[0].message.tool_calls[0];\n        const args = JSON.parse(toolCall.function.arguments) as SendEmailArgs;\n        \n        expect(args.to).to.include(\"@agency.com\");\n        const result = await (availableFunctions.send_email as (args: SendEmailArgs) => Promise<SendEmailResult>)(args);\n        console.log(`   Email sent: ${result.message_id}`);\n        \n        messages.push(response3.choices[0].message);\n        messages.push({\n          role: \"tool\",\n          tool_call_id: toolCall.id,\n          content: JSON.stringify(result)\n        });\n      }\n      \n      // Final response\n      const finalResponse = await openai.chat.completions.create({\n        model: TEST_MODEL,\n        messages,\n        temperature: 0.1\n      });\n      \n      console.log(\"   Final:\", finalResponse.choices[0].message.content?.substring(0, 100) + \"...\");\n      console.log(\"    Complete conversation flow successful!\");\n    });\n  });\n});\n\n// Add summary at the end\nprocess.on(\"exit\", () => {\n  console.log(\"\\n\" + \"=\".repeat(60));\n  console.log(\" TEST COMPLETE: ToolBridge enables FULL OpenAI-compatible function calling!\");\n  console.log(\"=\".repeat(60));\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/integration/real-llm-tests.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[601,604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[601,604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[777,780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[777,780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":88,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":88,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1739,1741],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2062,2065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2062,2065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":129,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":129,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":129,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":129,"endColumn":21},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":204,"column":32,"nodeType":null,"messageId":"preferOptionalChain","endLine":204,"endColumn":71,"suggestions":[{"fix":{"range":[5525,5564],"text":"content?.includes(\"<search>\")"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":208,"column":16,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":208,"endColumn":30},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":208,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":208,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5734,5736],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":214,"column":13,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":214,"endColumn":27},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":272,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":272,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7864,7866],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":273,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":273,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7927,7929],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":274,"column":71,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":274,"endColumn":73,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8012,8014],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":364,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":364,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[11173,11175],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":367,"column":43,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":367,"endColumn":45,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11376,11378],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":370,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":370,"endColumn":26,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11446,11459],"text":"hasCreateUser ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[11446,11459],"text":"hasCreateUser === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":439,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":439,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[13779,13781],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":442,"column":43,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":442,"endColumn":45,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13982,13984],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":448,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":448,"endColumn":26,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[14176,14189],"text":"hasInsertCode ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[14176,14189],"text":"hasInsertCode === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fullContent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":520,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":520,"endColumn":24},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":625,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":625,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[19847,19849],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":707,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":707,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22627,22630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22627,22630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":708,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":708,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22699,22702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22699,22702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":721,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":721,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23312,23315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23312,23315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":722,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":722,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23395,23398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23395,23398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":723,"column":76,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":723,"endColumn":78,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[23488,23490],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":774,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":774,"endColumn":95,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[25067,25130],"text":"((response.data.choices[0].message.content?.includes(\"<analyze>\")) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[25067,25130],"text":"((response.data.choices[0].message.content?.includes(\"<analyze>\")) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":774,"column":96,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":774,"endColumn":98,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[25131,25133],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":776,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":776,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[25266,25268],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":779,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":779,"endColumn":27,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[25334,25348],"text":"hasAnalyzeCall ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[25334,25348],"text":"hasAnalyzeCall === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":849,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":849,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[27702,27704],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":852,"column":42,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":852,"endColumn":44,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[27899,27901],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":855,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":855,"endColumn":25,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[27966,27978],"text":"hasCalculate ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[27966,27978],"text":"hasCalculate === true"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawn } from \"child_process\";\n\nimport axios from \"axios\";\nimport { expect } from \"chai\";\nimport dotenv from \"dotenv\";\nimport { describe, it, before, after } from \"mocha\";\n\nimport type { AxiosResponse } from \"axios\";\nimport type { ChildProcess } from \"child_process\";\nimport type { IncomingMessage } from \"http\";\n\ndotenv.config();\n\n// Type definitions\ninterface OpenAIMessage {\n  role: string;\n  content: string;\n}\n\ninterface ToolDefinition {\n  type: \"function\";\n  function: {\n    name: string;\n    description: string;\n    parameters: {\n      type: \"object\";\n      properties: Record<string, any>;\n      required?: string[];\n    };\n  };\n}\n\ninterface ToolCall {\n  id?: string;\n  type?: \"function\";\n  function: {\n    name: string;\n    arguments: string | Record<string, any>;\n  };\n}\n\ninterface CompletionRequest {\n  model: string;\n  messages: OpenAIMessage[];\n  tools?: ToolDefinition[];\n  stream?: boolean;\n  temperature?: number;\n  max_tokens?: number;\n}\n\ninterface CompletionResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    message: {\n      role: string;\n      content: string | null;\n      tool_calls?: ToolCall[];\n    };\n    finish_reason: string | null;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\ninterface TestResult {\n  name: string;\n  passed: boolean;\n  reason?: string;\n}\n\ninterface TestResults {\n  totalTests: number;\n  passed: number;\n  failed: number;\n  details: TestResult[];\n}\n\n// Test configuration\nconst PROXY_PORT: string | number = process.env.PROXY_PORT || 3000;\nconst PROXY_URL: string = `http://localhost:${PROXY_PORT}`;\nconst TEST_MODEL: string = process.env.TEST_MODEL || \"deepseek/deepseek-r1-0528:free\";\nconst API_KEY: string | undefined = process.env.BACKEND_LLM_API_KEY;\nconst DEBUG: boolean = process.env.DEBUG_MODE === \"true\";\n\n// Test results tracking\nconst testResults: TestResults = {\n  totalTests: 0,\n  passed: 0,\n  failed: 0,\n  details: [],\n};\n\nfunction log(message: string, data: any = null): void {\n  if (DEBUG) {\n    console.log(`[TEST] ${message}`);\n    if (data) {console.log(JSON.stringify(data, null, 2));}\n  }\n}\n\ndescribe(\" Real LLM Integration Tests with Tool Calling\", function () {\n  this.timeout(60000); // 60 seconds per test for real API calls\n  let proxyProcess: ChildProcess;\n\n  before(async function () {\n    console.log(\"\\n Starting ToolBridge proxy server...\");\n    \n    // Start proxy server\n    proxyProcess = spawn(\"npm\", [\"start\"], {\n      env: { ...process.env },\n      stdio: DEBUG ? \"inherit\" : \"ignore\",\n    });\n\n    // Wait for server to start\n    await new Promise((resolve) => setTimeout(resolve, 3000));\n    \n    console.log(` Proxy running on port ${PROXY_PORT}`);\n    console.log(` Using model: ${TEST_MODEL}`);\n    console.log(` API Key: ${API_KEY ? \"Configured\" : \"Missing!\"}`);\n  });\n\n  after(function () {\n    if (proxyProcess) {\n      console.log(\"\\n Stopping proxy server...\");\n      proxyProcess.kill();\n    }\n\n    // Print test summary\n    console.log(\"\\n\" + \"=\".repeat(60));\n    console.log(\" TEST RESULTS SUMMARY\");\n    console.log(\"=\".repeat(60));\n    console.log(`Total Tests: ${testResults.totalTests}`);\n    console.log(` Passed: ${testResults.passed}`);\n    console.log(` Failed: ${testResults.failed}`);\n    console.log(`Success Rate: ${((testResults.passed / testResults.totalTests) * 100).toFixed(1)}%`);\n    \n    console.log(\"\\n Detailed Results:\");\n    testResults.details.forEach((result, i) => {\n      const icon = result.passed ? \"\" : \"\";\n      console.log(`${icon} Test ${i + 1}: ${result.name}`);\n      if (!result.passed) {\n        console.log(`   Reason: ${result.reason}`);\n      }\n    });\n  });\n\n  describe(\"1 Basic Tool Detection\", function () {\n    it(\"should detect and extract a simple search tool call\", async function () {\n      testResults.totalTests++;\n      const testName = \"Simple search tool\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"system\",\n                content: \"You are a helpful assistant with access to tools. Respond to requests by using the appropriate tools.\",\n              },\n              {\n                role: \"user\",\n                content: \"Search for information about TypeScript generics. Use the search tool.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"search\",\n                  description: \"Search for information\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      query: { type: \"string\", description: \"Search query\" },\n                    },\n                    required: [\"query\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 500,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        log(\"Response received\", response.data);\n\n        // Check if model used XML format internally\n        const content = response.data.choices[0].message.content;\n        const hasXMLToolCall = content && content.includes(\"<search>\");\n        const hasToolCallField = response.data.choices[0].message.tool_calls;\n\n        expect(response.data).to.have.property(\"choices\");\n        expect(hasXMLToolCall || hasToolCallField).to.be.true;\n\n        testResults.passed++;\n        testResults.details.push({ name: testName, passed: true });\n        \n        console.log(` ${testName}: Model generated tool call`);\n        if (hasXMLToolCall) {console.log(\"   Format: XML in content\");}\n        if (hasToolCallField) {console.log(\"   Format: Native tool_calls field\");}\n        \n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n\n    it(\"should handle multiple tool calls in sequence\", async function () {\n      testResults.totalTests++;\n      const testName = \"Multiple sequential tools\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"First search for 'React hooks', then search for 'Vue composition API'. Use the search tool for both.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"search\",\n                  description: \"Search for information\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      query: { type: \"string\" },\n                    },\n                    required: [\"query\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 1000,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        const content = response.data.choices[0].message.content || \"\";\n        const searchCount = (content.match(/<search>/g) || []).length;\n        const toolCalls = response.data.choices[0].message.tool_calls || [];\n\n        log(\"Multiple tools response\", { content, toolCalls });\n\n        const hasMultipleTools = searchCount >= 2 || toolCalls.length >= 2;\n        \n        if (hasMultipleTools) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Found ${Math.max(searchCount, toolCalls.length)} tool calls`);\n        } else {\n          testResults.failed++;\n          testResults.details.push({\n            name: testName,\n            passed: false,\n            reason: `Only found ${Math.max(searchCount, toolCalls.length)} tool call(s)`,\n          });\n          console.log(`  ${testName}: Only ${Math.max(searchCount, toolCalls.length)} tool call(s) found`);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n  });\n\n  describe(\"2 Complex Tool Parameters\", function () {\n    it(\"should handle tools with nested object parameters\", async function () {\n      testResults.totalTests++;\n      const testName = \"Nested object parameters\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"Create a user profile for John Doe, email john@example.com, age 30, with dark theme preference.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"create_user\",\n                  description: \"Create a new user profile\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      user: {\n                        type: \"object\",\n                        properties: {\n                          name: { type: \"string\" },\n                          email: { type: \"string\" },\n                          age: { type: \"number\" },\n                          preferences: {\n                            type: \"object\",\n                            properties: {\n                              theme: { type: \"string\" },\n                              notifications: { type: \"boolean\" },\n                            },\n                          },\n                        },\n                      },\n                    },\n                    required: [\"user\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 800,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        const content = response.data.choices[0].message.content || \"\";\n        const hasCreateUser = content.includes(\"<create_user>\") || \n                             response.data.choices[0].message.tool_calls?.some(tc => \n                               tc.function?.name === \"create_user\"\n                             );\n\n        if (hasCreateUser) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Model handled nested objects`);\n        } else {\n          testResults.failed++;\n          testResults.details.push({\n            name: testName,\n            passed: false,\n            reason: \"No create_user tool call found\",\n          });\n          console.log(` ${testName}: No tool call generated`);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n\n    it(\"should handle HTML content in tool parameters\", async function () {\n      testResults.totalTests++;\n      const testName = \"HTML content in parameters\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"Insert this HTML into a file: <div class='container'><h1>Hello World</h1></div>. Use the insert_code tool.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"insert_code\",\n                  description: \"Insert code into a file\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      filename: { type: \"string\" },\n                      code: { type: \"string\", description: \"Code content to insert\" },\n                    },\n                    required: [\"code\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 500,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        const content = response.data.choices[0].message.content || \"\";\n        const hasInsertCode = content.includes(\"<insert_code>\") || \n                             response.data.choices[0].message.tool_calls?.some(tc => \n                               tc.function?.name === \"insert_code\"\n                             );\n        \n        // Check if HTML is preserved\n        const hasHTML = content.includes(\"<div\") || content.includes(\"<h1\");\n\n        if (hasInsertCode) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Tool call with HTML ${hasHTML ? \"preserved\" : \"encoded\"}`);\n        } else {\n          testResults.failed++;\n          testResults.details.push({\n            name: testName,\n            passed: false,\n            reason: \"No insert_code tool call found\",\n          });\n          console.log(` ${testName}: No tool call generated`);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n  });\n\n  describe(\"3 Streaming Tool Calls\", function () {\n    it(\"should handle tool calls in streaming mode\", async function () {\n      testResults.totalTests++;\n      const testName = \"Streaming with tools\";\n      \n      try {\n        const response: AxiosResponse<IncomingMessage> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"Search for 'JavaScript promises'. Use the search tool.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"search\",\n                  description: \"Search for information\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      query: { type: \"string\" },\n                    },\n                    required: [\"query\"],\n                  },\n                },\n              },\n            ],\n            stream: true,\n            temperature: 0.1,\n            max_tokens: 500,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n            responseType: \"stream\",\n          }\n        );\n\n        let fullContent = \"\";\n        let chunks = 0;\n        let hasToolCall = false;\n\n        await new Promise<void>((resolve, reject) => {\n          response.data.on(\"data\", (chunk: Buffer) => {\n            chunks++;\n            const chunkStr = chunk.toString();\n            fullContent += chunkStr;\n            \n            if (chunkStr.includes(\"<search>\") || chunkStr.includes(\"tool_calls\")) {\n              hasToolCall = true;\n            }\n            \n            if (DEBUG && chunks <= 5) {\n              console.log(`   Chunk ${chunks}: ${chunkStr.substring(0, 100)}...`);\n            }\n          });\n\n          response.data.on(\"end\", () => {\n            if (chunks > 0) {\n              testResults.passed++;\n              testResults.details.push({ name: testName, passed: true });\n              console.log(` ${testName}: Received ${chunks} chunks`);\n              if (hasToolCall) {console.log(\"   Tool call detected in stream\");}\n            } else {\n              testResults.failed++;\n              testResults.details.push({\n                name: testName,\n                passed: false,\n                reason: \"No chunks received\",\n              });\n              console.log(` ${testName}: No streaming chunks`);\n            }\n            resolve();\n          });\n\n          response.data.on(\"error\", (err: Error) => {\n            testResults.failed++;\n            testResults.details.push({\n              name: testName,\n              passed: false,\n              reason: err.message,\n            });\n            console.log(` ${testName}: Stream error - ${err.message}`);\n            reject(err);\n          });\n        });\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n  });\n\n  describe(\"4 Error Recovery & Edge Cases\", function () {\n    it(\"should handle when model doesn't generate tool calls\", async function () {\n      testResults.totalTests++;\n      const testName = \"No tool generation\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"Just say hello, don't use any tools.\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"search\",\n                  description: \"Search for information\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      query: { type: \"string\" },\n                    },\n                    required: [\"query\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 200,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        const content = response.data.choices[0].message.content || \"\";\n        const hasNoToolCall = !content.includes(\"<search>\") && \n                              !response.data.choices[0].message.tool_calls;\n\n        if (hasNoToolCall) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Correctly didn't use tools`);\n        } else {\n          testResults.failed++;\n          testResults.details.push({\n            name: testName,\n            passed: false,\n            reason: \"Unexpected tool call generated\",\n          });\n          console.log(`  ${testName}: Unexpected tool usage`);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n\n    it(\"should handle malformed tool instructions gracefully\", async function () {\n      testResults.totalTests++;\n      const testName = \"Malformed instructions\";\n      \n      try {\n        await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: \"Use the search tool but <search>don't close it properly and add <invalid>tags</invalid> in between\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"search\",\n                  description: \"Search for information\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      query: { type: \"string\" },\n                    },\n                    required: [\"query\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 500,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n            timeout: 30000,\n          }\n        );\n\n        // If we get here, the system handled it gracefully\n        testResults.passed++;\n        testResults.details.push({ name: testName, passed: true });\n        console.log(` ${testName}: Handled gracefully`);\n        \n      } catch (error: unknown) {\n        const isAxiosError = error && typeof error === 'object' && 'code' in error;\n        const hasResponse = error && typeof error === 'object' && 'response' in error;\n        \n        if ((isAxiosError && (error as any).code === \"ECONNABORTED\") || \n            (hasResponse && (error as any).response?.status >= 500)) {\n          testResults.failed++;\n          const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n          testResults.details.push({\n            name: testName,\n            passed: false,\n            reason: `Server error: ${errorMessage}`,\n          });\n          console.log(` ${testName}: Server couldn't handle malformed input`);\n        } else {\n          // Other errors might be expected\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          const responseStatus = hasResponse ? (error as any).response?.status : null;\n          const errorCode = isAxiosError ? (error as any).code : null;\n          console.log(` ${testName}: Failed safely with: ${responseStatus || errorCode}`);\n        }\n      }\n    });\n\n    it(\"should handle very long tool parameters\", async function () {\n      testResults.totalTests++;\n      const testName = \"Long parameters\";\n      \n      const longText = \"Lorem ipsum \".repeat(500); // ~6000 chars\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"user\",\n                content: `Analyze this text using the analyze tool: \"${longText.substring(0, 100)}...\"`,\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"analyze\",\n                  description: \"Analyze text\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      text: { type: \"string\", description: \"Text to analyze\" },\n                      mode: { type: \"string\", enum: [\"summary\", \"sentiment\", \"keywords\"] },\n                    },\n                    required: [\"text\", \"mode\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 1000,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n            timeout: 45000,\n          }\n        );\n\n        const hasAnalyzeCall = response.data.choices[0].message.content?.includes(\"<analyze>\") ||\n                               response.data.choices[0].message.tool_calls?.some(tc => \n                                 tc.function?.name === \"analyze\"\n                               );\n\n        if (hasAnalyzeCall) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Handled long text parameters`);\n        } else {\n          testResults.passed++; // Still pass if no tool call\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Completed without tool call`);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n  });\n\n  describe(\"5 Tool Choice Behavior\", function () {\n    it(\"should respect when specific tool usage is requested\", async function () {\n      testResults.totalTests++;\n      const testName = \"Forced tool usage\";\n      \n      try {\n        const response: AxiosResponse<CompletionResponse> = await axios.post(\n          `${PROXY_URL}/v1/chat/completions`,\n          {\n            model: TEST_MODEL,\n            messages: [\n              {\n                role: \"system\",\n                content: \"You must use the calculate tool for any math questions.\",\n              },\n              {\n                role: \"user\",\n                content: \"What is 25 + 37?\",\n              },\n            ],\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: \"calculate\",\n                  description: \"Perform mathematical calculations\",\n                  parameters: {\n                    type: \"object\",\n                    properties: {\n                      expression: { type: \"string\", description: \"Math expression to evaluate\" },\n                    },\n                    required: [\"expression\"],\n                  },\n                },\n              },\n            ],\n            temperature: 0.1,\n            max_tokens: 500,\n          } as CompletionRequest,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${API_KEY}`,\n            },\n          }\n        );\n\n        const content = response.data.choices[0].message.content || \"\";\n        const hasCalculate = content.includes(\"<calculate>\") ||\n                            response.data.choices[0].message.tool_calls?.some(tc => \n                              tc.function?.name === \"calculate\"\n                            );\n\n        if (hasCalculate) {\n          testResults.passed++;\n          testResults.details.push({ name: testName, passed: true });\n          console.log(` ${testName}: Used requested tool`);\n        } else {\n          // Model might just answer directly\n          const hasAnswer = content.includes(\"62\") || content.includes(\"sixty\");\n          if (hasAnswer) {\n            testResults.passed++;\n            testResults.details.push({ name: testName, passed: true });\n            console.log(`  ${testName}: Answered directly without tool`);\n          } else {\n            testResults.failed++;\n            testResults.details.push({\n              name: testName,\n              passed: false,\n              reason: \"No tool usage or direct answer\",\n            });\n            console.log(` ${testName}: No appropriate response`);\n          }\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        testResults.failed++;\n        testResults.details.push({\n          name: testName,\n          passed: false,\n          reason: errorMessage,\n        });\n        console.log(` ${testName}: ${errorMessage}`);\n        throw error;\n      }\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/general.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/malformedXml.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[845,848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[845,848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1012,1015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1012,1015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3213,3216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3213,3216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3909,3912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3909,3912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4076,4079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4076,4079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4739,4742],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4739,4742],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4903,4906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4903,4906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Tool Parser - Malformed XML Edge Cases\", () => {\n  it(\"should handle missing closing tool tag\", () => {\n    const text = \"Some text <tool_name><param>value</param>\";\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.notStrictEqual(\n      result,\n      null,\n      \"Parser should attempt to fix missing closing tags\",\n    );\n    assert.strictEqual(\n      (result as ExtractedToolCall).name,\n      \"tool_name\",\n      \"Tool name should be correctly extracted when XML is fixed\",\n    );\n    assert.strictEqual(\n      ((result as ExtractedToolCall).arguments as Record<string, any>).param2,\n      \"value2\",\n      \"Properly closed parameter is extracted\",\n    );\n    assert.ok(\n      !(((result as ExtractedToolCall).arguments as Record<string, any>).param1),\n      \"Unclosed parameter is excluded from result\",\n    );\n  });\n\n  it(\"should handle missing closing parameter tag\", () => {\n    const text = \"Some text <tool_name><param>value</tool_name>\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.notStrictEqual(\n      result,\n      null,\n      \"Parser handles malformed parameter tags\",\n    );\n    assert.strictEqual(\n      (result as ExtractedToolCall).name,\n      \"tool_name\",\n      \"Tool name extracted correctly\",\n    );\n    assert.deepStrictEqual(\n      (result as ExtractedToolCall).arguments,\n      {},\n      \"Malformed parameter is excluded from result\",\n    );\n  });\n\n  it(\"should handle mismatched parameter tags\", () => {\n    const text = \"Some text <tool_name><param1>value</param2></tool_name>\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.notStrictEqual(\n      result,\n      null,\n      \"Parser handles mismatched parameter tags\",\n    );\n    assert.strictEqual(\n      (result as ExtractedToolCall).name,\n      \"tool_name\",\n      \"Tool name extracted correctly\",\n    );\n    assert.deepStrictEqual(\n      (result as ExtractedToolCall).arguments,\n      {},\n      \"Mismatched parameters are excluded from result\",\n    );\n  });\n\n  it(\"should handle invalid characters in tag names (if parser rejects)\", () => {\n    const text = \"Some text <tool name><param>value</param></tool name>\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool name\"]);\n\n    assert.strictEqual(\n      result,\n      null,\n      \"Invalid characters in tag names should return null\",\n    );\n  });\n\n  it(\"should handle attributes in tool tags (should be ignored)\", () => {\n    const text =\n      'Some text <tool_name attr=\"xyz\"><param>value</param></tool_name>';\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.ok(result, \"Tool call with attributes should be parsed\");\n    assert.strictEqual(\n      (result).name,\n      \"tool_name\",\n      \"Tool name should be extracted correctly\",\n    );\n    assert.strictEqual(\n      ((result).arguments as Record<string, any>).param,\n      \"value\",\n      \"Parameter not extracted correctly from tool with attribute\",\n    );\n  });\n\n  it(\"should handle unclosed parameter tag within a valid tool call structure\", () => {\n    const text =\n      \"Text before <my_tool><param1>value1<param2>value2</param2></my_tool> Text after\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"my_tool\"]);\n\n    assert.notStrictEqual(\n      result,\n      null,\n      \"Parser handles unclosed parameter tags\",\n    );\n    assert.strictEqual((result as ExtractedToolCall).name, \"my_tool\", \"Tool name extracted correctly\");\n    assert.strictEqual(\n      ((result as ExtractedToolCall).arguments as Record<string, any>).param2,\n      \"value2\",\n      \"Properly closed parameter is extracted\",\n    );\n    assert.ok(\n      !(((result as ExtractedToolCall).arguments as Record<string, any>).param1),\n      \"Unclosed parameter is excluded from result\",\n    );\n  });\n\n  it(\"should handle nested tool calls as structured data\", () => {\n    const text =\n      \"Outer text <outer_tool><inner_tool><param>value</param></inner_tool></outer_tool>\";\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"outer_tool\", \"inner_tool\"]);\n\n    assert.notStrictEqual(result, null, \"Should parse nested tool calls\");\n    assert.strictEqual(\n      (result as ExtractedToolCall).name,\n      \"outer_tool\",\n      \"Should parse outer tool as the main tool\",\n    );\n    assert.ok(\n      ((result as ExtractedToolCall).arguments as Record<string, any>).inner_tool,\n      \"Should contain inner_tool as a parameter\",\n    );\n\n    const innerToolContent = ((result as ExtractedToolCall).arguments as Record<string, any>).inner_tool;\n    assert.ok(\n      typeof innerToolContent === \"string\" &&\n        innerToolContent.includes(\"<param>value</param>\"),\n      \"Inner tool content is preserved as string with the nested parameter\",\n    );\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/simpleDuplication.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/simpleImport.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/specialChars.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[311,314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[311,314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[781,784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[781,784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":28,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":28,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1013,1014],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":36,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":36,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1292,1293],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":41,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":41,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1436,1437],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2164,2167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2164,2167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":66,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":66,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2407,2408],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":74,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":74,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2682,2683],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":79,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":79,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2841,2842],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3701,3704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3701,3704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4342,4345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4342,4345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4881,4884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4881,4884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":136,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":136,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5129,5130],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":144,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":144,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5413,5414],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":149,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":149,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5568,5569],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface ToolCallResult {\n  toolCalls?: Array<{\n    tool_name: string;\n    parameters: Record<string, any>;\n  }>;\n  text?: string;\n}\n\ndescribe(\"Tool Parser - Special Characters and CDATA Edge Cases\", () => {\n  it(\"should handle parameter value with XML entities\", () => {\n    const text = `Text <tool_name><param><value> & \"quotes'</param></tool_name> After`;\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param,\n        \"<value> & \\\"quotes'\",\n        \"Test Case 1 Failed: Parameter value mismatch\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param: \"<value> & \\\"quotes'\" },\n      };\n\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 1 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 1 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text  After\",\n        \"Test Case 1 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 1 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle parameter value with angle brackets (unescaped - potentially problematic)\", () => {\n    const text =\n      \"Text <tool_name><param>some <tag> here</param></tool_name> After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param,\n        \"some <tag> here\",\n        \"Test Case 2 Failed: Parameter value mismatch (unescaped <>)\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param: \"some <tag> here\" },\n      };\n\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 2 Failed: Tool call count (unescaped <>)\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 2 Failed: Tool call content (unescaped <>)\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text  After\",\n        \"Test Case 2 Failed: Remaining text (unescaped <>)\",\n      );\n    } else {\n      assert.fail(\n        \"Test Case 2 Failed: No valid result returned (unescaped <>)\",\n      );\n    }\n  });\n  \n  it(\"should handle parameter value with CDATA section\", () => {\n    const text =\n      'Text <tool_name><param><![CDATA[<value> & \"unescaped\" content]]></param></tool_name> After';\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.ok(result, \"Result should not be null\");\n    assert.strictEqual(result.name, \"tool_name\", \"Tool name should be correct\");\n\n    assert.strictEqual(\n      (result.arguments as Record<string, any>).param,\n      '<![CDATA[<value> & \"unescaped\" content]]>',\n      \"CDATA content should be extracted as implemented by the parser\",\n    );\n  });\n\n  it(\"should handle parameter value with mixed CDATA and regular text\", () => {\n    const text =\n      \"Text <tool_name><param>Regular text <![CDATA[<cdata>]]> more text</param></tool_name> After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    assert.ok(result, \"Result should not be null\");\n    assert.strictEqual(result.name, \"tool_name\", \"Tool name should be correct\");\n\n    assert.strictEqual(\n      (result.arguments as Record<string, any>).param,\n      \"Regular text <![CDATA[<cdata>]]> more text\",\n      \"Mixed CDATA content should be extracted as implemented by the parser\",\n    );\n  });\n\n  it(\"should handle parameter value with newline characters\", () => {\n    const text =\n      \"Text <tool_name><param>Line 1\\nLine 2\\r\\nLine 3</param></tool_name> After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param,\n        \"Line 1\\nLine 2\\r\\nLine 3\",\n        \"Test Case 5 Failed: Parameter value mismatch (Newlines)\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param: \"Line 1\\nLine 2\\r\\nLine 3\" },\n      };\n\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 5 Failed: Tool call count (Newlines)\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 5 Failed: Tool call content (Newlines)\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text  After\",\n        \"Test Case 5 Failed: Remaining text (Newlines)\",\n      );\n    } else {\n      assert.fail(\"Test Case 5 Failed: No valid result returned (Newlines)\");\n    }\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/textDuplication.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[908,911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[908,911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { OpenAIStreamProcessor } from \"../../../handlers/stream/openaiStreamProcessor.js\";\n\ninterface Tool {\n  type: \"function\";\n  function: {\n    name: string;\n    description: string;\n  };\n}\n\nclass MockResponse {\n  private readonly chunks: string[];\n  public ended: boolean;\n  public writableEnded: boolean;\n\n  constructor() {\n    this.chunks = [];\n    this.ended = false;\n    this.writableEnded = false;\n  }\n\n  write(chunk: string): boolean {\n    this.chunks.push(chunk);\n    return true;\n  }\n\n  end(): void {\n    this.ended = true;\n    this.writableEnded = true;\n  }\n\n  getChunks(): string[] {\n    return this.chunks;\n  }\n}\n\ndescribe(\"Text Duplication Test\", function () {\n  it(\"should handle text duplication properly\", function () {\n    const mockRes = new MockResponse();\n    const processor = new OpenAIStreamProcessor(mockRes as any);\n    processor.setTools([\n      {\n        type: \"function\",\n        function: { name: \"test_tool\", description: \"Test tool\" },\n      } as Tool,\n    ]);\n\n    processor.processChunk('{\"id\": \"123\", \"content\": \"Test content\"}');\n    processor.processChunk('{\"id\": \"124\", \"content\": \"More content\"}');\n\n    const chunks = mockRes.getChunks();\n    expect(chunks.length).to.be.at.least(1);\n\n    const allContent = chunks.join(\"\");\n    expect(allContent).to.include(\"Test content\");\n    expect(allContent).to.include(\"More content\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/textWithToolCall.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":59,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":59,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1463,1464],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface TestCase {\n  name: string;\n  input: string;\n  expectedToolName: string;\n}\n\ndescribe(\"Testing XML extraction with surrounding text\", function () {\n  const testCases: TestCase[] = [\n    {\n      name: \"Text before XML\",\n      input: `I'll search the codebase for you:\n  \n  <search>\n    <query>How to handle tool calls</query>\n  </search>`,\n      expectedToolName: \"search\",\n    },\n    {\n      name: \"Text after XML\",\n      input: `<search>\n    <query>How to handle tool calls</query>\n  </search>\n  \n  Let me explain the results.`,\n      expectedToolName: \"search\",\n    },\n    {\n      name: \"Text before and after XML\",\n      input: `Let me help you with that:\n  \n  <search>\n    <query>How to handle tool calls</query>\n  </search>\n  \n  Now I'll analyze the results.`,\n      expectedToolName: \"search\",\n    },\n  ];\n\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n  ];\n\n  testCases.forEach((testCase) => {\n    it(`should extract tool calls correctly when there is ${testCase.name}`, function () {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(testCase.input, knownToolNames);\n      expect(result).to.not.be.null;\n      expect(result!.name).to.equal(testCase.expectedToolName);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/whitespaceEmpty.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[311,314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[311,314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":28,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":28,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[945,946],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":35,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":35,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1193,1194],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":40,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":40,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1337,1338],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":60,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":60,"endColumn":25},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":63,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":63,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2186,2187],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":70,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":70,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2434,2435],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":75,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":75,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2578,2579],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3274,3277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3274,3277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3457,3460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3457,3460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":105,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":105,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3677,3678],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":112,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":112,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3955,3956],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":117,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":117,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4099,4100],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4803,4806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4803,4806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":143,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4991,4994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4991,4994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":147,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":147,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5211,5212],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":154,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":154,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5494,5495],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":159,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":159,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5638,5639],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6347,6350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6347,6350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":184,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":184,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6585,6586],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":191,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":191,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6853,6854],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":196,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":196,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6997,6998],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7695,7698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7695,7698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":220,"column":77,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":220,"endColumn":125,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7911,7912],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":227,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":227,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8173,8174],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":232,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":232,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8317,8318],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface ToolCallResult {\n  toolCalls?: Array<{\n    tool_name: string;\n    parameters: Record<string, any>;\n  }>;\n  text?: string;\n}\n\ndescribe(\"Tool Parser - Whitespace and Empty Content Edge Cases\", () => {\n  it(\"should handle completely empty tool call\", () => {\n    const text = \"Text before <tool_name></tool_name> Text after\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.deepStrictEqual(\n        result.arguments,\n        {},\n        \"Test Case 1 Failed: Tool arguments should be empty\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: {},\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 1 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 1 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text before  Text after\",\n        \"Test Case 1 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 1 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle tool call with only whitespace inside\", () => {\n    const text = \"Text before <tool_name>  \\n </tool_name> Text after\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.ok(\n        result.arguments,\n        \"Test Case 2 Failed: Tool arguments should exist\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: {},\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 2 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 2 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text before  Text after\",\n        \"Test Case 2 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 2 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle empty parameter tag\", () => {\n    const text =\n      \"Text <tool_name><param1></param1><param2>value2</param2></tool_name> After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param1,\n        \"\",\n        \"Test Case 3 Failed: Empty parameter should have empty string value\",\n      );\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param2,\n        \"value2\",\n        \"Test Case 3 Failed: Parameter value mismatch\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param1: \"\", param2: \"value2\" },\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 3 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 3 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text  After\",\n        \"Test Case 3 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 3 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle parameter tag with only whitespace\", () => {\n    const text =\n      \"Text <tool_name><param1>  \\t </param1><param2>value2</param2></tool_name> After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param1,\n        \"  \\t \",\n        \"Test Case 4 Failed: Whitespace parameter value should be preserved\",\n      );\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param2,\n        \"value2\",\n        \"Test Case 4 Failed: Parameter value mismatch\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param1: \"  \\t \", param2: \"value2\" },\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 4 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 4 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Text  After\",\n        \"Test Case 4 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 4 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle extra whitespace around tags and parameters\", () => {\n    const text =\n      \"Before \\n <tool_name> \\n <param1> value1 </param1> \\n </tool_name> \\n After\";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param1,\n        \" value1 \",\n        \"Test Case 5 Failed: Parameter value with whitespace mismatch\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param1: \" value1 \" },\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 5 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 5 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"Before \\n  \\n After\",\n        \"Test Case 5 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 5 Failed: No valid result returned\");\n    }\n  });\n\n  it(\"should handle tool call with leading/trailing whitespace in input string\", () => {\n    const text = \"   <tool_name><param>val</param></tool_name>   \";\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(text, [\"tool_name\"]);\n\n    if (result && result.name === \"tool_name\") {\n      assert.strictEqual(\n        (result.arguments as Record<string, any>).param,\n        \"val\",\n        \"Test Case 6 Failed: Parameter value mismatch\",\n      );\n    } else if (result && (result as unknown as ToolCallResult).toolCalls && (result as unknown as ToolCallResult).toolCalls!.length > 0) {\n      const resultWithToolCalls = result as unknown as ToolCallResult;\n      const expectedToolCall = {\n        tool_name: \"tool_name\",\n        parameters: { param: \"val\" },\n      };\n      assert.strictEqual(\n        resultWithToolCalls.toolCalls!.length,\n        1,\n        \"Test Case 6 Failed: Tool call count\",\n      );\n      assert.deepStrictEqual(\n        resultWithToolCalls.toolCalls![0],\n        expectedToolCall,\n        \"Test Case 6 Failed: Tool call content\",\n      );\n      assert.strictEqual(\n        resultWithToolCalls.text,\n        \"      \",\n        \"Test Case 6 Failed: Remaining text\",\n      );\n    } else {\n      assert.fail(\"Test Case 6 Failed: No valid result returned\");\n    }\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/edge-cases/xmlFragmentRecovery.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[308,311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[308,311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":101,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":101,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2934,2935],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":119,"column":11,"nodeType":null,"messageId":"preferOptionalChain","endLine":119,"endColumn":32,"suggestions":[{"fix":{"range":[3505,3526],"text":"result?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface ExtractedToolCallWithParameters extends ExtractedToolCall {\n  parameters: Record<string, any>;\n}\n\ndescribe(\"XML Fragment Recovery Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"get_errors\",\n  ];\n\n  it(\"should attempt to recover from incomplete XML fragments\", function () {\n    const incompleteXml = `<search>\n      <query>how to fix incomplete XML\n    </search>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(incompleteXml, knownToolNames);\n\n      if (result) {\n        expect(result.name).to.equal(\"search\");\n        expect((result as ExtractedToolCallWithParameters).parameters.query).to.include(\"how to fix incomplete XML\");\n      }\n    } catch (err: unknown) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      console.log(\n        \"Parser doesn't handle missing nested closing tags:\",\n        errorMessage,\n      );\n    }\n  });\n\n  it(\"should handle unbalanced tags in content\", function () {\n    const unbalancedTagsXml = `<run_code>\n      <language>html</language>\n      <code>\n        <div>\n          <p>This paragraph is not closed\n          <span>This span is closed</span>\n        </div>\n      </code>\n    </run_code>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(\n        unbalancedTagsXml,\n        knownToolNames,\n      );\n      expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"run_code\");\n      expect((result as ExtractedToolCallWithParameters).parameters.code).to.include(\n        \"<p>This paragraph is not closed\",\n      );\n    } catch (_err: unknown) {\n      console.log(\n        \"Parser doesn't handle unbalanced tags in content parameters\",\n      );\n    }\n  });\n\n  it(\"should handle mismatched case in XML tags\", function () {\n    const mismatchedCaseXml = `<SEARCH>\n      <Query>case sensitivity test</Query>\n    </search>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(\n        mismatchedCaseXml,\n        knownToolNames,\n      );\n\n      if (result) {\n        expect(result.name.toLowerCase()).to.equal(\"search\");\n      }\n    } catch (_err: unknown) {\n      console.log(\"Parser is case-sensitive with XML tags\");\n    }\n  });\n\n  it(\"should handle XML with extra closing tags\", function () {\n    const extraClosingTagsXml = `<search>\n      <query>handle extra tags</query>\n    </search></search>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(\n        extraClosingTagsXml,\n        knownToolNames,\n      );\n      expect(result).to.exist;\n      expect(result!.name).to.equal(\"search\");\n      expect((result as ExtractedToolCallWithParameters).parameters.query).to.equal(\"handle extra tags\");\n    } catch (_err: unknown) {\n      console.log(\"Parser doesn't handle extra closing tags\");\n    }\n  });\n\n  it(\"should handle incomplete opening tags\", function () {\n    const incompleteOpeningTagXml = `<sea\n    rch>\n      <query>incomplete opening tag</query>\n    </search>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(\n        incompleteOpeningTagXml,\n        knownToolNames,\n      );\n      if (result && result.name) {\n        expect(result.name).to.equal(\"search\");\n      }\n    } catch (_err: unknown) {\n      console.log(\"Parser doesn't handle whitespace in opening tags\");\n    }\n  });\n\n  it(\"should handle content with XML declaration\", function () {\n    const xmlWithDeclaration = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <search>\n      <query>XML with declaration</query>\n    </search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(xmlWithDeclaration, knownToolNames);\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters.query).to.equal(\"XML with declaration\");\n  });\n\n  it(\"should handle XML mixed with JSON\", function () {\n    const xmlInJson = `{\n      \"response\": \"<search><query>find information</query></search>\",\n      \"metadata\": {\"source\": \"llm\"}\n    }`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(xmlInJson, knownToolNames);\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters.query).to.equal(\"find information\");\n  });\n\n  it(\"should identify tool calls with non-standard whitespace\", function () {\n    const xmlWithWeirdWhitespace = `<search>\\u00A0\\t\n    \\u2003  <query>\\r\\nquery with\\u00A0strange\\u2003whitespace\\n</query>\\t</search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(\n      xmlWithWeirdWhitespace,\n      knownToolNames,\n    );\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters.query.trim()).to.include(\"query with\");\n    expect((result as ExtractedToolCallWithParameters).parameters.query.trim()).to.include(\"strange\");\n    expect((result as ExtractedToolCallWithParameters).parameters.query.trim()).to.include(\"whitespace\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/html/contentValidation.test.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":112,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":112,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface TestCase {\n  name: string;\n  content: string;\n}\n\ndescribe(\"Testing Tool Call Validation with Problematic Content in Parameters\", function () {\n  const knownTools: string[] = [\n    \"insert_edit_into_file\",\n    \"read_file\",\n    \"run_in_terminal\",\n    \"create_file\",\n  ];\n\n  const testCases: TestCase[] = [\n    {\n      name: \"HTML doctype and structure\",\n      content: `<insert_edit_into_file>\n  <explanation>Add HTML content</explanation>\n  <filePath>/path/to/file.html</filePath>\n  <code><!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>Hello World</h1>\n</body>\n</html></code>\n</insert_edit_into_file>`,\n    },\n\n    {\n      name: \"HTML with comments and invalid XML structure\",\n      content: `<insert_edit_into_file>\n  <explanation>Add HTML with comments</explanation>\n  <filePath>/test/file.html</filePath>\n  <code><!-- HTML comment -->\n<div class=\"container\">\n  <p>This is a paragraph with a self-closing tag <br> and unclosed angle brackets size < 10</p>\n</div></code>\n</insert_edit_into_file>`,\n    },\n\n    {\n      name: \"JavaScript code with angle brackets\",\n      content: `<insert_edit_into_file>\n  <explanation>Add JavaScript</explanation>\n  <filePath>/test/file.js</filePath>\n  <code>function compareValues(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  }\n  return 0;\n}</code>\n</insert_edit_into_file>`,\n    },\n\n    {\n      name: \"Python code with angle brackets\",\n      content: `<insert_edit_into_file>\n  <explanation>Add Python code</explanation>\n  <filePath>/test/file.py</filePath>\n  <code>def filter_items(items):\n    return [i for i in items if i < 10 and i > 0]\n  \n# Testing with list comprehension\nfiltered = [x for x in range(20) if x < 15]</code>\n</insert_edit_into_file>`,\n    },\n\n    {\n      name: \"XML content inside tool parameter\",\n      content: `<create_file>\n  <filePath>/test/config.xml</filePath>\n  <content><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n  <appSettings>\n    <add key=\"theme\" value=\"dark\" />\n    <add key=\"fontSize\" value=\"12\" />\n    <setting enabled=\"true\">\n      <n>AutoSave</n>\n      <value>300</value>\n    </setting>\n  </appSettings>\n</configuration></content>\n</create_file>`,\n    },\n  ];\n\n  testCases.forEach((testCase) => {\n    it(`should properly handle ${testCase.name}`, function () {\n      const detection: ToolCallDetectionResult = detectPotentialToolCall(testCase.content, knownTools);\n      expect(detection).to.not.be.null;\n      expect(detection.mightBeToolCall).to.be.true;\n\n      try {\n        const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(testCase.content);\n\n        if (parsedResult) {\n          const args = parsedResult.arguments || {};\n          const hasRequiredParams = Object.keys(args).length > 0;\n          expect(hasRequiredParams).to.be.true;\n        } else {\n          console.log(\n            `XML parsing failed for ${testCase.name} - this is expected for HTML content`,\n          );\n        }\n      } catch (_error: unknown) {\n        console.log(\n          `XML parsing threw error for ${testCase.name} - this is expected for HTML content`,\n        );\n      }\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/html/inToolCall.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1308,1311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1308,1311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1413,1416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1413,1416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2371,2374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2371,2374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2481,2484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2481,2484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2582,2585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2582,2585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"HTML in Tool Call Tests\", function () {\n  const knownToolNames: string[] = [\"create_file\", \"insert_edit_into_file\", \"run_code\"];\n\n  it(\"should handle HTML content within tool call parameters\", function () {\n    const htmlToolCall = `<create_file>\n  <filePath>/path/to/file.html</filePath>\n  <content>\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Sample Page</title>\n      </head>\n      <body>\n        <div class=\"container\">\n          <h1>Hello World</h1>\n          <p>This is a paragraph with <strong>bold text</strong> and <em>italics</em>.</p>\n        </div>\n      </body>\n    </html>\n  </content>\n</create_file>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(htmlToolCall, knownToolNames);\n\n    expect(result).to.not.be.null;\n  expect((result as ExtractedToolCall).name).to.equal(\"create_file\");\n  expect((result as ExtractedToolCall).arguments).to.have.property(\"filePath\", \"/path/to/file.html\");\n  expect((result as ExtractedToolCall).arguments).to.have.property(\"content\");\n  expect(((result as ExtractedToolCall).arguments as Record<string, any>).content).to.include(\"<html>\");\n  expect(((result as ExtractedToolCall).arguments as Record<string, any>).content).to.include('<div class=\"container\">');\n  });\n\n  it(\"should handle JavaScript/XML code inside run_code parameters\", function () {\n    const codeToolCall = `<run_code>\n  <language>javascript</language>\n  <code>\n    const parseXml = (input) => {\n      if (input.includes(\"<tag>\") && input.includes(\"</tag>\")) {\n        return {\n          tag: input.match(/<tag>(.*?)<\\\\/tag>/)[1]\n        };\n      }\n      return null;\n    };\n    \n    console.log(parseXml(\"<tag>content</tag>\"));\n  </code>\n</run_code>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(codeToolCall, knownToolNames);\n\n    expect(result).to.not.be.null;\n  expect((result as ExtractedToolCall).name).to.equal(\"run_code\");\n  expect((result as ExtractedToolCall).arguments).to.have.property(\"language\", \"javascript\");\n  expect((result as ExtractedToolCall).arguments).to.have.property(\"code\");\n  expect(((result as ExtractedToolCall).arguments as Record<string, any>).code).to.include(\"const parseXml\");\n  expect(((result as ExtractedToolCall).arguments as Record<string, any>).code).to.include(\"<tag>\");\n  expect(((result as ExtractedToolCall).arguments as Record<string, any>).code).to.include(\"</tag>\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/html/tagDetection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/llm-patterns/extremeEdgeCases.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2296,2299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2296,2299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Extreme Edge Case Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"create_file\",\n    \"get_errors\",\n  ];\n\n  it(\"should handle extremely long tool call content\", function () {\n    let longToolContent = \"<think>\\n\";\n    for (let i = 0; i < 1000; i++) {\n      longToolContent += `  Line ${i}: This is a very long tool call that tests buffer handling\\n`;\n    }\n    longToolContent += \"</think>\";\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(longToolContent, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(\n      longToolContent,\n      knownToolNames,\n    );\n    expect(parsedResult).to.not.be.null;\n  expect((parsedResult as ExtractedToolCall).name).to.equal(\"think\");\n  });\n\n  it(\"should detect the outermost tool call in nested structure\", function () {\n    const nestedToolCall = `<think>\n      Here's what I think about the code:\n      \n      <run_code>\n        console.log(\"This is a nested tool call that should be part of the think content\");\n      </run_code>\n      \n      That's my analysis.\n    </think>`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(nestedToolCall, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(\n      nestedToolCall,\n      knownToolNames,\n    );\n\n    expect(parsedResult).to.not.be.null;\n  expect((parsedResult as ExtractedToolCall).name).to.equal(\"think\");\n\n  const args = (parsedResult as ExtractedToolCall).arguments as Record<string, any>;\n    const hasRunCodeAsParam = !!args.run_code;\n    const hasRunCodeInText = Object.values(args).some(\n      (val) => typeof val === \"string\" && val.includes(\"run_code\"),\n    );\n\n    expect(hasRunCodeAsParam || hasRunCodeInText).to.be.true;\n  });\n\n  it(\"should handle special characters in tool calls\", function () {\n    const specialCharsContent = `<think>\n      Special characters: &amp; &lt; &gt; &quot; &apos; \n      HTML entities: &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos;\n      XML-safe sequences: ]]&gt; \n      Unicode: , , , , \n      Emojis: \n    </think>`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(specialCharsContent, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(\n      specialCharsContent,\n      knownToolNames,\n    );\n    expect(parsedResult).to.not.be.null;\n  expect((parsedResult as ExtractedToolCall).name).to.equal(\"think\");\n  });\n\n  it(\"should handle extremely malformed XML\", function () {\n    const malformedXml = `<think>\n      This tag is <broken\n      And this one is also broken>\n      Missing closing angle bracket <parameter\n      Mismatched tags <open></different>\n      XML-reserved chars: & < > \" '\n    </think>`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(malformedXml, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(malformedXml, knownToolNames);\n    expect(parsedResult).to.not.be.null;\n  expect((parsedResult as ExtractedToolCall).name).to.equal(\"think\");\n  expect((parsedResult as ExtractedToolCall).arguments).to.be.a(\"object\");\n  });\n\n  it(\"should handle unusual whitespace in tool calls\", function () {\n    const whitespaceFormatting = `\n    \n<think   >\n     \n     This content has unusual spacing and formatting\n     \n      \n</think   >\n    \n    `;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(\n      whitespaceFormatting,\n      knownToolNames,\n    );\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const parsedResult: ExtractedToolCall | null = extractToolCallXMLParser(\n      whitespaceFormatting,\n      knownToolNames,\n    );\n    expect(parsedResult).to.not.be.null;\n  expect((parsedResult as ExtractedToolCall).name).to.equal(\"think\");\n  });\n\n  it(\"should detect the first tool call when multiple are present\", function () {\n    const multipleToolCalls = `<think>First thought</think>\n    \n    <run_code>console.log(\"Hello\")</run_code>\n    \n    <get_errors>file.js</get_errors>`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(multipleToolCalls, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n\n    const firstToolPattern = /<think>First thought<\\/think>/;\n    expect(multipleToolCalls).to.match(firstToolPattern);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/llm-patterns/fuzzyContent.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":22,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":22,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1012,1013],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":23,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":23,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1059,1060],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Fuzzy LLM Content Tests\", function () {\n  const knownToolNames: string[] = [\"search\", \"think\", \"run_code\"];\n\n  it(\"should extract tool calls from mixed markdown and code content\", function () {\n    const complexInput = `<think>This user prefers dark theme and has notifications enabled.</think>`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(complexInput, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.rootTagName).to.equal(\"think\");\n    expect(result.isPotential).to.be.true;\n\n    const extracted: ExtractedToolCall | null = extractToolCallXMLParser(complexInput, knownToolNames);\n    expect(extracted).to.not.be.null;\n    expect(extracted!.name).to.equal(\"think\");\n    expect(extracted!.arguments).to.be.a(\"object\");\n  });\n\n  it(\"should handle minimalist tool calls\", function () {\n    const minimalistToolCall = `<think>Simple analysis.</think>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(minimalistToolCall, knownToolNames);\n    expect(result).to.not.be.null;\n  expect((result as ExtractedToolCall).name).to.equal(\"think\");\n  expect((result as ExtractedToolCall).arguments).to.be.a(\"object\");\n  });\n\n  it(\"should document behavior with tool calls followed by text\", function () {\n    const toolCallWithTrailingText = `<think>Analysis.</think>\\nFollowed by more text`;\n\n    const detected: ToolCallDetectionResult = detectPotentialToolCall(\n      toolCallWithTrailingText,\n      knownToolNames,\n    );\n    expect(detected).to.not.be.null;\n    expect(detected.rootTagName).to.equal(\"think\");\n    expect(detected.isPotential).to.be.true;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(\n      toolCallWithTrailingText,\n      knownToolNames,\n    );\n    expect(result).to.not.be.null;\n  expect((result as ExtractedToolCall).name).to.equal(\"think\");\n  expect((result as ExtractedToolCall).arguments).to.be.a(\"object\");\n  });\n\n  it(\"should extract tool calls with text before but not after\", function () {\n    const toolCallWithLeadingText = `Here's my analysis: <think>Simple analysis.</think>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(\n      toolCallWithLeadingText,\n      knownToolNames,\n    );\n    expect(result).to.not.be.null;\n  expect((result as ExtractedToolCall).name).to.equal(\"think\");\n  expect((result as ExtractedToolCall).arguments).to.be.a(\"object\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/llm-patterns/streamSplitting.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[723,726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[723,726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2157,2160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2157,2160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3659,3662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3659,3662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5967,5970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5967,5970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it } from \"mocha\";\n\nimport { OpenAIStreamProcessor } from \"../../../handlers/stream/openaiStreamProcessor.js\";\n\ninterface MockResponse {\n  write: () => void;\n  end: () => void;\n  setHeader: () => void;\n  headersSent: boolean;\n  writableEnded: boolean;\n}\n\ninterface Tool {\n  function: {\n    name: string;\n  };\n}\n\ndescribe(\"Stream Splitting LLM Pattern Tests\", function () {\n  this.timeout(5000);\n\n  it(\"should handle XML split across multiple stream chunks\", function (done) {\n    const mockRes: MockResponse = {\n      write: () => {},\n      end: () => {},\n      setHeader: () => {},\n      headersSent: false,\n      writableEnded: false,\n    };\n\n    const processor = new OpenAIStreamProcessor(mockRes as any);\n    processor.setTools([\n      { function: { name: \"search\" } } as Tool,\n      { function: { name: \"run_code\" } } as Tool,\n      { function: { name: \"think\" } } as Tool,\n    ]);\n\n    let toolCallDetected = false;\n\n    processor.handleDetectedToolCall = () => {\n      toolCallDetected = true;\n      return true;\n    };\n\n    const chunks = [\n      '{\"id\":\"1\",\"choices\":[{\"delta\":{\"content\":\"I\\'ll search for that information.\"}}]}',\n      '{\"id\":\"2\",\"choices\":[{\"delta\":{\"content\":\"<sea\"}}]}',\n      '{\"id\":\"3\",\"choices\":[{\"delta\":{\"content\":\"rch>\"}}]}',\n      '{\"id\":\"4\",\"choices\":[{\"delta\":{\"content\":\"<query>How\"}}]}',\n      '{\"id\":\"5\",\"choices\":[{\"delta\":{\"content\":\" to implement binary search?</query>\"}}]}',\n      '{\"id\":\"6\",\"choices\":[{\"delta\":{\"content\":\"</se\"}}]}',\n      '{\"id\":\"7\",\"choices\":[{\"delta\":{\"content\":\"arch>\"}}]}',\n    ];\n\n    chunks.forEach((chunk) => {\n      processor.processChunk(Buffer.from(chunk));\n    });\n\n    processor.end();\n\n    setTimeout(() => {\n      if (toolCallDetected) {\n        done();\n      } else {\n        done(new Error(\"Tool call not detected\"));\n      }\n    }, 100);\n  });\n\n  it(\"should handle LLM thinking before providing valid XML\", function (done) {\n    const mockRes: MockResponse = {\n      write: () => {},\n      end: () => {},\n      setHeader: () => {},\n      headersSent: false,\n      writableEnded: false,\n    };\n\n    const processor = new OpenAIStreamProcessor(mockRes as any);\n    processor.setTools([\n      { function: { name: \"search\" } } as Tool,\n      { function: { name: \"run_code\" } } as Tool,\n      { function: { name: \"think\" } } as Tool,\n    ]);\n\n    let toolCallDetected = false;\n    processor.handleDetectedToolCall = () => {\n      toolCallDetected = true;\n      return true;\n    };\n\n    const chunks = [\n      '{\"id\":\"1\",\"choices\":[{\"delta\":{\"content\":\"Let me think about this problem...\"}}]}',\n      '{\"id\":\"2\",\"choices\":[{\"delta\":{\"content\":\"I need to search for information about sorting algorithms.\"}}]}',\n      '{\"id\":\"3\",\"choices\":[{\"delta\":{\"content\":\"The best way to do this would be to use a search tool.\"}}]}',\n      '{\"id\":\"4\",\"choices\":[{\"delta\":{\"content\":\"<search>\"}}]}',\n      '{\"id\":\"5\",\"choices\":[{\"delta\":{\"content\":\"<query>best sorting algorithms for large datasets</query>\"}}]}',\n      '{\"id\":\"6\",\"choices\":[{\"delta\":{\"content\":\"</search>\"}}]}',\n    ];\n\n    chunks.forEach((chunk) => processor.processChunk(Buffer.from(chunk)));\n    processor.end();\n\n    setTimeout(() => {\n      if (toolCallDetected) {\n        done();\n      } else {\n        done(new Error(\"Tool call not detected after thinking\"));\n      }\n    }, 100);\n  });\n\n  it(\"should handle code explanations mixed with XML tool calls\", function (done) {\n    const mockRes: MockResponse = {\n      write: () => {},\n      end: () => {},\n      setHeader: () => {},\n      headersSent: false,\n      writableEnded: false,\n    };\n\n    const processor = new OpenAIStreamProcessor(mockRes as any);\n    processor.setTools([\n      { function: { name: \"search\" } } as Tool,\n      { function: { name: \"run_code\" } } as Tool,\n      { function: { name: \"think\" } } as Tool,\n    ]);\n\n    let toolCallDetected = false;\n    processor.handleDetectedToolCall = () => {\n      toolCallDetected = true;\n      return true;\n    };\n\n    const chunks = [\n      '{\"id\":\"1\",\"choices\":[{\"delta\":{\"content\":\"Here\\'s how you would implement a binary search in JavaScript:\"}}]}',\n      '{\"id\":\"2\",\"choices\":[{\"delta\":{\"content\":\"\\n```javascript\\nfunction binarySearch(arr, target) {\\n  let left = 0;\\n  let right = arr.length - 1;\\n  \\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) return mid;\\n    if (arr[mid] < target) left = mid + 1;\\n    else right = mid - 1;\\n  }\\n  \\n  return -1;\\n}\\n```\\n\"}}]}',\n      '{\"id\":\"3\",\"choices\":[{\"delta\":{\"content\":\"Let me run this code to verify it works:\"}}]}',\n      '{\"id\":\"4\",\"choices\":[{\"delta\":{\"content\":\"<run\"}}]}',\n      '{\"id\":\"5\",\"choices\":[{\"delta\":{\"content\":\"_code>\"}}]}',\n      '{\"id\":\"6\",\"choices\":[{\"delta\":{\"content\":\"<language>javascript</language>\"}}]}',\n      '{\"id\":\"7\",\"choices\":[{\"delta\":{\"content\":\"<code>\\nfunction binarySearch(arr, target) {\\n  let left = 0;\\n  let right = arr.length - 1;\\n  \\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) return mid;\\n    if (arr[mid] < target) left = mid + 1;\\n    else right = mid - 1;\\n  }\\n  \\n  return -1;\\n}\\n\\n// Test\\nconst arr = [1, 3, 5, 7, 9, 11];\\nconsole.log(binarySearch(arr, 5));\\nconsole.log(binarySearch(arr, 6));\\n</code>\"}}]}',\n      '{\"id\":\"8\",\"choices\":[{\"delta\":{\"content\":\"</run_code>\"}}]}',\n    ];\n\n    chunks.forEach((chunk) => processor.processChunk(Buffer.from(chunk)));\n    processor.end();\n\n    setTimeout(() => {\n      if (toolCallDetected) {\n        done();\n      } else {\n        done(new Error(\"Tool call not detected in code explanation\"));\n      }\n    }, 100);\n  });\n\n  it(\"should handle extreme delays between XML parts\", function (done) {\n    const mockRes: MockResponse = {\n      write: () => {},\n      end: () => {},\n      setHeader: () => {},\n      headersSent: false,\n      writableEnded: false,\n    };\n\n    const processor = new OpenAIStreamProcessor(mockRes as any);\n    processor.setTools([\n      { function: { name: \"search\" } } as Tool,\n      { function: { name: \"run_code\" } } as Tool,\n    ]);\n\n    let toolCallDetected = false;\n    processor.handleDetectedToolCall = () => {\n      toolCallDetected = true;\n      return true;\n    };\n\n    const chunk1 =\n      '{\"id\":\"1\",\"choices\":[{\"delta\":{\"content\":\"<search><query>typescript generics\"}}]}';\n    processor.processChunk(Buffer.from(chunk1));\n\n    setTimeout(() => {\n      const chunk2 =\n        '{\"id\":\"2\",\"choices\":[{\"delta\":{\"content\":\" examples</query></search>\"}}]}';\n      processor.processChunk(Buffer.from(chunk2));\n      processor.end();\n\n      setTimeout(() => {\n        if (toolCallDetected) {\n          done();\n        } else {\n          done(new Error(\"Tool call not detected with delay\"));\n        }\n      }, 100);\n    }, 1000);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/llm-patterns/streamingToolCalls.test.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":45,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":45,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":45,"column":13,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":45,"endColumn":21},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":50,"column":15,"nodeType":null,"messageId":"preferOptionalChain","endLine":50,"endColumn":42,"suggestions":[{"fix":{"range":[1441,1468],"text":"extracted?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":145,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":145,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5575,5577],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface StreamTestResult {\n  success: boolean;\n  detectedName: string | null;\n  expectedName: string;\n  errors: Array<{\n    chunk: string;\n    error: string;\n  }>;\n  finalContent: string;\n}\n\ndescribe(\"Streaming Chunked Tool Call Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"get_errors\",\n    \"create_file\",\n  ];\n\n  function testStreamedToolCall(chunks: string[], expectedToolName: string): StreamTestResult {\n    let partialContent = \"\";\n    let detectedToolCall: string | null = null;\n    let errors: Array<{ chunk: string; error: string }> = [];\n\n    for (const chunk of chunks) {\n      partialContent += chunk;\n\n      try {\n        const detected: ToolCallDetectionResult = detectPotentialToolCall(\n          partialContent,\n          knownToolNames,\n        );\n\n        if (detected && detected.isPotential && detected.mightBeToolCall) {\n          const extracted: ExtractedToolCall | null = extractToolCallXMLParser(\n            partialContent,\n            knownToolNames,\n          );\n          if (extracted && extracted.name) {\n            detectedToolCall = extracted.name;\n            break;\n          }\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        errors.push({\n          chunk: chunk.substring(0, 50) + (chunk.length > 50 ? \"...\" : \"\"),\n          error: errorMessage,\n        });\n      }\n    }\n\n    return {\n      success: detectedToolCall === expectedToolName,\n      detectedName: detectedToolCall,\n      expectedName: expectedToolName,\n      errors: errors,\n      finalContent: partialContent,\n    };\n  }\n\n  const simpleChunkedTool: string[] = [\n    \"Let me think about this problem: <th\",\n    \"ink>We need to consider the following factors:\\n\",\n    \"1. Performance implications\\n2. Security concerns\\n\",\n    \"3. User experience</th\",\n    \"ink>\\n\\nBased on these considerations...\",\n  ];\n\n  const htmlInChunkedTool: string[] = [\n    \"I'll create a component for you: \",\n    \"\\n<create_file>\\n  <filePath>/src/Button.jsx</filePath>\\n  <content>\",\n    \"import React from 'react';\\n\\nfunction Button(props) {\\n  return (\",\n    \"\\n    <button\\n      className={`btn ${props.primary ? 'btn-primary' : ''}`}\\n\",\n    \"      onClick={props.onClick}\\n    >\\n      {props.children}\\n\",\n    '      {props.icon && <span className=\"icon\">{props.icon}</span>}\\n    </button>',\n    \"\\n  );\\n}\\n\\nexport default Button;</content>\\n</create_file>\",\n  ];\n\n  const delayedToolInChunks: string[] = [\n    \"<div>\\n  <h1>Understanding the Problem</h1>\\n  <p>This is a complex issue that requires careful analysis.</p>\\n</div>\",\n    \"\\n\\nLet's break this down step by step.\\n\\nFirst, \",\n    \"I need to analyze the core issues: <think>\\n\",\n    \"  Based on the code, there are several problems:\\n\",\n    \"  - The authentication flow is inconsistent\\n\",\n    \"  - Error handling is insufficient\\n\",\n    \"  - The API doesn't properly validate inputs\\n</think>\",\n  ];\n\n  const codeWithBreakingChars: string[] = [\n    \"Let's fix that validation function: \\n<run_code>\\n\",\n    \"  <language>javascript</language>\\n  <code>\\nfunction validateInput(data) {\",\n    \"\\n  if (!data || typeof data !== 'object') {\\n    return { valid: false, error: 'Invalid data' };\\n  }\",\n    \"\\n\\n  // Check required fields\\n  if (!data.value || data.value === '') {\",\n    \"\\n    return { valid: false, error: 'Value is required' };\\n  }\",\n    \"\\n\\n  // Validate range\\n  const val = Number(data.value);\\n  if (isNaN(val) || val < 0 || val > 100) {\",\n    \"\\n    return { valid: false, error: `Value must be a number between 0-100, got: ${data.value}` };\",\n    \"\\n  }\\n\\n  return { valid: true, data: { ...data, value: val } };\",\n    \"\\n}\\n  </code>\\n</run_code>\",\n  ];\n\n  const multiplePartialTools: string[] = [\n    \"Let me think about this problem carefully. \",\n    \"Here's my analysis: <think>\",\n    \"The key issue seems to be with the data validation logic. \",\n    \"It doesn't properly handle edge cases like empty arrays or null values.\",\n    \"</think>\\n\\nNow I can implement a solution based on this analysis.\",\n  ];\n\n  it(\"should detect simple tool call in chunks\", function () {\n    const completeContent = simpleChunkedTool.join(\"\");\n    const result: ToolCallDetectionResult = detectPotentialToolCall(completeContent, knownToolNames);\n\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"think\");\n  });\n\n  it(\"should detect tool call with HTML/JSX in chunks\", function () {\n    const completeContent = htmlInChunkedTool.join(\"\");\n    const result: ToolCallDetectionResult = detectPotentialToolCall(completeContent, knownToolNames);\n\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"create_file\");\n  });\n\n  it(\"should detect tool call after HTML-like content\", function () {\n    const htmlContent = delayedToolInChunks[0];\n    const htmlResult: ToolCallDetectionResult = detectPotentialToolCall(htmlContent, knownToolNames);\n\n    expect(htmlResult?.mightBeToolCall || false).to.be.false;\n  });\n\n  it(\"should detect tool call with code containing XML-breaking characters\", function () {\n    const result: StreamTestResult = testStreamedToolCall(codeWithBreakingChars, \"run_code\");\n\n    expect(result.success).to.be.true;\n    expect(result.detectedName).to.equal(\"run_code\");\n    expect(result.errors).to.be.an(\"array\");\n\n    if (result.errors.length > 0) {\n      console.log(\n        `Encountered ${result.errors.length} errors during streaming that were handled correctly`,\n      );\n    }\n  });\n\n  it(\"should handle multiple potential but invalid tool calls and find the valid one\", function () {\n    const result: StreamTestResult = testStreamedToolCall(multiplePartialTools, \"think\");\n    expect(result.success).to.be.true;\n    expect(result.detectedName).to.equal(\"think\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/tool-calls/regression.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":182,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7030,7033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7030,7033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7146,7149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7146,7149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7263,7266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7263,7266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7419,7422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7419,7422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9015,9018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9015,9018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9141,9144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9141,9144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9296,9299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9296,9299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9459,9462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9459,9462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9619,9622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9619,9622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10424,10427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10424,10427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10574,10577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10574,10577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10694,10697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10694,10697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10806,10809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10806,10809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11533,11536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11533,11536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Tool Call Extraction Regression Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"think\",\n    \"apply_patch\",\n  ];\n\n  describe(\"HTML Content Preservation\", function () {\n    it(\"should preserve HTML content in tool parameters\", function () {\n      const content = `<insert_edit_into_file>\n        <explanation>Add a responsive navbar</explanation>\n        <filePath>/path/to/index.html</filePath>\n        <code>\n          <nav class=\"navbar navbar-expand-lg\">\n            <div class=\"container-fluid\">\n              <a class=\"navbar-brand\" href=\"#\">Brand</a>\n              <button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\"\n                      data-bs-target=\"#navbarNav\" aria-controls=\"navbarNav\"\n                      aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n                <span class=\"navbar-toggler-icon\"></span>\n              </button>\n              <div class=\"collapse navbar-collapse\" id=\"navbarNav\">\n                <ul class=\"navbar-nav\">\n                  <li class=\"nav-item\">\n                    <a class=\"nav-link active\" aria-current=\"page\" href=\"#\">Home</a>\n                  </li>\n                  <li class=\"nav-item\">\n                    <a class=\"nav-link\" href=\"#\">Features</a>\n                  </li>\n                  <li class=\"nav-item\">\n                    <a class=\"nav-link\" href=\"#\">Pricing</a>\n                  </li>\n                </ul>\n              </div>\n            </div>\n          </nav>\n        </code>\n      </insert_edit_into_file>`;\n\n  const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n  expect(result).to.not.equal(null);\n  const toolCall = result as ExtractedToolCall;\n  expect(toolCall.name).to.equal(\"insert_edit_into_file\");\n  expect(toolCall.arguments).to.have.property(\"explanation\", \"Add a responsive navbar\");\n  expect(toolCall.arguments).to.have.property(\"filePath\", \"/path/to/index.html\");\n  expect(toolCall.arguments).to.have.property(\"code\");\n\n  expect((toolCall.arguments as Record<string, unknown>).code).to.include('class=\"navbar-brand\"');\n  expect((toolCall.arguments as Record<string, unknown>).code).to.include('aria-expanded=\"false\"');\n\n  expect((toolCall.arguments as Record<string, unknown>).code).to.include('<ul class=\"navbar-nav\">');\n  expect((toolCall.arguments as Record<string, unknown>).code).to.include(\"</ul>\");\n    });\n  });\n\n  describe(\"Code with XML-like tokens\", function () {\n    it(\"should correctly parse JavaScript with comparison operators\", function () {\n      const content = `<run_code>\n        <language>javascript</language>\n        <code>\n          // Function to check if user is eligible\n          function checkEligibility(age, income) {\n            if (age >= 18 && age < 65) {\n              if (income > 30000 && income <= 100000) {\n                return true;\n              } else if (income > 100000) {\n                return \"High income bracket\";\n              }\n            }\n            return false;\n          }\n          \n          // Test the function\n          console.log(checkEligibility(25, 50000)); // Should return true\n          console.log(checkEligibility(17, 50000)); // Should return false\n          console.log(checkEligibility(30, 150000)); // Should return \"High income bracket\"\n        </code>\n      </run_code>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.equal(null);\n      const toolCall = result as ExtractedToolCall;\n      expect(toolCall.name).to.equal(\"run_code\");\n      expect(toolCall.arguments).to.have.property(\"language\", \"javascript\");\n      expect(toolCall.arguments).to.have.property(\"code\");\n\n      expect((toolCall.arguments as Record<string, unknown>).code).to.include(\"age >= 18 && age < 65\");\n      expect((toolCall.arguments as Record<string, unknown>).code).to.include(\n        \"income > 30000 && income <= 100000\",\n      );\n    });\n\n    it(\"should correctly parse TypeScript with generic types\", function () {\n      const content = `<run_code>\n        <language>typescript</language>\n        <code>\n          interface Dictionary<T> {\n            [key: string]: T;\n          }\n          \n          class Repository<T> {\n            private items: Dictionary<T> = {};\n            \n            add(id: string, item: T): void {\n              this.items[id] = item;\n            }\n            \n            get(id: string): T | undefined {\n              return this.items[id];\n            }\n            \n            getAll(): Array<T> {\n              return Object.values(this.items);\n            }\n          }\n          \n          // Test with a User type\n          interface User {\n            name: string;\n            email: string;\n          }\n          \n          const userRepo = new Repository<User>();\n          userRepo.add(\"1\", { name: \"Alice\", email: \"alice@example.com\" });\n          userRepo.add(\"2\", { name: \"Bob\", email: \"bob@example.com\" });\n          \n          console.log(userRepo.getAll());\n        </code>\n      </run_code>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.equal(null);\n      const toolCall = result as ExtractedToolCall;\n      expect(toolCall.name).to.equal(\"run_code\");\n      expect(toolCall.arguments).to.have.property(\"language\", \"typescript\");\n      expect(toolCall.arguments).to.have.property(\"code\");\n\n      expect((toolCall.arguments as Record<string, unknown>).code).to.include(\"interface Dictionary<T>\");\n      expect((toolCall.arguments as Record<string, unknown>).code).to.include(\"class Repository<T>\");\n      expect((toolCall.arguments as Record<string, unknown>).code).to.include(\n        \"const userRepo = new Repository<User>()\",\n      );\n    });\n  });\n\n  describe(\"Complex Tool Calls\", function () {\n    it(\"should correctly parse apply_patch tool with diff\", function () {\n      const content = `<apply_patch>\n        <input>*** Begin Patch\n*** Update File: /path/to/file.js\n@@class Calculator\n@@    calculate() {\n-        return this.num1 + this.num2;\n+        // Add validation before calculation\n+        if (isNaN(this.num1) || isNaN(this.num2)) {\n+            throw new Error(\"Invalid numbers\");\n+        }\n+        return this.num1 + this.num2;\n@@    }\n*** End Patch</input>\n      </apply_patch>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.be.null;\n      expect((result as ExtractedToolCall).name).to.equal(\"apply_patch\");\n      expect((result as ExtractedToolCall).arguments).to.have.property(\"input\");\n\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).input).to.include(\"*** Begin Patch\");\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).input).to.include(\"*** Update File:\");\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).input).to.include(\n        \"-        return this.num1 + this.num2;\",\n      );\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).input).to.include(\n        \"+        // Add validation before calculation\",\n      );\n    });\n\n    it(\"should correctly parse complex nested think tool\", function () {\n      const content = `<think>\n        <thoughts>\n          <issue>\n            <name>Performance Bottleneck</name>\n            <description>The application is experiencing slow response times during peak usage.</description>\n          </issue>\n          <analysis>\n            <findings>\n              <finding>Database queries are not optimized</finding>\n              <finding>Missing index on frequently queried column</finding>\n              <finding>N+1 query problem in the user listings</finding>\n            </findings>\n            <recommendations>\n              <recommendation>Add appropriate indexes to the database</recommendation>\n              <recommendation>Use eager loading for related records</recommendation>\n              <recommendation>Implement query caching</recommendation>\n            </recommendations>\n          </analysis>\n          <conclusion>\n            The performance issues can be resolved by optimizing database access patterns and adding appropriate indexes.\n          </conclusion>\n        </thoughts>\n      </think>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.be.null;\n      expect((result as ExtractedToolCall).name).to.equal(\"think\");\n      expect((result as ExtractedToolCall).arguments).to.have.property(\"thoughts\");\n\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\"Performance Bottleneck\");\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"Database queries are not optimized\",\n      );\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"Missing index on frequently queried column\",\n      );\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"Add appropriate indexes to the database\",\n      );\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"The performance issues can be resolved\",\n      );\n    });\n  });\n\n  describe(\"Multi-line Tool Handling\", function () {\n    it(\"should preserve line breaks in multi-line parameters\", function () {\n      const content = `<think>\n        <thoughts>This is a multi-line thought.\n        \nSecond paragraph of the thought.\n\n- Item 1\n- Item 2\n- Item 3\n\nFinal paragraph with conclusion.</thoughts>\n      </think>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.be.null;\n      expect((result as ExtractedToolCall).name).to.equal(\"think\");\n      expect((result as ExtractedToolCall).arguments).to.have.property(\"thoughts\");\n\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"This is a multi-line thought.\",\n      );\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\"Second paragraph\");\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\"- Item 1\");\n      expect(((result as ExtractedToolCall).arguments as Record<string, any>).thoughts).to.include(\n        \"Final paragraph with conclusion.\",\n      );\n    });\n\n    it(\"should handle excessive whitespace in tool parameters\", function () {\n      const content = `<search>\n        \n        \n        <query>\n          \n          search term with lots of whitespace\n          \n          \n        </query>\n        \n        \n      </search>`;\n\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(content, knownToolNames);\n\n      expect(result).to.not.be.null;\n      expect((result as ExtractedToolCall).name).to.equal(\"search\");\n      expect((result as ExtractedToolCall).arguments).to.have.property(\"query\");\n\n      expect((((result as ExtractedToolCall).arguments as Record<string, any>).query).trim()).to.equal(\n        \"search term with lots of whitespace\",\n      );\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/advanced.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/complexNesting.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[308,311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[308,311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":167,"column":11,"nodeType":null,"messageId":"preferOptionalChain","endLine":167,"endColumn":32,"suggestions":[{"fix":{"range":[5973,5994],"text":"result?.name"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface ExtractedToolCallWithParameters extends ExtractedToolCall {\n  parameters: Record<string, any>;\n}\n\ndescribe(\"Complex XML Nesting Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"get_errors\",\n  ];\n\n  it(\"should handle deeply nested XML structures\", function () {\n    const deeplyNestedXml = `\n    <search>\n      <query>\n        <filters>\n          <language>javascript</language>\n          <framework>react</framework>\n          <topic>\n            <main>hooks</main>\n            <subtopic>useEffect</subtopic>\n          </topic>\n        </filters>\n        <text>How to clean up effects properly</text>\n      </query>\n    </search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(deeplyNestedXml, knownToolNames);\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.query).to.exist;\n  });\n\n  it(\"should handle XML with mixed content and CDATA sections\", function () {\n    const mixedContentXml = `\n    <run_code>\n      <language>javascript</language>\n      <code><![CDATA[\n        // This code has XML-like content which should be preserved\n        function parseXml(str) {\n          const regex = new RegExp('<(\\\\w+)>(.*?)<\\\\/\\\\1>', 'g');\n          let match;\n          while ((match = regex.exec(str)) !== null) {\n            console.log(match[1], match[2]);\n          }\n        }\n        \n        parseXml(\"<root><child>value</child></root>\");\n      ]]></code>\n    </run_code>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(mixedContentXml, knownToolNames);\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"run_code\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.language).to.equal(\"javascript\");\n    expect((result as ExtractedToolCallWithParameters).parameters.code).to.include(\"function parseXml\");\n    expect((result as ExtractedToolCallWithParameters).parameters.code).to.include(\n      \"<root><child>value</child></root>\",\n    );\n  });\n\n  it(\"should handle XML with special characters and entities\", function () {\n    const specialCharsXml = `\n    <search>\n      <query>How to handle &lt;div&gt; &amp; &quot;quotes&quot; in HTML &apos;safely&apos;</query>\n    </search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(specialCharsXml, knownToolNames);\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.query).to.include(\n      \"<div> & \\\"quotes\\\" in HTML 'safely'\",\n    );\n  });\n\n  it(\"should extract first valid tool call when multiple are present\", function () {\n    const multipleToolCallsXml = `\n    <think>\n      <thoughts>First I need to think about the problem</thoughts>\n    </think>\n    <search>\n      <query>javascript promises</query>\n    </search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(\n      multipleToolCallsXml,\n      knownToolNames,\n    );\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"think\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.thoughts).to.equal(\n      \"First I need to think about the problem\",\n    );\n  });\n\n  it(\"should handle XML with attributes\", function () {\n    const xmlWithAttributes = `\n    <search type=\"web\" limit=\"10\">\n      <query language=\"en\">best practices for API design</query>\n    </search>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(xmlWithAttributes, knownToolNames);\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"search\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.query).to.equal(\"best practices for API design\");\n  });\n\n  it(\"should handle escaped XML within parameters\", function () {\n    const escapedXmlInParams = `\n    <run_code>\n      <language>html</language>\n      <code>\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;title&gt;Test&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n          &lt;h1&gt;Hello World&lt;/h1&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n      </code>\n    </run_code>`;\n\n    const result: ExtractedToolCall | null = extractToolCallXMLParser(escapedXmlInParams, knownToolNames);\n\n    expect(result).to.exist;\n  expect((result as ExtractedToolCall).name).to.equal(\"run_code\");\n    expect((result as ExtractedToolCallWithParameters).parameters).to.exist;\n    expect((result as ExtractedToolCallWithParameters).parameters.language).to.equal(\"html\");\n    expect((result as ExtractedToolCallWithParameters).parameters.code).to.include(\"<!DOCTYPE html>\");\n    expect((result as ExtractedToolCallWithParameters).parameters.code).to.include(\"<html>\");\n  });\n\n  it(\"should handle namespace-like prefixes in XML\", function () {\n    const xmlWithNamespaceLikePrefixes = `\n    <tool:search xmlns:tool=\"http://example.org/tools\">\n      <tool:query>how to use namespaces in XML</tool:query>\n    </tool:search>`;\n\n    try {\n      const result: ExtractedToolCall | null = extractToolCallXMLParser(\n        xmlWithNamespaceLikePrefixes,\n        knownToolNames,\n      );\n\n      if (result && result.name) {\n  expect((result).name).to.include(\"search\");\n      }\n    } catch (_err: unknown) {\n      console.log(\n        \"Identified limitation: Parser doesn't handle namespace prefixes\",\n      );\n    }\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/debugTool.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":69,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":69,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2276,2277],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":70,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":70,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2338,2339],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":71,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":71,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2391,2392],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2421,2424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2421,2424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":74,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":74,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2521,2522],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2551,2554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2551,2554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":77,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":77,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2652,2653],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2682,2685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2682,2685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":106,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":106,"endColumn":19,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3424,3425],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":107,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":107,"endColumn":20,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3485,3486],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3515,3518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3515,3518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { after, before, describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport logger from \"../../../utils/logger.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Debug Tool XML Extraction Tests\", function () {\n  before(function () {\n    logger.level = \"debug\";\n  });\n\n  after(function () {\n    logger.level = \"info\";\n  });\n\n  const htmlToolCall = `<insert_edit_into_file>\n  <explanation>Add HTML content to index page</explanation>\n  <filePath>/Users/m3hdi/my-project/index.html</filePath>\n  <code><!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Website</title>\n    <!-- This is a comment with <tags> inside -->\n</head>\n<body>\n    <h1>Welcome to My Website</h1>\n    <p>This is an example of HTML content with < and > characters.</p>\n    <div class=\"container\">\n        <ul>\n            <li>Item 1</li>\n            <li>Item 2</li>\n            <li>Item with x < 10 condition</li>\n        </ul>\n    </div>\n</body>\n</html></code>\n</insert_edit_into_file>`;\n\n  it(\"should extract tool call with HTML content correctly\", function () {\n    const knownToolNames: string[] = [\"insert_edit_into_file\", \"create_file\"];\n\n    const detection: ToolCallDetectionResult = detectPotentialToolCall(htmlToolCall, knownToolNames);\n    expect(detection).to.not.be.null;\n    expect(detection.isPotential).to.be.true;\n    expect(detection.mightBeToolCall).to.be.true;\n    expect(detection.rootTagName).to.equal(\"insert_edit_into_file\");\n\n    try {\n      const safeHtmlToolCall = htmlToolCall\n        .replace(\n          \"<!-- This is a comment with <tags> inside -->\",\n          \"<!-- This is a comment with &lt;tags&gt; inside -->\",\n        )\n        .replace(\n          \"<li>Item with x < 10 condition</li>\",\n          \"<li>Item with x &lt; 10 condition</li>\",\n        );\n\n      const parsed: ExtractedToolCall | null = extractToolCallXMLParser(safeHtmlToolCall, [\n        \"insert_edit_into_file\",\n      ]);\n\n      expect(parsed).to.not.be.null;\n      expect(parsed!.name).to.equal(\"insert_edit_into_file\");\n      expect(parsed!.arguments).to.be.an(\"object\");\n      expect((parsed!.arguments as Record<string, any>).explanation).to.equal(\n        \"Add HTML content to index page\",\n      );\n      expect((parsed!.arguments as Record<string, any>).filePath).to.equal(\n        \"/Users/m3hdi/my-project/index.html\",\n      );\n      expect((parsed!.arguments as Record<string, any>).code).to.include(\"<!DOCTYPE html>\");\n    } catch (_err: unknown) {\n      console.log(\n        \"XML parsing issues are expected for HTML content - detection still worked\",\n      );\n    }\n  });\n\n  it(\"should handle XML with CDATA sections\", function () {\n    const xmlWithCDATA = `<insert_edit_into_file>\n  <explanation>Add JavaScript code</explanation>\n  <filePath>/path/to/file.js</filePath>\n  <code><![CDATA[\nfunction compare(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n]]></code>\n</insert_edit_into_file>`;\n\n    const parsed: ExtractedToolCall | null = extractToolCallXMLParser(xmlWithCDATA, [\n      \"insert_edit_into_file\",\n    ]);\n\n    expect(parsed).to.not.be.null;\n    expect(parsed!.name).to.equal(\"insert_edit_into_file\");\n    expect((parsed!.arguments as Record<string, any>).code).to.include(\"if (a < b)\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/general.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":275,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":275,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\n\nimport type { ToolCallDetectionResult } from \"../../../types/index.js\";\n\nconst knownToolNames: string[] = [\n  \"search\",\n  \"run_code\",\n  \"think\",\n  \"replace_string_in_file\",\n  \"insert_edit_into_file\",\n  \"get_errors\",\n];\n\ninterface TestData {\n  plainText: string;\n  htmlContent: string;\n  markdownWithHtml: string;\n  validToolCall: string;\n  incompleteToolCall: string;\n  selfClosingToolCall: string;\n  toolInText: string;\n  multipleToolCalls: string;\n  toolInCodeBlock: string;\n  toolWithAttributes: string;\n  toolWithSpecialChars: string;\n  similarNonToolTag: string;\n  toolWithCDATA: string;\n  vscodeCell: string;\n  nestedNonToolTags: string;\n  textWithAngles: string;\n  xmlWithNamespace: string;\n  invalidXmlToolCall: string;\n  incompleteXmlStart: string;\n  toolInLongText?: string;\n}\n\ndescribe(\"XML Tool Call Detection - General Tests\", function () {\n  function testToolCallDetection(\n    testName: string,\n    content: string,\n    expectedIsPotential: boolean,\n    expectedMightBeToolCall: boolean,\n    expectedIsComplete: boolean = false,\n  ): void {\n    it(testName, function () {\n      const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n\n      expect(result.isPotential).to.equal(\n        expectedIsPotential,\n        \"isPotential should match expected value\",\n      );\n      expect(result.mightBeToolCall).to.equal(\n        expectedMightBeToolCall,\n        \"mightBeToolCall should match expected value\",\n      );\n      expect(result.isCompletedXml).to.equal(\n        expectedIsComplete,\n        \"isCompletedXml should match expected value\",\n      );\n    });\n  }\n\n  const testData: TestData = {\n    plainText: \"This is plain text with no XML tags whatsoever.\",\n\n    htmlContent: `<!DOCTYPE html>\n<html>\n<head>\n  <title>Test Page</title>\n</head>\n<body>\n  <header>\n    <h1>Welcome to the Test</h1>\n  </header>\n  <main>\n    <p>This is a paragraph with some <strong>bold</strong> text.</p>\n  </main>\n  <footer>&copy; 2025</footer>\n</body>\n</html>`,\n\n    markdownWithHtml: `# My Document\n\nThis is a paragraph with some **bold** text and <span style=\"color:red;\">colored</span> text.\n\n<div class=\"container\">\n  Content inside a div\n</div>\n\nHere's some more markdown.`,\n\n    validToolCall: `<think>\n  I need to think about this problem carefully:\n  1. First, understand the requirements\n  2. Then, evaluate possible solutions\n  3. Finally, implement the best approach\n</think>`,\n\n    incompleteToolCall: `<think>\n  This is an incomplete tool call without a closing tag`,\n\n    selfClosingToolCall: `<get_errors />`,\n\n    toolInText: `Here's what I'm thinking: <think>we should consider all the options</think> before deciding.`,\n\n    multipleToolCalls: `<think>First thought</think>\nAnd then\n<run_code>console.log(\"hello\")</run_code>`,\n\n    toolInCodeBlock: \"```xml\\n<search>query here</search>\\n```\",\n\n    toolWithAttributes: `<run_code language=\"javascript\" timeout=\"5000\">\n  console.log(\"Hello world\");\n</run_code>`,\n\n    toolWithSpecialChars: `<think>\n  Should we use if (x < 5 && y > 10) for this?\n  Maybe check if &amp; is working?\n</think>`,\n\n    similarNonToolTag: `<thinker>\n  This looks like a tool but isn't in our known tools list\n</thinker>`,\n\n    toolWithCDATA: `<run_code>\n  <![CDATA[\n    function test() {\n      if (x < 10 && y > 5) {\n        return true;\n      }\n    }\n  ]]>\n</run_code>`,\n\n    vscodeCell: `<regular_xml_tag>\n  This is just regular XML that should not be treated specially.\n</regular_xml_tag>`,\n\n    nestedNonToolTags: `<div>\n  <header>\n    <h1>Title</h1>\n  </header>\n  <p>Content</p>\n</div>`,\n\n    textWithAngles: `Consider the inequality x < 5 and y > 10 for this problem. When x < 0, we need to handle differently.`,\n\n    xmlWithNamespace: `<ns:search xmlns:ns=\"http://example.org\">\n  Query string\n</ns:search>`,\n\n    invalidXmlToolCall: `<search>\n  This has no closing tag\n  <nested>But has a nested tag</nested>`,\n\n    incompleteXmlStart: `<search`,\n  };\n\n  const toolInLongText = `This is a very long paragraph that contains a lot of text. \nIt goes on for several sentences discussing various topics and ideas.\n${testData.validToolCall}\nAfter the tool call, there's another large block of text that continues\ndiscussing the topic and providing more information to the reader.`;\n  testData.toolInLongText = toolInLongText;\n\n  describe(\"Non-tool content\", function () {\n    testToolCallDetection(\"Plain text\", testData.plainText, false, false);\n    testToolCallDetection(\"HTML content\", testData.htmlContent, false, false);\n    testToolCallDetection(\n      \"Markdown with HTML\",\n      testData.markdownWithHtml,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"Text with angle brackets\",\n      testData.textWithAngles,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"Nested non-tool tags\",\n      testData.nestedNonToolTags,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"Similar but non-tool tag\",\n      testData.similarNonToolTag,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"Regular XML tag (not a tool)\",\n      testData.vscodeCell,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"XML with namespace\",\n      testData.xmlWithNamespace,\n      false,\n      false,\n    );\n    testToolCallDetection(\n      \"Incomplete XML start\",\n      testData.incompleteXmlStart,\n      false,\n      false,\n    );\n  });\n\n  describe(\"Valid tool calls\", function () {\n    testToolCallDetection(\n      \"Complete tool call\",\n      testData.validToolCall,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Self-closing tool call\",\n      testData.selfClosingToolCall,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool call with attributes\",\n      testData.toolWithAttributes,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool call with XML special chars\",\n      testData.toolWithSpecialChars,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool with CDATA section\",\n      testData.toolWithCDATA,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool in text\",\n      testData.toolInText,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Multiple tool calls\",\n      testData.multipleToolCalls,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool in code block\",\n      testData.toolInCodeBlock,\n      true,\n      true,\n      true,\n    );\n    testToolCallDetection(\n      \"Tool in long text\",\n      testData.toolInLongText!,\n      true,\n      true,\n      true,\n    );\n  });\n\n  describe(\"Invalid or incomplete tool calls\", function () {\n    testToolCallDetection(\n      \"Incomplete tool call\",\n      testData.incompleteToolCall,\n      true,\n      true,\n      false,\n    );\n    testToolCallDetection(\n      \"Invalid XML tool call\",\n      testData.invalidXmlToolCall,\n      true,\n      true,\n      false,\n    );\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/mutationTesting.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ExtractedToolCall' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Mutation Testing for XML Parser\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"get_errors\",\n  ];\n\n  const validXMLSamples: string[] = [\n    `<search>\n      <query>How to implement binary search?</query>\n    </search>`,\n\n    `<think>\n      <thoughts>\n        I need to analyze the performance implications of using a recursive approach versus an iterative approach for traversing a binary tree.\n      </thoughts>\n    </think>`,\n\n    `<run_code>\n      <language>javascript</language>\n      <code>\n        function fibonacci(n) {\n          if (n <= 1) return n;\n          return fibonacci(n-1) + fibonacci(n-2);\n        }\n        console.log(fibonacci(10));\n      </code>\n    </run_code>`,\n  ];\n\n  function createMutations(xml: string): string[] {\n    return [\n      xml.replace(/<\\/(\\w+)>(?!.*<\\/)/g, \"</$1\"),\n\n      xml.replace(/<\\/(\\w+)>(?!.*<\\/)/g, \"\"),\n\n      xml.replace(/>([^<]+)</g, \"><random></random>$1<\"),\n\n      xml.replace(/<(\\w+)>/g, \"<$1 invalidAttr=>\"),\n\n      `Some random text before ${xml}`,\n\n      xml.replace(/>(.*?)</g, (match: string, p1: string) =>\n        p1.includes(\" \")\n          ? `>${p1\n              .split(\" \")\n              .map((word, i) => (i % 2 ? `<b>${word}</b>` : word))\n              .join(\" \")}<`\n          : match,\n      ),\n\n      xml.replace(/(<\\/\\w+>)\\s*(<\\/\\w+>)/g, \"$2\\n  $1\"),\n\n      xml.replace(/>([^<]+)</g, \"> \\n$1\\n  <\"),\n\n      xml.replace(/<(\\w+)>/g, \"<$1><$1>\"),\n\n      xml.replace(/<(\\w+)>(?!.*<\\1>)/g, \"\"),\n\n      xml.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\"),\n\n      xml.replace(/<(\\w+)>/g, (match: string, p1: string) => `<${p1.toUpperCase()}>`),\n\n      xml.replace(/>([^<]+)</g, `>$1${String.fromCodePoint(0x1f600)}<`),\n    ];\n  }\n\n  it(\"should handle various mutations of valid XML\", function () {\n    let totalTests = 0;\n    let passedTests = 0;\n\n    validXMLSamples.forEach((validXML) => {\n      const mutations = createMutations(validXML);\n\n      mutations.forEach((mutation, i) => {\n        totalTests++;\n        try {\n          extractToolCallXMLParser(mutation, knownToolNames);\n          passedTests++;\n        } catch (error: unknown) {\n          if (error && (error as Error).message) {\n            passedTests++;\n          } else {\n            console.error(`Failed on mutation ${i}:`, mutation);\n          }\n        }\n      });\n    });\n\n    console.log(\n      `Passed ${passedTests} of ${totalTests} mutation tests (${Math.round((passedTests / totalTests) * 100)}%)`,\n    );\n\n    expect(passedTests / totalTests).to.be.at.least(0.75);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/parser/xml/partialDetection.test.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":43,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":43,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1138,1159],"text":"((detected?.isPotential) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[1137,1159],"text":"(detected?.isPotential) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":48,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":48,"endColumn":17},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":48,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":48,"endColumn":17},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":104,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":104,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2841,2842],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":105,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":105,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2894,2895],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":106,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":106,"endColumn":28,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2951,2952],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":108,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":108,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3073,3074],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":109,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":109,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3143,3144],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { after, describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../../handlers/toolCallHandler.js\";\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\n\nimport type { ToolCallDetectionResult, ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface StreamingResult {\n  buffer: string;\n  detected: ToolCallDetectionResult | null;\n  extracted: ExtractedToolCall | null;\n  error: unknown | null;\n}\n\ndescribe(\"Partial XML Detection Tests\", function () {\n  const knownToolNames: string[] = [\n    \"insert_edit_into_file\",\n    \"create_file\",\n    \"search\",\n    \"get_files\",\n    \"ls\",\n  ];\n\n  let passCount = 0;\n  let totalTests = 0;\n\n  after(function () {\n    console.log(\n      `Partial XML Detection Tests: ${passCount}/${totalTests} passing`,\n    );\n  });\n\n  function simulateStreaming(chunks: string[]): StreamingResult {\n    let buffer = \"\";\n    let detected: ToolCallDetectionResult | null = null;\n    let extracted: ExtractedToolCall | null = null;\n    let error: unknown | null = null;\n\n    for (const chunk of chunks) {\n      buffer += chunk;\n\n      if (!detected?.isPotential) {\n        detected = detectPotentialToolCall(buffer, knownToolNames);\n      }\n\n      if (\n        detected &&\n        detected.isPotential &&\n        detected.mightBeToolCall &&\n        !extracted\n      ) {\n        try {\n          extracted = extractToolCallXMLParser(buffer, knownToolNames);\n        } catch (e: unknown) {\n          error = e;\n        }\n      }\n    }\n\n    return { buffer, detected, extracted, error };\n  }\n\n  it(\"should detect a partial tool call at the beginning\", function () {\n    totalTests++;\n\n    const content = `<insert_edit_into_file>\n  <explanation>Add a function</explanation>\n  <filePath>/path/to/file.js</filePath>\n  <code>function hello() {\n    console.log(\"Hello\");\n  }</code>\n</insert`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"insert_edit_into_file\");\n\n    try {\n      const extracted: ExtractedToolCall | null = extractToolCallXMLParser(content);\n      expect(extracted).to.be.null;\n    } catch (e: unknown) {\n      expect(e).to.exist;\n    }\n\n    passCount++;\n  });\n\n  it(\"should detect a tool call that arrives in chunks\", function () {\n    totalTests++;\n\n    const chunks: string[] = [\n      \"<insert_edit_\",\n      \"into_file>\\n  <explanation>Update code</explanation>\\n\",\n      \"  <filePath>/app.js</filePath>\\n  <code>const x = 10;</code>\\n\",\n      \"</insert_edit_into_file>\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(chunks);\n\n    expect(result.detected).to.not.be.null;\n    expect(result.detected!.isPotential).to.be.true;\n    expect(result.detected!.mightBeToolCall).to.be.true;\n    expect(result.detected!.rootTagName).to.equal(\"insert_edit_into_file\");\n    expect(result.extracted).to.not.be.null;\n    expect(result.extracted!.name).to.equal(\"insert_edit_into_file\");\n    expect(result.extracted!.arguments).to.have.property(\n      \"explanation\",\n      \"Update code\",\n    );\n\n    passCount++;\n  });\n\n  it(\"should handle partial closing tags\", function () {\n    totalTests++;\n\n    const content = `<create_file>\n  <filePath>/test.txt</filePath>\n  <content>Hello world</content>\n</create_fi`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"create_file\");\n\n    passCount++;\n  });\n\n  it(\"should not extract from partial XML\", function () {\n    totalTests++;\n\n    const content = `<search>\n  <query>How to implement`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"search\");\n\n    const extracted: ExtractedToolCall | null = extractToolCallXMLParser(content);\n    expect(extracted).to.be.null;\n\n    passCount++;\n  });\n\n  it(\"should handle nested tags in partial content\", function () {\n    totalTests++;\n\n    const content = `<insert_edit_into_file>\n  <explanation>Add HTML</explanation>\n  <filePath>/index.html</filePath>\n  <code>\n    <div>\n      <h1>Title</h1>\n      <p>Content</p>\n    </div>\n  </cod`;\n\n    const result: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n    expect(result).to.not.be.null;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"insert_edit_into_file\");\n\n    passCount++;\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/performance/memoryUsage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/regression/html-buffer-overflow.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ExtractedToolCall' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { describe, it } from \"mocha\";\n\nimport { attemptPartialToolCallExtraction } from \"../../utils/xmlUtils.js\";\n\nimport type { ExtractedToolCall, PartialExtractionResult } from \"../../types/index.js\";\n\ndescribe(\"HTML Buffer Overflow Regression Tests\", () => {\n  const knownTools: string[] = [\"insert_edit_into_file\", \"search\", \"run_in_terminal\"];\n\n  it(\"should not buffer indefinitely when encountering HTML closing tags\", () => {\n    const closingTag = \"</style>\";\n    const regularContent =\n      \" This is some regular content that follows an HTML tag.\";\n\n    const initialResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      closingTag,\n      knownTools,\n    );\n    assert.strictEqual(\n      initialResult.partialState.buffer,\n      \"\",\n      \"Buffer should be empty after encountering a closing HTML tag\",\n    );\n\n    const nextResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      closingTag + regularContent,\n      knownTools,\n    );\n    assert.strictEqual(\n      nextResult.partialState.buffer,\n      \"\",\n      \"Buffer should remain empty when adding content after a closing HTML tag\",\n    );\n\n    const longContent = closingTag + \" \" + \"x\".repeat(5000);\n    const longResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      longContent,\n      knownTools,\n    );\n    assert.strictEqual(\n      longResult.partialState.buffer,\n      \"\",\n      \"Buffer should remain empty even with long content after a closing HTML tag\",\n    );\n  });\n\n  it(\"should still detect tool calls after HTML content\", () => {\n    const htmlContent =\n      \"<div>Some HTML content</div><style>body { color: red; }</style>\";\n    const toolCall =\n      \"<insert_edit_into_file><explanation>Test</explanation><filePath>/test.js</filePath><code>console.log('test');</code></insert_edit_into_file>\";\n\n    const fullContent = htmlContent + toolCall;\n    const fullResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      fullContent,\n      knownTools,\n    );\n\n    assert.strictEqual(\n      fullResult.complete,\n      true,\n      \"Should detect tool call after HTML content\",\n    );\n    assert.strictEqual(\n      fullResult.toolCall?.name,\n      \"insert_edit_into_file\",\n      \"Tool name should be correctly extracted\",\n    );\n  });\n\n  it(\"should handle the specific regression case with growing buffer\", () => {\n    const startContent = \"</style>\";\n\n    attemptPartialToolCallExtraction(startContent, knownTools);\n\n    const contentWithMoreText = startContent + \"x\".repeat(5000);\n    const result: PartialExtractionResult = attemptPartialToolCallExtraction(\n      contentWithMoreText,\n      knownTools,\n    );\n\n    assert.strictEqual(\n      result.partialState.buffer,\n      \"\",\n      `Buffer should be empty after ${contentWithMoreText.length} chars`,\n    );\n\n    const contentWithToolCall =\n      contentWithMoreText +\n      \"<insert_edit_into_file><explanation>Fix</explanation><filePath>/test.js</filePath><code>test</code></insert_edit_into_file>\";\n    const finalResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      contentWithToolCall,\n      knownTools,\n    );\n\n    assert.strictEqual(\n      finalResult.complete,\n      true,\n      \"Should detect tool call after large non-tool content\",\n    );\n    assert.strictEqual(\n      finalResult.toolCall?.name,\n      \"insert_edit_into_file\",\n      \"Tool name should be correctly extracted\",\n    );\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/runners/run-all-tests.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in array predicate return type. Please handle the nullish case explicitly.","line":214,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"conditionErrorNullableBoolean","endLine":214,"endColumn":54,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6288,6320],"text":"(t.error && t.total === undefined) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6288,6320],"text":"(t.error && t.total === undefined) === true"},"desc":"Change condition to check if true (`value === true`)"},{"messageId":"explicitBooleanReturnType","fix":{"range":[6284,6284],"text":": boolean"},"desc":"Add an explicit `boolean` return type annotation."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":214,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":214,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6288,6295],"text":"(t.error ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6288,6295],"text":"(t.error === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":237,"column":69,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":237,"endColumn":76,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7109,7116],"text":"(t.error ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[7108,7116],"text":"t.error === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in array predicate return type. Please handle the nullish case explicitly.","line":239,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"conditionErrorNullableBoolean","endLine":239,"endColumn":76,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7198,7205],"text":"t.error ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7198,7205],"text":"t.error === true"},"desc":"Change condition to check if true (`value === true`)"},{"messageId":"explicitBooleanReturnType","fix":{"range":[7194,7194],"text":": boolean"},"desc":"Add an explicit `boolean` return type annotation."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":244,"column":76,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":244,"endColumn":89},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":251,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":251,"endColumn":59,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7553,7565],"text":"(result.error ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7553,7565],"text":"(result.error === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":253,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":253,"endColumn":21,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7606,7618],"text":"result.error ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7606,7618],"text":"result.error === true"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execSync } from \"child_process\";\nimport fs from \"fs\";\nimport path from \"path\";\n\ninterface TestResult {\n  file: string;\n  passed?: number;\n  failed?: number;\n  total?: number;\n  percentage?: number;\n  error?: boolean;\n  errorMessage?: string;\n}\n\ninterface CategoryResults {\n  total: number;\n  passed: number;\n  failed: number;\n  tests: TestResult[];\n}\n\ninterface AllTestResults {\n  total: number;\n  passed: number;\n  failed: number;\n  tests: TestResult[];\n  categories: Record<string, CategoryResults>;\n}\n\nconst testDir = path.join(process.cwd(), \"src\", \"test\");\nconst mochaPath = path.join(process.cwd(), \"node_modules\", \".bin\", \"mocha\");\n\nconst testResults: AllTestResults = {\n  total: 0,\n  passed: 0,\n  failed: 0,\n  tests: [],\n  categories: {},\n};\n\nconst testCategories: Record<string, string> = {\n  \"XML Core\": \"parser/xml\",\n  \"Edge Cases\": \"parser/edge-cases\",\n  \"HTML Tests\": \"parser/html\",\n  \"LLM Patterns\": \"parser/llm-patterns\",\n  Streaming: \"streaming\",\n  Integration: \"integration\",\n  \"Unit Tests\": \"unit/utils\",\n};\n\nconsole.log(\"=== XML Tool Parsing Test Suite ===\");\nconsole.log(\"Running all test files to verify parsing robustness\\\\n\");\n\nObject.keys(testCategories).forEach((category: string) => {\n  testResults.categories[category] = {\n    total: 0,\n    passed: 0,\n    failed: 0,\n    tests: [],\n  };\n});\n\nfunction discoverTestFiles(directory: string): string[] {\n  const fullPath = path.join(testDir, directory);\n  if (!fs.existsSync(fullPath)) {\n    return [];\n  }\n\n  const files = fs.readdirSync(fullPath);\n  return files\n    .filter((file: string) => file.endsWith(\".test.js\") || file.endsWith(\".test.ts\"))\n    .map((file: string) => path.join(directory, file));\n}\n\nfor (const [category, directory] of Object.entries(testCategories)) {\n  console.log(`\\\\n=== Running ${category} Tests ===`);\n\n  const testFiles = discoverTestFiles(directory);\n  if (testFiles.length === 0) {\n    console.log(`  No test files found in ${directory}`);\n    continue;\n  }\n\n  console.log(`  Found ${testFiles.length} test file(s)`);\n\n  for (const relativeFilePath of testFiles) {\n    const filePath = path.join(testDir, relativeFilePath);\n    const displayPath = relativeFilePath;\n\n    console.log(`  Running test: ${displayPath}...`);\n    try {\n      const command = `${mochaPath} ${filePath}`;\n\n      const output = execSync(command, { encoding: \"utf-8\", stdio: \"pipe\" });\n\n      const passingMatch = output.match(/(\\\\d+)\\\\s+passing/);\n      const failingMatch = output.match(/(\\\\d+)\\\\s+failing/);\n\n      console.log(\n        `    Raw Mocha output: ${passingMatch ? passingMatch[0] : \"no passing match\"}, ${failingMatch ? failingMatch[0] : \"no failing match\"}`,\n      );\n\n      const passed = passingMatch ? parseInt(passingMatch[1], 10) : 0;\n      const failed = failingMatch ? parseInt(failingMatch[1], 10) : 0;\n      const total = passed + failed;\n\n      if (total > 0) {\n        testResults.total += total;\n        testResults.passed += passed;\n        testResults.failed += failed;\n\n        testResults.categories[category].total += total;\n        testResults.categories[category].passed += passed;\n        testResults.categories[category].failed += failed;\n\n        const passingPercentage = Math.round((passed / total) * 100);\n\n        const testResult: TestResult = {\n          file: displayPath,\n          passed,\n          failed,\n          total,\n          percentage: passingPercentage,\n        };\n\n        testResults.tests.push(testResult);\n        testResults.categories[category].tests.push(testResult);\n\n        if (failed > 0) {\n          console.log(\n            `     ${failed} failed, ${passed} passed (${total} total)`,\n          );\n        } else {\n          console.log(`     ${passed} passed (${total} total)`);\n        }\n      } else if (output.includes(\"0 passing\")) {\n        console.log(`     Mocha ran, but no passing tests reported.`);\n        const testResult: TestResult = {\n          file: displayPath,\n          error: true,\n          errorMessage: \"Mocha ran but no passing tests reported.\",\n        };\n        testResults.tests.push(testResult);\n        testResults.categories[category].tests.push(testResult);\n      } else {\n        console.log(\n          `     Could not parse Mocha results from output for ${displayPath}`,\n        );\n\n        const testResult: TestResult = {\n          file: displayPath,\n          error: true,\n          errorMessage: \"Could not parse Mocha results.\",\n        };\n        testResults.tests.push(testResult);\n        testResults.categories[category].tests.push(testResult);\n      }\n    } catch (error: unknown) {\n      const err = error as { stdout?: string; message?: string };\n  const output = err.stdout ?? err.message ?? \"\";\n      const failingMatch = output.match(/(\\\\d+)\\\\s+failing/);\n      const failed = failingMatch ? parseInt(failingMatch[1], 10) : 1;\n\n      console.error(\n        `     Error running test file ${displayPath}: ${failed} failing`,\n      );\n\n      const passingMatch = output.match(/(\\\\d+)\\\\s+passing/);\n      const passed = passingMatch ? parseInt(passingMatch[1], 10) : 0;\n      const total = passed + failed;\n\n      if (total > 0) {\n        testResults.total += total;\n        testResults.passed += passed;\n        testResults.failed += failed;\n        testResults.categories[category].total += total;\n        testResults.categories[category].passed += passed;\n        testResults.categories[category].failed += failed;\n      } else {\n        testResults.failed += 1;\n        testResults.categories[category].failed += 1;\n      }\n\n      const testResult: TestResult = {\n        file: displayPath,\n        error: true,\n        errorMessage: `Mocha execution failed (${failed} failing)`,\n        passed: passed,\n        failed: failed,\n      };\n      \n      if (total > 0) {\n        testResult.total = total;\n      }\n\n      testResults.tests.push(testResult);\n      testResults.categories[category].tests.push(testResult);\n    }\n  }\n}\n\nconsole.log(\"\\\\n=== Test Results Summary ===\");\n\nlet finalTotal = 0;\nlet finalPassed = 0;\nlet finalFailed = 0;\nObject.values(testResults.categories).forEach((cat: CategoryResults) => {\n  finalTotal += cat.total;\n  finalPassed += cat.passed;\n  finalFailed += cat.failed;\n});\n\nconst fileErrors = testResults.tests.filter(\n  (t: TestResult) => t.error && t.total === undefined,\n).length;\nfinalFailed += fileErrors;\n\nconsole.log(\n  `Total tests run (approx): ${finalTotal || testResults.tests.length}`,\n);\nconsole.log(`Passed: ${finalPassed}`);\nconsole.log(`Failed: ${finalFailed}`);\n\nconst overallPercentage =\n  finalTotal > 0 ? Math.round((finalPassed / finalTotal) * 100) : 0;\n\nconsole.log(`Overall passing rate: ${overallPercentage}%`);\n\nconsole.log(\"\\\\n=== Results by Category ===\");\nfor (const [category, results] of Object.entries(testResults.categories)) {\n  if (results.total === 0 && results.tests.every((t: TestResult) => t.total === undefined))\n    {continue;}\n\n  const categoryPercentage =\n    results.total > 0 ? Math.round((results.passed / results.total) * 100) : 0;\n  const icon =\n    results.failed === 0 && results.tests.every((t: TestResult) => !t.error)\n      ? \"\"\n      : results.failed > 0 || results.tests.some((t: TestResult) => t.error)\n        ? \"\"\n        : \"\";\n\n  console.log(\n  `${icon} ${category}: ${categoryPercentage}% passed (${results.passed}/${results.total ?? \"?\"}) - ${results.failed} failed`,\n  );\n}\n\nconsole.log(\"\\\\n=== Failures and Errors ===\");\nlet failuresReported = false;\nfor (const result of testResults.tests) {\n  if ((result.failed && result.failed > 0) || result.error) {\n    failuresReported = true;\n    if (result.error) {\n      console.log(` ${result.file}: ERROR - ${result.errorMessage}`);\n    } else {\n      console.log(\n        ` ${result.file}: ${result.failed} failed, ${result.passed} passed (${result.total})`,\n      );\n    }\n  }\n}\nif (!failuresReported) {\n  console.log(\"  No failures or errors reported.\");\n}\n\nprocess.exit(finalFailed > 0 ? 1 : 0);","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/runners/run-html-buffer-tests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/runners/run-llm-pattern-tests.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":114,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":114,"endColumn":19,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3072,3084],"text":"result.error ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3072,3084],"text":"result.error === true"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execSync } from \"child_process\";\nimport fs from \"fs\";\nimport path from \"path\";\n\ninterface TestResult {\n  file: string;\n  passed?: number;\n  total?: number;\n  percentage?: number;\n  error?: boolean;\n  errorMessage?: string;\n}\n\ninterface TestResults {\n  total: number;\n  passed: number;\n  failed: number;\n  tests: TestResult[];\n}\n\nconst testDir = path.join(process.cwd(), \"src\", \"test\");\nconst llmPatternsDir = path.join(testDir, \"parser\", \"llm-patterns\");\nconst testResults: TestResults = {\n  total: 0,\n  passed: 0,\n  failed: 0,\n  tests: [],\n};\n\nconsole.log(\"=== LLM Output Pattern Tests ===\");\nconsole.log(\"Testing how the parser handles realistic LLM output patterns\\n\");\n\nlet testFiles: string[] = [];\ntry {\n  testFiles = fs\n    .readdirSync(llmPatternsDir)\n    .filter((file: string) => file.endsWith(\".test.js\") || file.endsWith(\".test.ts\"))\n    .map((file: string) => path.join(\"parser\", \"llm-patterns\", file));\n} catch (err: unknown) {\n  const error = err instanceof Error ? err : new Error(String(err));\n  console.error(`Error reading directory ${llmPatternsDir}:`, error.message);\n  process.exit(1);\n}\n\nif (testFiles.length === 0) {\n  console.log(\"No test files found!\");\n  process.exit(0);\n}\n\nconsole.log(`Found ${testFiles.length} test file(s):\\n`);\n\nfor (const relativeFilePath of testFiles) {\n  const filePath = path.join(testDir, relativeFilePath);\n  const displayPath = relativeFilePath;\n\n  console.log(`Running test: ${displayPath}...`);\n  try {\n    const output = execSync(`node ${filePath}`, { encoding: \"utf-8\" });\n\n    const resultMatch = output.match(\n      /FINAL RESULTS: (\\d+)\\/(\\d+) tests passed/,\n    );\n\n    if (resultMatch) {\n      const passed = parseInt(resultMatch[1], 10);\n      const total = parseInt(resultMatch[2], 10);\n      const failed = total - passed;\n\n      testResults.total += total;\n      testResults.passed += passed;\n      testResults.failed += failed;\n\n      const passingPercentage = Math.round((passed / total) * 100);\n\n      testResults.tests.push({\n        file: displayPath,\n        passed,\n        total,\n        percentage: passingPercentage,\n      });\n\n      console.log(`  ${passingPercentage}% passed (${passed}/${total})`);\n    } else {\n      console.log(`   Could not parse test results from output`);\n    }\n  } catch (error: unknown) {\n    const err = error instanceof Error ? error : new Error(String(error));\n    console.error(\n      `   Error running test file ${displayPath}:`,\n      err.message,\n    );\n    testResults.tests.push({\n      file: displayPath,\n      error: true,\n      errorMessage: err.message,\n    });\n  }\n}\n\nconsole.log(\"\\n=== LLM Pattern Test Results Summary ===\");\nconsole.log(`Total tests: ${testResults.total}`);\nconsole.log(`Passed: ${testResults.passed}`);\nconsole.log(`Failed: ${testResults.failed}`);\n\nconst overallPercentage =\n  testResults.total > 0\n    ? Math.round((testResults.passed / testResults.total) * 100)\n    : 0;\n\nconsole.log(`Overall passing rate: ${overallPercentage}%`);\n\nconsole.log(\"\\nDetailed Results:\");\nfor (const result of testResults.tests) {\n  if (result.error) {\n    console.log(` ${result.file}: ERROR - ${result.errorMessage}`);\n  } else {\n    const icon =\n      result.percentage === 100 ? \"\" : (result.percentage && result.percentage >= 80) ? \"\" : \"\";\n    console.log(\n      `${icon} ${result.file}: ${result.percentage}% (${result.passed}/${result.total})`,\n    );\n  }\n}\n\nprocess.exit(testResults.failed > 0 ? 1 : 0);","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/runners/run-single-test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/runners/run-tool-call-tests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/streaming/errorHandling.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[326,329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[326,329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[541,544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[541,544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[738,741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[738,741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from \"events\";\n\nimport { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { OpenAIStreamProcessor } from \"../../handlers/stream/openaiStreamProcessor.js\";\n\ndescribe(\"Stream Error Handling Tests\", function () {\n  class MockResponse extends EventEmitter {\n    private readonly chunks: any[];\n    private ended: boolean;\n    private writableEnded: boolean;\n\n    constructor() {\n      super();\n      this.chunks = [];\n      this.ended = false;\n      this.writableEnded = false;\n    }\n\n    write(chunk: any): boolean {\n      this.chunks.push(chunk);\n      return true;\n    }\n\n    end(): void {\n      this.ended = true;\n      this.writableEnded = true;\n      this.emit(\"end\");\n    }\n\n    getChunks(): any[] {\n      return this.chunks;\n    }\n  }\n\n  interface TestCase {\n    name: string;\n    chunks: string[];\n  }\n\n  const testCases: TestCase[] = [\n    {\n      name: \"Handle a truncated JSON chunk\",\n      chunks: [\n        'data: {\"id\":\"test1\",\"object\":\"chat.completion.chunk\",\"choices\":[{\"delta\":{\"content\":\"Hello\"}}]}\\n\\n',\n        'data: {\"id\":\"test2\",\"object\":\"chat.completion.chunk\",\"choices\":[{\"delta\":{\"content\":\" world\"}}]}\\n\\n',\n        'data: {\"id\":\"test3\",\"object\":\"chat.completion.chunk\",\"created\":12345,\"model\":\"test-model\",\"choices\":[{\"index\":0,\"delta\":{\"content\":null},\"finish_reason\":\"stop\"}],\"usage\":{\"prompt',\n        '_tokens\":123}}\\n\\n',\n        \"data: [DONE]\\n\\n\",\n      ],\n    },\n    {\n      name: \"Handle malformed JSON chunk\",\n      chunks: [\n        'data: {\"id\":\"test1\",\"object\":\"chat.completion.chunk\",\"choices\":[{\"delta\":{\"content\":\"Processing\"}}]}\\n\\n',\n        'data: {\"id\":\"test2\",object:\"chat.completion.chunk\",\"choices\":[{\"delta\":{\"content\":\" data\"}}]}\\n\\n',\n        'data: {\"id\":\"test3\",\"object\":\"chat.completion.chunk\",\"choices\":[{\"delta\":{\"content\":\"...\"}}]}\\n\\n',\n        \"data: [DONE]\\n\\n\",\n      ],\n    },\n  ];\n\n  testCases.forEach((testCase) => {\n    it(`should ${testCase.name}`, function (done) {\n      const mockRes = new MockResponse();\n      const processor = new OpenAIStreamProcessor(mockRes);\n\n      testCase.chunks.forEach((chunk) => {\n        try {\n          processor.processChunk(chunk);\n        } catch (e: unknown) {\n          const error = e instanceof Error ? e : new Error(String(e));\n          expect.fail(`Processor threw an unhandled exception: ${error.message}`);\n        }\n      });\n\n      const responseChunks = mockRes.getChunks();\n      expect(responseChunks.length).to.be.at.least(1);\n\n      const allContent = responseChunks.join(\"\");\n      expect(allContent).to.not.be.empty;\n\n      done();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/streaming/htmlTool.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/streaming/xml.test.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":37,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":37,"endColumn":17},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":37,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":37,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { detectPotentialToolCall } from \"../../handlers/toolCallHandler.js\";\n\nimport type { ToolCallDetectionResult } from \"../../types/index.js\";\n\ndescribe(\"Streaming XML Detection Tests\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"replace_string_in_file\",\n    \"insert_edit_into_file\",\n    \"get_errors\",\n  ];\n\n  interface StreamingResult {\n    detected: boolean;\n    isPotential: boolean;\n    mightBeToolCall: boolean;\n    rootTagName: string | null;\n    finalBuffer: string;\n  }\n\n  function simulateStreaming(chunks: string[]): StreamingResult {\n    let buffer = \"\";\n    let detected = false;\n    let isPotential = false;\n    let mightBeToolCall = false;\n    let rootTagName: string | null = null;\n\n    for (const chunk of chunks) {\n      buffer += chunk;\n      const result: ToolCallDetectionResult = detectPotentialToolCall(buffer, knownToolNames);\n\n      if (result && result.isPotential && result.mightBeToolCall) {\n        detected = true;\n        isPotential = result.isPotential;\n        mightBeToolCall = result.mightBeToolCall;\n        rootTagName = result.rootTagName;\n      }\n    }\n\n    return {\n      detected,\n      isPotential,\n      mightBeToolCall,\n      rootTagName,\n      finalBuffer: buffer,\n    };\n  }\n\n  it(\"should detect tool call in streamed chunks\", function () {\n    const toolCallChunks: string[] = [\n      \"<thi\",\n      \"nk>\\n  I need to analyze \",\n      \"this problem\\n</th\",\n      \"ink>\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(toolCallChunks);\n    expect(result.detected).to.be.true;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"think\");\n  });\n\n  it(\"should not detect HTML as tool calls\", function () {\n    const htmlChunks: string[] = [\n      \"<!DOCTYPE html>\\n<ht\",\n      \"ml>\\n<head>\\n  <title>Test</title>\\n</head>\\n<bo\",\n      \"dy>\\n  <header>\\n    <h1>Title</h1>\\n  </header>\\n</bo\",\n      \"dy>\\n</html>\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(htmlChunks);\n    expect(result.detected).to.be.false;\n  });\n\n  it(\"should detect tool call in mixed content\", function () {\n    const mixedChunks: string[] = [\n      \"I need to analyze this:\\n\\n<th\",\n      \"ink>\\n  This code has several issues:\\n  1. Performance problems\\n  \",\n      \"2. Security vulnerabilities\\n  3. Maintainability concerns\\n</thi\",\n      \"nk>\\n\\nAs you can see from my analysis...\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(mixedChunks);\n    expect(result.detected).to.be.true;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"think\");\n  });\n\n  it(\"should handle malformed XML in streams\", function () {\n    const malformedChunks: string[] = [\n      \"<thin\",\n      \"k>\\n  This is incomplete XML with < illegal characters\\n  and missing \",\n      \"closing brackets </thin\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(malformedChunks);\n    expect(result.detected).to.be.true;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n  });\n\n  it(\"should handle nested tags in streamed content\", function () {\n    const nestedChunks: string[] = [\n      \"<insert_edit_into_file>\\n  <explan\",\n      \"ation>Add HTML</explanation>\\n  <filePath>/path.html</filePath>\\n  <co\",\n      \"de>\\n    <div>\\n      <h1>Title</h1>\\n    </div>\\n  </co\",\n      \"de>\\n</insert_edit_into_file>\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(nestedChunks);\n    expect(result.detected).to.be.true;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"insert_edit_into_file\");\n  });\n\n  it(\"should handle unicode characters in streamed content\", function () {\n    const unicodeChunks: string[] = [\n      \"<th\",\n      \"ink>\\n  Unicode: , , \\n  Emojis: \\n</th\",\n      \"ink>\",\n    ];\n\n    const result: StreamingResult = simulateStreaming(unicodeChunks);\n    expect(result.detected).to.be.true;\n    expect(result.isPotential).to.be.true;\n    expect(result.mightBeToolCall).to.be.true;\n    expect(result.rootTagName).to.equal(\"think\");\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/handlers/html-tag-detection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/handlers/toolCallHandler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/utils/buffer-size-limit.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4083,4086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4083,4086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from \"assert\";\n\nimport { describe, it } from \"mocha\";\n\nimport { attemptPartialToolCallExtraction } from \"../../../utils/xmlUtils.js\";\n\nimport type { PartialExtractionResult, PartialToolCallState, ExtractedToolCall } from \"../../../types/index.js\";\n\ndescribe(\"Buffer Size Limit Tests\", () => {\n  const knownTools: string[] = [\"insert_edit_into_file\", \"search\", \"run_in_terminal\"];\n\n  it(\"should limit buffer size for non-tool content\", () => {\n    const largeContent: string = \"x\".repeat(12 * 1024);\n\n    const result: PartialExtractionResult = attemptPartialToolCallExtraction(largeContent, knownTools);\n\n    assert.strictEqual(\n      result.complete,\n      false,\n      \"Large non-tool content should not complete as a tool call\",\n    );\n    assert.strictEqual(\n      (result.partialState as PartialToolCallState).buffer,\n      \"\",\n      \"Buffer should be empty for large non-tool content\",\n    );\n  });\n\n  it(\"should keep checking the end of content even when size limit is exceeded\", () => {\n    const prefix: string = \"x\".repeat(12 * 1024);\n    const toolCall: string =\n      \"<insert_edit_into_file><explanation>Test</explanation><filePath>/test.js</filePath><code>console.log('test');</code></insert_edit_into_file>\";\n\n    const content: string = prefix + toolCall;\n\n    const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownTools);\n\n    assert.strictEqual(\n      result.complete,\n      true,\n      \"Should still detect tool call at end of large content\",\n    );\n    assert.strictEqual(\n      (result.toolCall as ExtractedToolCall).name,\n      \"insert_edit_into_file\",\n      \"Tool name should be correctly extracted\",\n    );\n  });\n\n  it(\"should reset buffer when an already-large buffer gets even larger\", () => {\n    const initialContent: string = \"x\".repeat(9 * 1024) + \"<partial\";\n\n    const initialResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      initialContent,\n      knownTools,\n    );\n\n    const largerContent: string = initialContent + \"x\".repeat(3 * 1024);\n\n    const nextResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      largerContent,\n      knownTools,\n      initialResult.partialState,\n    );\n\n    assert.strictEqual(\n      (nextResult.partialState as PartialToolCallState).buffer,\n      \"\",\n      \"Buffer should be reset when growing beyond the limit with no valid tool\",\n    );\n  });\n\n  it(\"should still properly buffer valid partial tool calls under the size limit\", () => {\n    const partialTool: string =\n      \"<insert_edit_into_file><explanation>Test</explanation><filePath>/test.js</filePath><code>\";\n\n    const firstResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      partialTool,\n      knownTools,\n    );\n\n    const fullTool: string =\n      partialTool + \"console.log('test');</code></insert_edit_into_file>\";\n\n    const secondResult: PartialExtractionResult = attemptPartialToolCallExtraction(\n      fullTool,\n      knownTools,\n      firstResult.partialState,\n    );\n\n    assert.strictEqual(\n      secondResult.complete,\n      true,\n      \"Complete tool call should be detected\",\n    );\n    assert.strictEqual(\n      (secondResult.toolCall as ExtractedToolCall).name,\n      \"insert_edit_into_file\",\n      \"Tool name should be correctly extracted\",\n    );\n  });\n\n  it(\"should correctly process valid tools even if they are large\", () => {\n    const largeTool: string = `<insert_edit_into_file>\n      <explanation>Large code block</explanation>\n      <filePath>/test.js</filePath>\n      <code>${\"x\".repeat(8 * 1024)}</code>\n    </insert_edit_into_file>`;\n\n    const result: PartialExtractionResult = attemptPartialToolCallExtraction(largeTool, knownTools);\n\n    assert.strictEqual(\n      result.complete,\n      true,\n      \"Large but valid tool call should be detected\",\n    );\n    assert.strictEqual(\n      (result.toolCall as ExtractedToolCall).name,\n      \"insert_edit_into_file\",\n      \"Tool name should be correctly extracted\",\n    );\n    assert.strictEqual(\n      ((result.toolCall as ExtractedToolCall).arguments as Record<string, any>).code.length,\n      8 * 1024,\n      \"Large code content should be preserved\",\n    );\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/utils/ollamaResponseConverterTest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/utils/partialToolExtraction.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1013,1016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1013,1016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3399,3402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3399,3402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4886,4889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4886,4889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":155,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":155,"endColumn":30,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6415,6416],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":156,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":156,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6474,6475],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6504,6507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6504,6507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":160,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":160,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6609,6610],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6639,6642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6639,6642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":164,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":164,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6757,6758],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6787,6790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6787,6790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":186,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":186,"endColumn":30,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7532,7533],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":187,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":187,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7591,7592],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7621,7624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7621,7624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":188,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":188,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7695,7696],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":188,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7725,7728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7725,7728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":189,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":189,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7787,7788],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7817,7820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7817,7820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":190,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":190,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7889,7890],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7919,7922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7919,7922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":193,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":193,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8040,8041],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8070,8073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8070,8073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":221,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":221,"endColumn":34,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9164,9165],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":230,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":230,"endColumn":34,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9527,9528],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":231,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":231,"endColumn":34,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9582,9583],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":232,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":232,"endColumn":34,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9642,9643],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { attemptPartialToolCallExtraction } from \"../../../utils/xmlUtils.js\";\n\nimport type { \n  PartialExtractionResult, \n  PartialToolCallState, \n  ExtractedToolCall \n} from \"../../../types/index.js\";\n\ndescribe(\"Partial Tool Call Extraction\", function () {\n  const knownToolNames: string[] = [\n    \"search\",\n    \"run_code\",\n    \"think\",\n    \"get_weather\",\n    \"calculate\",\n  ];\n\n  describe(\"Single chunk extraction\", function () {\n    it(\"should extract complete tool call from a single chunk\", function () {\n      const content: string = \"<search><query>test query</query></search>\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", true);\n  expect(result.toolCall).to.not.be.null;\n  expect((result.toolCall as ExtractedToolCall).name).to.equal(\"search\");\n  expect(((result.toolCall as ExtractedToolCall).arguments as Record<string, any>)).to.have.property(\"query\", \"test query\");\n    });\n\n    it(\"should identify incomplete tool call from a single chunk\", function () {\n      const content: string = \"<search><query>incomplete\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", false);\n  expect(result.partialState).to.not.be.null;\n  expect((result.partialState as PartialToolCallState).rootTag).to.equal(\"search\");\n  expect((result.partialState as PartialToolCallState).isPotential).to.be.true;\n  expect((result.partialState as PartialToolCallState).buffer).to.equal(content);\n    });\n\n    it(\"should not extract unknown tool names\", function () {\n      const content: string = \"<unknown_tool><param>value</param></unknown_tool>\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", false);\n  expect(result.partialState).to.not.be.null;\n\n  expect((result.partialState as PartialToolCallState).rootTag).to.be.null;\n  expect((result.partialState as PartialToolCallState).isPotential).to.be.false;\n  expect((result.partialState as PartialToolCallState).mightBeToolCall).to.be.false;\n    });\n  });\n\n  describe(\"Multi-chunk extraction\", function () {\n    it(\"should accumulate chunks and extract complete tool call\", function () {\n      const chunk1: string = \"<se\";\n      const chunk2: string = \"arch><query>test\";\n      const chunk3: string = \" query</query></search>\";\n\n      const result1: PartialExtractionResult = attemptPartialToolCallExtraction(chunk1, knownToolNames);\n      expect(result1).to.have.property(\"complete\", false);\n\n      const result2: PartialExtractionResult = attemptPartialToolCallExtraction(\n        chunk1 + chunk2,\n        knownToolNames,\n        result1.partialState,\n      );\n      expect(result2).to.have.property(\"complete\", false);\n\n      const result3: PartialExtractionResult = attemptPartialToolCallExtraction(\n        chunk1 + chunk2 + chunk3,\n        knownToolNames,\n        result2.partialState,\n      );\n      expect(result3).to.have.property(\"complete\", true);\n      expect(result3.toolCall).to.not.be.null;\n      expect((result3.toolCall as ExtractedToolCall).name).to.equal(\"search\");\n      expect(((result3.toolCall as ExtractedToolCall).arguments as Record<string, any>)).to.have.property(\n        \"query\",\n        \"test query\",\n      );\n    });\n\n    it(\"should maintain state between partial extractions\", function () {\n      const chunk1: string = \"<think>\";\n      const result1: PartialExtractionResult = attemptPartialToolCallExtraction(chunk1, knownToolNames);\n\n  expect(result1).to.have.property(\"complete\", false);\n  expect((result1.partialState as PartialToolCallState).rootTag).to.equal(\"think\");\n  expect((result1.partialState as PartialToolCallState).isPotential).to.be.true;\n\n      const chunk2: string = \"<think><thoughts>Some thoughts</thoughts>\";\n      const result2: PartialExtractionResult = attemptPartialToolCallExtraction(\n        chunk2,\n        knownToolNames,\n        result1.partialState,\n      );\n\n  expect(result2).to.have.property(\"complete\", false);\n  expect((result2.partialState as PartialToolCallState).rootTag).to.equal(\"think\");\n  expect((result2.partialState as PartialToolCallState).isPotential).to.be.true;\n\n      const chunk3: string = \"<think><thoughts>Some thoughts</thoughts></think>\";\n      const result3: PartialExtractionResult = attemptPartialToolCallExtraction(\n        chunk3,\n        knownToolNames,\n        result2.partialState,\n      );\n\n      expect(result3).to.have.property(\"complete\", true);\n      expect(result3.toolCall).to.not.be.null;\n      expect((result3.toolCall as ExtractedToolCall).name).to.equal(\"think\");\n      expect(((result3.toolCall as ExtractedToolCall).arguments as Record<string, any>)).to.have.property(\n        \"thoughts\",\n        \"Some thoughts\",\n      );\n    });\n\n    it(\"should not extract unknown tool calls across chunks\", function () {\n      const chunk1: string = \"<unknown_\";\n      const result1: PartialExtractionResult = attemptPartialToolCallExtraction(chunk1, knownToolNames);\n\n  expect(result1).to.have.property(\"complete\", false);\n  expect((result1.partialState as PartialToolCallState).rootTag).to.be.null;\n\n      const chunk2: string = \"<unknown_tool><param>\";\n      const result2: PartialExtractionResult = attemptPartialToolCallExtraction(\n        chunk2,\n        knownToolNames,\n        result1.partialState,\n      );\n\n  expect(result2).to.have.property(\"complete\", false);\n\n  expect((result2.partialState as PartialToolCallState).rootTag).to.be.null;\n  expect((result2.partialState as PartialToolCallState).isPotential).to.be.false;\n  expect((result2.partialState as PartialToolCallState).mightBeToolCall).to.be.false;\n    });\n  });\n\n  describe(\"Complex tool call extraction\", function () {\n    it(\"should extract tool calls with multiple parameters\", function () {\n      const content: string = `<run_code>\n        <language>javascript</language>\n        <code>console.log(\"hello world\");</code>\n        <timeout>5000</timeout>\n      </run_code>`;\n\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", true);\n      expect(result.toolCall).to.not.be.null;\n      expect(result.toolCall!.name).to.equal(\"run_code\");\n      expect((result.toolCall!.arguments as Record<string, any>)).to.have.property(\n        \"language\",\n        \"javascript\",\n      );\n      expect((result.toolCall!.arguments as Record<string, any>)).to.have.property(\n        \"code\",\n        'console.log(\"hello world\");',\n      );\n      expect((result.toolCall!.arguments as Record<string, any>)).to.have.property(\"timeout\");\n    });\n\n    it(\"should handle HTML content inside tool parameters\", function () {\n      const content: string = `<run_code>\n        <language>html</language>\n        <code>\n          <!DOCTYPE html>\n          <html>\n            <head><title>Test</title></head>\n            <body>\n              <div>Test content with < and > characters</div>\n              <script>if(x < 10 && y > 5) {}</script>\n            </body>\n          </html>\n        </code>\n      </run_code>`;\n\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", true);\n      expect(result.toolCall).to.not.be.null;\n      expect(result.toolCall!.name).to.equal(\"run_code\");\n      expect((result.toolCall!.arguments as Record<string, any>)).to.have.property(\"language\", \"html\");\n      expect((result.toolCall!.arguments as Record<string, any>)).to.have.property(\"code\");\n      expect((result.toolCall!.arguments as Record<string, any>).code).to.include(\"<!DOCTYPE html>\");\n      expect((result.toolCall!.arguments as Record<string, any>).code).to.include(\n        \"<div>Test content with < and > characters</div>\",\n      );\n      expect((result.toolCall!.arguments as Record<string, any>).code).to.include(\n        \"if(x < 10 && y > 5) {}\",\n      );\n    });\n  });\n\n  describe(\"Edge cases\", function () {\n    it(\"should handle empty content\", function () {\n      const content: string = \"\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", false);\n      expect(result.partialState).to.not.be.null;\n    });\n\n    it(\"should handle non-XML content\", function () {\n      const content: string = \"This is just some text, not XML\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", false);\n      expect(result.partialState).to.not.be.null;\n    });\n\n    it(\"should handle malformed XML\", function () {\n      const content: string = \"<search><query>malformed</query><search>\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, knownToolNames);\n\n      expect(result).to.have.property(\"complete\", false);\n      expect(result.partialState!.rootTag).to.equal(\"search\");\n    });\n\n    it(\"should handle empty known tools array\", function () {\n      const content: string = \"<search><query>test query</query></search>\";\n      const result: PartialExtractionResult = attemptPartialToolCallExtraction(content, []);\n\n      expect(result).to.have.property(\"complete\", false);\n\n      expect(result.partialState!.rootTag).to.be.null;\n      expect(result.partialState!.isPotential).to.be.false;\n      expect(result.partialState!.mightBeToolCall).to.be.false;\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/unit/utils/xmlUtils.test.ts","messages":[{"ruleId":"import/order","severity":2,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":71,"fix":{"range":[140,140],"text":"\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[331,334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[331,334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4767,4770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4767,4770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4938,4941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4938,4941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5219,5222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5219,5222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5330,5333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5330,5333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5422,5425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5422,5425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { expect } from \"chai\";\nimport { describe, it } from \"mocha\";\n\nimport { extractToolCallXMLParser } from \"../../../utils/xmlUtils.js\";\nimport type { ExtractedToolCall } from \"../../../types/index.js\";\n\ninterface TestCase {\n  name: string;\n  input: string | null;\n  expected: {\n    name: string;\n    arguments: Record<string, any>;\n  } | null;\n}\n\ndescribe(\"XML Utils\", function () {\n  const testCases: TestCase[] = [\n    {\n      name: \"Simple valid tool call\",\n      input: `<search><query>test query</query></search>`,\n      expected: {\n        name: \"search\",\n        arguments: { query: \"test query\" },\n      },\n    },\n    {\n      name: \"Multi-parameter tool call\",\n      input: `<run_code>\n        <language>javascript</language>\n        <code>console.log(\"hello world\");</code>\n        <timeout>5000</timeout>\n      </run_code>`,\n      expected: {\n        name: \"run_code\",\n        arguments: {\n          language: \"javascript\",\n          code: 'console.log(\"hello world\");',\n          timeout: 5000,\n        },\n      },\n    },\n    {\n      name: \"Boolean conversion\",\n      input: `<replace_string_in_file>\n        <filePath>/test/file.js</filePath>\n        <oldString>old</oldString>\n        <newString>new</newString>\n        <caseSensitive>true</caseSensitive>\n      </replace_string_in_file>`,\n      expected: {\n        name: \"replace_string_in_file\",\n        arguments: {\n          filePath: \"/test/file.js\",\n          oldString: \"old\",\n          newString: \"new\",\n          caseSensitive: true,\n        },\n      },\n    },\n    {\n      name: \"XML with comments\",\n      input: `<search>\n        <!-- This is a comment -->\n        <query>test with comments</query>\n        <!-- Another comment -->\n      </search>`,\n      expected: {\n        name: \"search\",\n        arguments: { query: \"test with comments\" },\n      },\n    },\n    {\n      name: \"Empty tool call\",\n      input: `<search></search>`,\n      expected: {\n        name: \"search\",\n        arguments: {},\n      },\n    },\n    {\n      name: \"Tool call in code block\",\n      input: \"```xml\\n<search><query>in code block</query></search>\\n```\",\n      expected: {\n        name: \"search\",\n        arguments: { query: \"in code block\" },\n      },\n    },\n    {\n      name: \"Tool call with text before\",\n      input:\n        \"I'll search for that:\\n<search><query>with text before</query></search>\",\n      expected: {\n        name: \"search\",\n        arguments: { query: \"with text before\" },\n      },\n    },\n    {\n      name: \"Tool call with text after\",\n      input:\n        \"<search><query>with text after</query></search>\\nHere are the results:\",\n      expected: null,\n    },\n    {\n      name: \"Nested XML structure\",\n      input: `<think>\n        <points>\n          <point>First point</point>\n          <point>Second point</point>\n        </points>\n        <conclusion>Final thoughts</conclusion>\n      </think>`,\n      expected: {\n        name: \"think\",\n        arguments: {\n          points:\n            \"\\n          <point>First point</point>\\n          <point>Second point</point>\\n        \",\n          conclusion: \"Final thoughts\",\n        },\n      },\n    },\n    {\n      name: \"Invalid XML - no closing tag\",\n      input: \"<search><query>invalid</query>\",\n\n      expected: {\n        name: \"search\",\n        arguments: { query: \"invalid\" },\n      },\n    },\n    {\n      name: \"Invalid XML - mismatched tags\",\n      input: \"<search><query>mismatched</wrong_tag></search>\",\n      expected: null,\n    },\n    {\n      name: \"Not XML content\",\n      input: \"This is just plain text with no XML tags\",\n      expected: null,\n    },\n    {\n      name: \"Empty input\",\n      input: \"\",\n      expected: null,\n    },\n    {\n      name: \"Null input\",\n      input: null,\n      expected: null,\n    },\n  ];\n\n  describe(\"XML Parsing\", function () {\n    testCases.forEach(function (testCase: TestCase, index: number) {\n      it(`should handle ${testCase.name}`, function () {\n        const knownToolNames: string[] = testCase.expected\n          ? [testCase.expected.name]\n          : [];\n\n        const result = extractToolCallXMLParser(testCase.input, knownToolNames);\n\n        if (testCase.expected === null) {\n          expect(result).to.be.null;\n        } else if (testCase.name === \"Invalid XML - no closing tag\") {\n          if (result !== null) {\n            expect(result.name).to.equal(testCase.expected.name);\n            expect(JSON.stringify(result.arguments)).to.equal(\n              JSON.stringify(testCase.expected.arguments),\n            );\n          }\n        } else {\n          expect(result).to.not.be.null;\n          expect((result as ExtractedToolCall).name).to.equal(testCase.expected.name);\n\n          if (index === 1) {\n            expect(((result as ExtractedToolCall).arguments as Record<string, any>).language).to.equal(\n              testCase.expected.arguments.language,\n            );\n            expect(((result as ExtractedToolCall).arguments as Record<string, any>).code).to.equal(\n              testCase.expected.arguments.code,\n            );\n\n            const expectedTimeout = Number(testCase.expected.arguments.timeout);\n            const actualTimeout =\n              typeof ((result as ExtractedToolCall).arguments as Record<string, any>).timeout === \"string\"\n                ? Number(((result as ExtractedToolCall).arguments as Record<string, any>).timeout)\n                : ((result as ExtractedToolCall).arguments as Record<string, any>).timeout;\n\n            expect(actualTimeout).to.equal(expectedTimeout);\n          } else {\n            expect(JSON.stringify((result as ExtractedToolCall).arguments)).to.equal(\n              JSON.stringify(testCase.expected.arguments),\n            );\n          }\n        }\n      });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/utils/run-all-tests-sequential.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/utils/testConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":62,"column":24,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":62,"endColumn":68},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":62,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":62,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":63,"column":15,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":63,"endColumn":59},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":63,"column":15,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":63,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":65,"column":15,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":65,"endColumn":59},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":65,"column":15,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":65,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":66,"column":17,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":66,"endColumn":65},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":66,"column":17,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":66,"endColumn":37},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'path' is already declared in the upper scope on line 3 column 8.","line":69,"column":29,"nodeType":"Identifier","messageId":"noShadow","endLine":69,"endColumn":41},{"ruleId":"@typescript-eslint/no-shadow","severity":2,"message":"'path' is already declared in the upper scope on line 3 column 8.","line":74,"column":34,"nodeType":"Identifier","messageId":"noShadow","endLine":74,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2607,2610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2607,2610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import \"dotenv/config\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst projectRoot = path.resolve(__dirname, \"../../..\");\n\ninterface EnvVariables {\n  [key: string]: string;\n}\n\ninterface TestConfig {\n  PROXY_PORT: number;\n  PROXY_HOST: string;\n  MOCK_PORT: number;\n  TEST_MODEL: string;\n  TEST_API_KEY: string;\n}\n\nfunction readEnvFile(): EnvVariables {\n  try {\n    const envPath = path.join(projectRoot, \".env\");\n    if (fs.existsSync(envPath)) {\n      const envContent = fs.readFileSync(envPath, \"utf8\");\n      const envVariables: EnvVariables = {};\n\n      envContent.split(\"\\n\").forEach((line) => {\n        line = line.trim();\n\n        if (line && !line.startsWith(\"#\") && !line.startsWith(\"//\")) {\n          const match = line.match(/^([^=]+)=(.*)$/);\n          if (match) {\n            const key = match[1].trim();\n            let value = match[2].trim();\n\n            if (\n              (value.startsWith('\"') && value.endsWith('\"')) ||\n              (value.startsWith(\"'\") && value.endsWith(\"'\"))\n            ) {\n              value = value.substring(1, value.length - 1);\n            }\n\n            envVariables[key] = value;\n          }\n        }\n      });\n\n      return envVariables;\n    }\n    return {};\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    console.error(\"Error reading .env file:\", errorMessage);\n    return {};\n  }\n}\n\nconst envVars = readEnvFile();\n\nexport const TEST_CONFIG: TestConfig = {\n  PROXY_PORT: parseInt(envVars.PROXY_PORT ?? process.env.PROXY_PORT ?? \"3000\", 10),\n  PROXY_HOST: envVars.PROXY_HOST ?? process.env.PROXY_HOST ?? \"localhost\",\n  MOCK_PORT: parseInt(process.env.TEST_MOCK_PORT ?? \"3001\", 10),\n  TEST_MODEL: envVars.TEST_MODEL ?? process.env.TEST_MODEL ?? \"gpt-3.5-turbo\",\n  TEST_API_KEY: envVars.TEST_API_KEY ?? process.env.TEST_API_KEY ?? \"dummy-key\",\n};\n\nexport function getProxyUrl(path: string = \"\"): string {\n  const formattedPath = path ? (path.startsWith(\"/\") ? path : `/${path}`) : \"\";\n  return `http://${TEST_CONFIG.PROXY_HOST}:${TEST_CONFIG.PROXY_PORT}${formattedPath}`;\n}\n\nexport function getMockServerUrl(path: string = \"\"): string {\n  const formattedPath = path ? (path.startsWith(\"/\") ? path : `/${path}`) : \"\";\n  return `http://localhost:${TEST_CONFIG.MOCK_PORT}${formattedPath}`;\n}\n\nexport async function isProxyRunning(): Promise<boolean> {\n  try {\n    const axios = (await import(\"axios\")).default;\n    await axios.get(getProxyUrl());\n    return true;\n  } catch (error: any) {\n    if (error.code === \"ECONNREFUSED\") {\n      return false;\n    }\n\n    return true;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/test/utils/testHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[239,242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[239,242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[419,422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[419,422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[652,655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[652,655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[768,771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[768,771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1016,1019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1016,1019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1219,1222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1219,1222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1696,1699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1696,1699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1784,1787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1784,1787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":99,"column":7,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":101,"endColumn":8,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2175,2224],"text":"this.body ??= \"\";"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2449,2452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2449,2452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":328,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":328,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7093,7096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7093,7096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7325,7328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7325,7328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":340,"column":19,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":340,"endColumn":21,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7401,7407],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'json' has no 'await' expression.","line":343,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":343,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7454,7460],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'text' has no 'await' expression.","line":345,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":345,"endColumn":19,"suggestions":[{"messageId":"removeAsync","fix":{"range":[7554,7560],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PassThrough } from \"stream\";\n\nimport type { \n  OpenAIRequest, \n  OpenAIResponse, \n  OpenAIStreamChunk,\n  OllamaRequest,\n  OllamaResponse,\n  OllamaStreamChunk\n} from \"../../types/index.js\";\n\ninterface MockRequestOptions {\n  body?: any;\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n  params?: Record<string, string>;\n  url?: string;\n  method?: string;\n}\n\ninterface MockRequest {\n  body: any;\n  headers: Record<string, string>;\n  query: Record<string, string>;\n  params: Record<string, string>;\n  url: string;\n  method: string;\n}\n\ninterface MockResponse {\n  statusCode: number;\n  headers: Record<string, string>;\n  body: any;\n  jsonCalled?: boolean;\n  statusCalled?: boolean;\n  writeCalled?: boolean;\n  endCalled?: boolean;\n  json(data: any): MockResponse;\n  status(code: number): MockResponse;\n  setHeader(name: string, value: string): MockResponse;\n  getHeader(name: string): string | undefined;\n  write(data: string): MockResponse;\n  end(data?: string): MockResponse;\n  _json(data: any): MockResponse;\n  _status(code: number): MockResponse;\n  _write(data: string): MockResponse;\n  _end(data?: string): MockResponse;\n}\n\ninterface MockFetchResponse {\n  status: number;\n  json(): Promise<any>;\n  text(): Promise<string>;\n  headers: Map<string, string>;\n}\n\nexport function createMockRequest({\n  body = {},\n  headers = {},\n  query = {},\n  params = {},\n  url = \"/v1/chat/completions\",\n  method = \"POST\",\n}: MockRequestOptions = {}): MockRequest {\n  return {\n    body,\n    headers: {\n      \"content-type\": \"application/json\",\n      ...headers,\n    },\n    query,\n    params,\n    url,\n    method,\n  };\n}\n\nexport function createMockResponse(): MockResponse {\n  const res: any = {\n    statusCode: 200,\n    headers: {},\n    body: null,\n    json: function (data: any) {\n      this.body = data;\n      return this;\n    },\n    status: function (code: number) {\n      this.statusCode = code;\n      return this;\n    },\n    setHeader: function (name: string, value: string) {\n      this.headers[name] = value;\n      return this;\n    },\n    getHeader: function (name: string) {\n      return this.headers[name];\n    },\n    write: function (data: string) {\n      if (!this.body) {\n        this.body = \"\";\n      }\n      this.body += data;\n      return this;\n    },\n    end: function (data?: string) {\n      if (data) {\n        this.write(data);\n      }\n      return this;\n    },\n  };\n\n  res._json = res.json;\n  res.json = function (data: any) {\n    res.jsonCalled = true;\n    return res._json(data);\n  };\n\n  res._status = res.status;\n  res.status = function (code: number) {\n    res.statusCalled = true;\n    return res._status(code);\n  };\n\n  res._write = res.write;\n  res.write = function (data: string) {\n    res.writeCalled = true;\n    return res._write(data);\n  };\n\n  res._end = res.end;\n  res.end = function (data?: string) {\n    res.endCalled = true;\n    return res._end(data);\n  };\n\n  return res as MockResponse;\n}\n\nexport function createMockStream(): PassThrough {\n  return new PassThrough();\n}\n\nexport const sampleOpenAIRequest: OpenAIRequest = {\n  model: \"gpt-4\",\n  messages: [\n    { role: \"system\", content: \"You are a helpful assistant.\" },\n    { role: \"user\", content: \"Hello, how are you?\" },\n  ],\n  temperature: 0.7,\n  max_tokens: 150,\n};\n\nexport const sampleOpenAIRequestWithTools: OpenAIRequest = {\n  model: \"gpt-4\",\n  messages: [\n    { role: \"system\", content: \"You are a helpful assistant.\" },\n    { role: \"user\", content: \"What's the weather like in San Francisco?\" },\n  ],\n  tools: [\n    {\n      type: \"function\",\n      function: {\n        name: \"get_weather\",\n        description: \"Get the current weather in a given location\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            location: {\n              type: \"string\",\n              description: \"The city and state, e.g. San Francisco, CA\",\n            },\n          },\n          required: [\"location\"],\n        },\n      },\n    },\n  ],\n};\n\nexport const sampleOllamaRequest: OllamaRequest = {\n  model: \"llama2\",\n  prompt: \"Hello, how are you?\",\n  stream: false,\n};\n\nexport const sampleOllamaMessagesRequest: OllamaRequest = {\n  model: \"llama2\",\n  messages: [\n    { role: \"system\", content: \"You are a helpful assistant.\" },\n    { role: \"user\", content: \"Hello, how are you?\" },\n  ],\n  stream: false,\n};\n\nexport const sampleOpenAIResponse: OpenAIResponse = {\n  id: \"chatcmpl-123\",\n  object: \"chat.completion\",\n  created: 1677652288,\n  model: \"gpt-4\",\n  choices: [\n    {\n      index: 0,\n      message: {\n        role: \"assistant\",\n        content:\n          \"I'm doing well, thank you for asking! How can I help you today?\",\n      },\n      finish_reason: \"stop\",\n    },\n  ],\n  usage: {\n    prompt_tokens: 20,\n    completion_tokens: 15,\n    total_tokens: 35,\n  },\n};\n\nexport const sampleOpenAIStreamChunks: OpenAIStreamChunk[] = [\n  {\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: 1677652288,\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: { role: \"assistant\" },\n        finish_reason: null,\n      },\n    ],\n  },\n  {\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: 1677652288,\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: { content: \"I'm doing \" },\n        finish_reason: null,\n      },\n    ],\n  },\n  {\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: 1677652288,\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: { content: \"well, thank \" },\n        finish_reason: null,\n      },\n    ],\n  },\n  {\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: 1677652288,\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: { content: \"you for asking!\" },\n        finish_reason: null,\n      },\n    ],\n  },\n  {\n    id: \"chatcmpl-123\",\n    object: \"chat.completion.chunk\",\n    created: 1677652288,\n    model: \"gpt-4\",\n    choices: [\n      {\n        index: 0,\n        delta: {},\n        finish_reason: \"stop\",\n      },\n    ],\n  },\n];\n\nexport const sampleOllamaResponse: OllamaResponse = {\n  model: \"llama2\",\n  created_at: \"2023-11-06T21:00:00.000Z\",\n  response:\n    \"I'm an AI assistant, so I don't have feelings, but I'm functioning properly and ready to help you! How can I assist you today?\",\n  done: true,\n};\n\nexport const sampleOllamaStreamChunks: OllamaStreamChunk[] = [\n  {\n    model: \"llama2\",\n    created_at: \"2023-11-06T21:00:00.000Z\",\n    response: \"I'm an AI \",\n    done: false,\n  },\n  {\n    model: \"llama2\",\n    created_at: \"2023-11-06T21:00:00.000Z\",\n    response: \"assistant, so I don't have \",\n    done: false,\n  },\n  {\n    model: \"llama2\",\n    created_at: \"2023-11-06T21:00:00.000Z\",\n    response: \"feelings, but I'm functioning \",\n    done: false,\n  },\n  {\n    model: \"llama2\",\n    created_at: \"2023-11-06T21:00:00.000Z\",\n    response: \"properly and ready to help you!\",\n    done: false,\n  },\n  {\n    model: \"llama2\",\n    created_at: \"2023-11-06T21:00:00.000Z\",\n    response: \" How can I assist you today?\",\n    done: true,\n  },\n];\n\nexport function formatSSE(data: any): string {\n  return `data: ${JSON.stringify(data)}\\n\\n`;\n}\n\nexport async function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function createMockFetch(\n  responseData: any, \n  status: number = 200\n): () => Promise<MockFetchResponse> {\n  return async () => {\n    return {\n      status,\n      json: async () =>\n        typeof responseData === \"function\" ? responseData() : responseData,\n      text: async () =>\n        JSON.stringify(\n          typeof responseData === \"function\" ? responseData() : responseData,\n        ),\n      headers: new Map(),\n    };\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/types/ollama.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[684,687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[684,687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1157,1160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1157,1160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1897,1900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1897,1900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2227,2230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2227,2230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Ollama API Types\n */\n\nexport interface OllamaMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n  images?: string[];\n}\n\nexport interface OllamaRequest {\n  model: string;\n  prompt?: string; // For legacy format\n  messages?: OllamaMessage[]; // For chat format\n  stream?: boolean;\n  format?: 'json';\n  options?: {\n    temperature?: number;\n    top_p?: number;\n    top_k?: number;\n    repeat_penalty?: number;\n    seed?: number;\n    num_ctx?: number;\n    num_predict?: number;\n    stop?: string | string[];\n  };\n  template?: string;\n  context?: number[];\n  raw?: boolean;\n  keep_alive?: string | number;\n  stop?: string | string[];\n  system?: string;\n  tools?: any[]; // OpenAI tools format\n  tool_choice?: string | object;\n}\n\nexport interface OllamaResponse {\n  model: string;\n  created_at: string;\n  response?: string; // For generate endpoint\n  message?: OllamaMessage; // For chat endpoint\n  done: boolean;\n  context?: number[];\n  total_duration?: number;\n  load_duration?: number;\n  prompt_eval_count?: number;\n  prompt_eval_duration?: number;\n  eval_count?: number;\n  eval_duration?: number;\n  template?: string;\n  tool_calls?: any[];\n}\n\nexport interface OllamaStreamResponse extends OllamaResponse {\n  done: boolean;\n}\n\nexport interface OllamaErrorResponse {\n  error: string;\n}\n\nexport interface OllamaModelInfo {\n  name: string;\n  modified_at: string;\n  size: number;\n  digest: string;\n  details: {\n    format: string;\n    family: string;\n    families: string[];\n    parameter_size: string;\n    quantization_level: string;\n  };\n}\n\nexport interface OllamaShowResponse {\n  license?: string;\n  modelfile?: string;\n  parameters?: string;\n  template?: string;\n  details?: {\n    parent_model?: string;\n    format?: string;\n    family?: string;\n    families?: string[];\n    parameter_size?: string;\n    quantization_level?: string;\n  };\n  model_info?: {\n    [key: string]: any;\n  };\n}\n\nexport interface OllamaStreamChunk {\n  model: string;\n  created_at?: string;\n  response?: string;\n  done: boolean;\n  context?: number[];\n  total_duration?: number;\n  load_duration?: number;\n  prompt_eval_count?: number;\n  prompt_eval_duration?: number;\n  eval_count?: number;\n  eval_duration?: number;\n  tool_calls?: any[];\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/types/openai.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[170,173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[170,173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1168,1171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1168,1171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1341,1344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1341,1344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2129,2132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2129,2132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OpenAI API Types\n */\n\nexport interface OpenAIFunction {\n  name: string;\n  description?: string;\n  parameters: {\n    type: 'object';\n    properties: Record<string, any>;\n    required?: string[];\n  };\n}\n\nexport interface OpenAITool {\n  type: 'function';\n  function: OpenAIFunction;\n}\n\nexport interface OpenAIToolCall {\n  id: string;\n  type: 'function';\n  function: {\n    name: string;\n    arguments: string;\n  };\n}\n\nexport interface OpenAIMessage {\n  role: 'system' | 'user' | 'assistant' | 'tool';\n  content: string | null;\n  name?: string;\n  tool_calls?: OpenAIToolCall[];\n  tool_call_id?: string;\n}\n\nexport interface OpenAIRequest {\n  model: string;\n  messages: OpenAIMessage[];\n  tools?: OpenAITool[];\n  tool_choice?: 'none' | 'auto' | { type: 'function'; function: { name: string } };\n  temperature?: number;\n  top_p?: number;\n  max_tokens?: number;\n  stream?: boolean;\n  stop?: string | string[];\n  functions?: OpenAIFunction[]; // Legacy support\n  function_call?: 'none' | 'auto' | { name: string }; // Legacy support\n}\n\nexport interface OpenAIUsage {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n  prompt_tokens_details?: any;\n}\n\nexport interface OpenAIChoice {\n  index: number;\n  message: OpenAIMessage;\n  finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | null;\n  logprobs?: any;\n  native_finish_reason?: string;\n}\n\nexport interface OpenAIResponse {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  provider?: string;\n  choices: OpenAIChoice[];\n  usage: OpenAIUsage;\n}\n\n// Streaming types\nexport interface OpenAIStreamChunk {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: string;\n  provider?: string;\n  choices: Array<{\n    index: number;\n    delta: {\n      role?: 'assistant';\n      content?: string;\n      tool_calls?: Array<{\n        index?: number;\n        id?: string;\n        type?: 'function';\n        function?: {\n          name?: string;\n          arguments?: string;\n        };\n      }>;\n    };\n    finish_reason?: 'stop' | 'length' | 'tool_calls' | 'content_filter' | null;\n    logprobs?: any;\n  }>;\n  usage?: OpenAIUsage;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/types/toolbridge.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[390,393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[390,393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[690,693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[690,693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[709,712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[709,712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[732,735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[732,735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[764,767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[764,767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[853,856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[853,856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2122,2125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2122,2125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2144,2147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2144,2147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ToolBridge Core Types\n */\n\nimport type { OpenAITool } from './openai.js';\n\nexport type RequestFormat = 'openai' | 'ollama';\n\nexport interface ToolCallDetectionResult {\n  isPotential: boolean;\n  isCompletedXml: boolean;\n  rootTagName: string | null;\n  confidence: number;\n  mightBeToolCall: boolean;\n}\n\nexport interface ExtractedToolCall {\n  name: string;\n  arguments: Record<string, any> | string;\n}\n\nexport interface BackendPayload {\n  model: string;\n  messages?: Array<{\n    role: string;\n    content: string;\n  }>;\n  prompt?: string; // For Ollama format\n  temperature?: number;\n  top_p?: number;\n  max_tokens?: number;\n  stream?: boolean;\n  tools?: OpenAITool[];\n  tool_choice?: any;\n  functions?: any;\n  function_call?: any;\n  options?: Record<string, any>; // For Ollama options\n  template?: string; // For Ollama template\n  [key: string]: any;\n}\n\nexport interface StreamProcessor {\n  res?: import('express').Response | undefined;\n  processChunk(chunk: Buffer | string): void;\n  setTools?(tools: OpenAITool[]): void;\n  handleDone?(): void;\n  end(): void;\n  closeStream?(message?: string | null): void;\n  closeStreamWithError?(errorMessage: string): void;\n  pipeFrom?(stream: NodeJS.ReadableStream): void;\n}\n\nexport interface WrapperAwareStreamProcessor extends StreamProcessor {\n  buffer: string;\n  inWrapper: boolean;\n  wrapperContent: string;\n  beforeWrapperContent: string;\n  knownToolNames: string[];\n  unwrappedBuffer: string;\n  checkingUnwrapped: boolean;\n  originalProcessor: StreamProcessor;\n}\n\nexport interface ToolCallHandlerConfig {\n  enableToolReinjection: boolean;\n  toolReinjectionMessageCount: number;\n  toolReinjectionTokenCount: number;\n  toolReinjectionType: 'system' | 'user';\n}\n\nexport interface ProxyConfig {\n  proxyPort: number;\n  proxyHost: string;\n  backendLlmBaseUrl: string;\n  backendLlmApiKey: string;\n  debugMode: boolean;\n  maxStreamBufferSize: number;\n  streamConnectionTimeout: number;\n  ollamaBaseUrl?: string;\n  ollamaDefaultContextLength: number;\n}\n\n// Error types\nexport interface BackendError extends Error {\n  status?: number;\n  response?: {\n    status: number;\n    data: any;\n  };\n  request?: any;\n}\n\n// Request context\nexport interface RequestContext {\n  clientRequestFormat: RequestFormat;\n  backendTargetFormat: RequestFormat;\n  originalTools: OpenAITool[];\n  clientRequestedStream: boolean;\n  clientAuthHeader: string;\n  clientHeaders: Record<string, string>;\n}\n\n// XML parsing specific types\nexport interface XMLParserStrategy {\n  canHandle(text: string, toolName: string): boolean;\n  extract(text: string, toolName: string): ExtractedToolCall | null;\n}\n\nexport interface XMLParsingResult {\n  success: boolean;\n  toolCall: ExtractedToolCall | null;\n  strategy: string;\n  error?: string;\n}\n\n// Stream chunk types for internal processing\nexport interface InternalStreamChunk {\n  type: 'content' | 'tool_call' | 'done' | 'error';\n  content?: string;\n  toolCall?: ExtractedToolCall;\n  error?: string;\n  metadata?: {\n    chunkIndex: number;\n    timestamp: number;\n  };\n}\n\n// Partial tool call extraction types\nexport interface PartialToolCallState {\n  rootTag: string | null;\n  isPotential: boolean;\n  mightBeToolCall: boolean;\n  buffer: string;\n  identifiedToolName: string | null;\n}\n\nexport interface PartialExtractionResult {\n  complete: boolean;\n  toolCall?: ExtractedToolCall;\n  content?: string;\n  partialState?: PartialToolCallState;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/configLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/ollama/detector.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":2,"column":41,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":2,"endColumn":53}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function isOllamaFormat(obj: unknown): obj is Record<string, unknown> {\n  if (obj && typeof obj === \"object\" && obj !== null) {\n    const record = obj as Record<string, unknown>;\n    \n    // Check for Ollama-specific fields\n    if (\n      typeof record.prompt === \"string\" ||\n      typeof record.response === \"string\" ||\n      typeof record.done === \"boolean\"\n    ) {\n      return true;\n    }\n\n    // Check for Ollama response format with model, created_at\n    if (\n      record.model &&\n      record.created_at &&\n      (record.response !== undefined || record.done !== undefined)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/ollama/requestConverter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":10,"column":6,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":10,"endColumn":52,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[370,416],"text":"((updatedRequest.template?.includes(\"ToolCalls\")) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[369,416],"text":"(updatedRequest.template?.includes(\"ToolCalls\")) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":32,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":32,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1053,1110],"text":"ollamaRequest.options ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":36,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":36,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1229,1286],"text":"ollamaRequest.options ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":40,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":40,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1398,1455],"text":"ollamaRequest.options ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":44,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":44,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1572,1629],"text":"ollamaRequest.options ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":50,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":50,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":50,"column":7,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":50,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":72,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":72,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2574,2576],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":92,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":92,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":147,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":147,"endColumn":32}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import logger from \"../../logger.js\";\nimport { formatToolsForBackendPromptXML } from \"../../promptUtils.js\";\n\nimport type { OpenAIRequest, OllamaRequest, OpenAIMessage } from \"../../../types/index.js\";\n\nexport function convertOllamaRequestToOllama(ollamaRequest: OllamaRequest): OllamaRequest {\n  const updatedRequest: OllamaRequest = { ...ollamaRequest };\n\n  if (\n    !updatedRequest.template?.includes(\"ToolCalls\")\n  ) {\n    updatedRequest.template =\n  updatedRequest.template ??= \"{{system}}\\n{{user}}\\n{{assistant}}\";\n    updatedRequest.template += \" ToolCalls\";\n    logger.debug(\n      \"[CONVERT] Added ToolCalls to Ollama template for tool support signaling\",\n    );\n  }\n\n  return updatedRequest;\n}\n\nexport function convertOpenAIRequestToOllama(openAIRequest: OpenAIRequest): OllamaRequest {\n  const ollamaRequest: OllamaRequest = {\n    model: openAIRequest.model,\n    stream: openAIRequest.stream === true,\n    options: {},\n    template: \"{{system}}\\n{{user}}\\n{{assistant}} ToolCalls\",\n  };\n\n  if (openAIRequest.temperature !== undefined) {\n    if (!ollamaRequest.options) {ollamaRequest.options = {};}\n    ollamaRequest.options.temperature = openAIRequest.temperature;\n  }\n  if (openAIRequest.top_p !== undefined) {\n    if (!ollamaRequest.options) {ollamaRequest.options = {};}\n    ollamaRequest.options.top_p = openAIRequest.top_p;\n  }\n  if (openAIRequest.max_tokens !== undefined) {\n    if (!ollamaRequest.options) {ollamaRequest.options = {};}\n    ollamaRequest.options.num_predict = openAIRequest.max_tokens;\n  }\n  if (openAIRequest.stop !== undefined) {\n    if (!ollamaRequest.options) {ollamaRequest.options = {};}\n    ollamaRequest.options.stop = Array.isArray(openAIRequest.stop)\n      ? openAIRequest.stop\n      : [openAIRequest.stop];\n  }\n\n  if (openAIRequest.messages && openAIRequest.messages.length > 0) {\n    const systemMessages = openAIRequest.messages.filter(\n      (msg) => msg.role === \"system\",\n    );\n\n    if (systemMessages.length > 0) {\n      ollamaRequest.system = systemMessages\n        .map((msg) => msg.content)\n        .join(\"\\n\\n\");\n    }\n\n    const userMessages = openAIRequest.messages.filter(\n      (msg) => msg.role === \"user\",\n    );\n    if (userMessages.length > 0) {\n      ollamaRequest.prompt = userMessages[userMessages.length - 1].content ?? '';\n    } else {\n      logger.debug(\n        \"[CONVERT] OpenAI request has messages but no user message. Using last message content for prompt.\",\n      );\n      const lastMessage =\n        openAIRequest.messages[openAIRequest.messages.length - 1];\n  ollamaRequest.prompt = lastMessage?.content ?? \"\";\n    }\n  }\n\n  if (openAIRequest.tools && openAIRequest.tools.length > 0) {\n    logger.debug(\n      \"[CONVERT] Converting OpenAI tools for Ollama request (using system prompt injection)\",\n    );\n    const toolInstructions = formatToolsForBackendPromptXML(\n      openAIRequest.tools,\n    );\n    ollamaRequest.system =\n      (ollamaRequest.system ? ollamaRequest.system + \"\\n\\n\" : \"\") +\n      toolInstructions;\n\n    logger.debug(\n      \"[CONVERT] Injected tool instructions into Ollama system prompt.\",\n    );\n  }\n\n  if (openAIRequest.tool_choice) {\n    logger.debug(\n      \"[CONVERT] OpenAI 'tool_choice' is not directly supported for Ollama conversion. Ignoring.\",\n    );\n  }\n\n  if (ollamaRequest.options && Object.keys(ollamaRequest.options).length === 0) {\n    delete ollamaRequest.options;\n  }\n\n  return ollamaRequest;\n}\n\nexport function convertOllamaRequestToOpenAI(ollamaRequest: OllamaRequest): OpenAIRequest {\n  const openAIRequest: OpenAIRequest = {\n    model: ollamaRequest.model,\n    stream: ollamaRequest.stream === true,\n    messages: [],\n  };\n\n  if (ollamaRequest.options) {\n    if (ollamaRequest.options.temperature !== undefined) {\n      openAIRequest.temperature = ollamaRequest.options.temperature;\n    }\n    if (ollamaRequest.options.top_p !== undefined) {\n      openAIRequest.top_p = ollamaRequest.options.top_p;\n    }\n    if (ollamaRequest.options.num_predict !== undefined) {\n      openAIRequest.max_tokens = ollamaRequest.options.num_predict;\n    }\n    if (ollamaRequest.options.stop !== undefined) {\n      openAIRequest.stop = ollamaRequest.options.stop;\n    }\n  }\n\n  if (ollamaRequest.system) {\n    const systemMessage: OpenAIMessage = {\n      role: \"system\",\n      content: ollamaRequest.system,\n    };\n    openAIRequest.messages.push(systemMessage);\n  }\n  if (ollamaRequest.prompt) {\n    const userMessage: OpenAIMessage = {\n      role: \"user\",\n      content: ollamaRequest.prompt,\n    };\n    openAIRequest.messages.push(userMessage);\n  }\n\n  if (ollamaRequest.tools) {\n    openAIRequest.tools = ollamaRequest.tools;\n\n    logger.debug(\"[CONVERT] Passing through Ollama tools to OpenAI request.\");\n  }\n  if (ollamaRequest.tool_choice) {\n    openAIRequest.tool_choice = ollamaRequest.tool_choice as \"none\" | \"auto\" | { type: \"function\"; function: { name: string; }; };\n    logger.debug(\n      \"[CONVERT] Passing through Ollama tool_choice to OpenAI request.\",\n    );\n  }\n\n  if (openAIRequest.messages.length === 0) {\n    logger.error(\n      \"[CONVERT] Ollama request could not be converted to OpenAI: Missing prompt or messages.\",\n    );\n\n    throw new Error(\n      \"Cannot convert Ollama request to OpenAI: No messages could be constructed.\",\n    );\n  }\n\n  return openAIRequest;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/ollama/responseConverter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":25,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":25,"endColumn":47,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[767,806],"text":"((updatedResponse.response?.includes(\"<\")) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[767,806],"text":"((updatedResponse.response?.includes(\"<\")) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":26,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":26,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[842,844],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":42,"column":12,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":42,"endColumn":32},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":44,"column":9,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":44,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":49,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":49,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1538,1540],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":54,"column":5,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":54,"endColumn":11},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":54,"column":5,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":54,"endColumn":11},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":64,"column":58,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":64,"endColumn":78},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":64,"column":58,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":64,"endColumn":78},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":97,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":97,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":109,"column":54,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":109,"endColumn":60},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":109,"column":54,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":109,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":117,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":117,"endColumn":58},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":117,"column":38,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":117,"endColumn":58},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":131,"column":33,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":131,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":152,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":152,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5895,5898],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5895,5898],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6510,6513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6510,6513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6653,6656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6653,6656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":231,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":231,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7424,7426],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":249,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":251,"endColumn":6,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[7939,8051],"text":"openAIChunk.choices[0].delta.content ??= '';"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":262,"column":10,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":262,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":300,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":300,"endColumn":57},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":311,"column":73,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":311,"endColumn":75,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[9948,9950],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":318,"column":59,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":318,"endColumn":61,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10250,10252],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":323,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":325,"endColumn":6,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[10345,10456],"text":"openAIResponse.choices[0].message.content ??= null;"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":329,"column":5,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":329,"endColumn":60}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import logger from \"../../logger.js\";\nimport { extractToolCallXMLParser } from \"../../xmlUtils.js\";\n\nimport type { \n  OpenAIResponse, \n  OpenAIStreamChunk, \n  OllamaResponse, \n  OllamaStreamChunk \n} from \"../../../types/index.js\";\n\nexport function convertOllamaResponseToOllama(ollamaResponse: OllamaResponse): OllamaResponse {\n  const updatedResponse: OllamaResponse = { ...ollamaResponse };\n\n  if (\n    updatedResponse.template &&\n    !updatedResponse.template.includes(\"ToolCalls\")\n  ) {\n    updatedResponse.template = updatedResponse.template + \" ToolCalls\";\n    logger.debug(\n      \"[CONVERT] Added ToolCalls to Ollama response template for tool support signaling\",\n    );\n  } else if (\n    !updatedResponse.template &&\n    (updatedResponse.tool_calls ||\n      (updatedResponse.response?.includes(\"<\") &&\n        updatedResponse.response?.includes(\">\")))\n  ) {\n    updatedResponse.template = \"{{system}}\\n{{user}}\\n{{assistant}} ToolCalls\";\n    logger.debug(\n      \"[CONVERT] Created template with ToolCalls for Ollama response with tool capabilities\",\n    );\n  }\n\n  return updatedResponse;\n}\n\nexport function convertOpenAIResponseToOllama(\n  openAIResponse: OpenAIResponse | OpenAIStreamChunk,\n  knownToolNames: string[] = [],\n): OllamaResponse | OllamaStreamChunk {\n  const baseOllamaResponse = {\n    model: openAIResponse.model ?? \"openai-model\",\n    created_at: new Date(\n      ((openAIResponse.created ?? Math.floor(Date.now() / 1000))) * 1000,\n    ).toISOString(),\n    done: false,\n  };\n\n  const choice = openAIResponse.choices?.[0];\n  const toNum = (v: unknown) => (typeof v === \"number\" ? v : 0);\n\n  if (\n    openAIResponse.object === \"chat.completion.chunk\" &&\n    choice &&\n    'delta' in choice\n  ) {\n    const delta = choice.delta;\n    const ollamaChunk: OllamaStreamChunk = {\n      ...baseOllamaResponse,\n      response: delta.content ?? \"\",\n      done: choice.finish_reason !== null,\n    };\n\n    if (ollamaChunk.done && 'usage' in openAIResponse && openAIResponse.usage) {\n      const usage = openAIResponse.usage as unknown as Record<string, unknown>;\n      ollamaChunk.total_duration = toNum(usage.total_duration);\n      ollamaChunk.load_duration = toNum(usage.load_duration);\n      ollamaChunk.prompt_eval_count = toNum(usage.prompt_tokens);\n      ollamaChunk.prompt_eval_duration = toNum(usage.prompt_eval_duration);\n      ollamaChunk.eval_count = toNum(usage.completion_tokens);\n      ollamaChunk.eval_duration = toNum(usage.eval_duration);\n    }\n\n  if (delta.tool_calls && delta.tool_calls.length > 0) {\n      ollamaChunk.tool_calls = delta.tool_calls.map((tc) => ({\n        function: {\n          name: tc.function?.name ?? \"\",\n      arguments: tc.function?.arguments,\n        },\n      }));\n\n      ollamaChunk.response = \"\";\n    } else if (\n      (delta.content ?? \"\").includes(\"<\") &&\n      (delta.content ?? \"\").includes(\">\")\n    ) {\n      const toolCall = extractToolCallXMLParser(delta.content ?? \"\", knownToolNames);\n      if (toolCall) {\n        logger.debug(\n          \"[CONVERT] Extracted XML tool call from OpenAI response content:\",\n          toolCall,\n        );\n        ollamaChunk.tool_calls = [\n          {\n            function: {\n              name: toolCall.name,\n              arguments: toolCall.arguments || {},\n            },\n          },\n        ];\n\n        ollamaChunk.response = \"\";\n      }\n    }\n\n    return ollamaChunk;\n  }\n\n  if (openAIResponse.object === \"chat.completion\" && choice && 'message' in choice) {\n    const message = choice.message;\n    const ollamaResponse: OllamaResponse = {\n      ...baseOllamaResponse,\n      response: message.content ?? \"\",\n      done: true,\n    };\n\n    if ('usage' in openAIResponse && openAIResponse.usage) {\n      const usage = openAIResponse.usage as unknown as Record<string, unknown>;\n      ollamaResponse.total_duration = toNum(usage.total_duration);\n      ollamaResponse.load_duration = toNum(usage.load_duration);\n      ollamaResponse.prompt_eval_count = toNum(usage.prompt_tokens);\n      ollamaResponse.prompt_eval_duration = toNum(usage.prompt_eval_duration);\n      ollamaResponse.eval_count = toNum(usage.completion_tokens);\n      ollamaResponse.eval_duration = toNum(usage.eval_duration);\n    }\n\n      if (message.tool_calls && message.tool_calls.length > 0) {\n      ollamaResponse.tool_calls = message.tool_calls.map((tc) => ({\n        function: {\n          name: tc.function.name,\n          arguments: JSON.parse(tc.function.arguments ?? \"{}\"),\n        },\n      }));\n\n      if (!message.content) {\n        ollamaResponse.response = \"\";\n      }\n    } else if (\n      (message.content ?? \"\").includes(\"<\") &&\n      (message.content ?? \"\").includes(\">\")\n    ) {\n      const toolCall = extractToolCallXMLParser(message.content ?? \"\", knownToolNames);\n      if (toolCall) {\n        logger.debug(\n          \"[CONVERT] Extracted XML tool call from OpenAI response content:\",\n          toolCall,\n        );\n        ollamaResponse.tool_calls = [\n          {\n            function: {\n              name: toolCall.name,\n              arguments: toolCall.arguments || {},\n            },\n          },\n        ];\n\n        ollamaResponse.response = \"\";\n      }\n    }\n\n    return ollamaResponse;\n  }\n\n  logger.debug(\n    \"[CONVERT] Unknown OpenAI response format encountered:\",\n    openAIResponse,\n  );\n  return { ...baseOllamaResponse, response: \"[Conversion Error]\", done: true };\n}\n\nexport function convertOllamaResponseToOpenAI(\n  ollamaResponse: OllamaResponse | OllamaStreamChunk,\n  stream: boolean = false,\n  knownToolNames: string[] = [],\n): OpenAIResponse | OpenAIStreamChunk {\n  const now = Math.floor(Date.now() / 1000);\n  const id = `chatcmpl-ollama-${Date.now()}`;\n\n  const toNum = (v: unknown) => (typeof v === \"number\" ? v : 0);\n\n  if (stream) {\n    const openAIChunk: OpenAIStreamChunk = {\n      id: id,\n      object: \"chat.completion.chunk\",\n      created: now,\n      model: (ollamaResponse as any).model ?? \"ollama-model\",\n      choices: [\n        {\n          index: 0,\n          delta: {\n            role: \"assistant\",\n            content: ollamaResponse.response ?? '',\n          },\n          finish_reason: ollamaResponse.done ? \"stop\" : null,\n          logprobs: null,\n        },\n      ],\n    };\n\n    if (ollamaResponse.done) {\n      openAIChunk.choices[0].finish_reason = \"stop\";\n\n      if (ollamaResponse.tool_calls) {\n        openAIChunk.choices[0].finish_reason = \"tool_calls\";\n      }\n\n      if (\n        ('eval_count' in (ollamaResponse as unknown as Record<string, unknown>) && (ollamaResponse as any).eval_count !== undefined) ||\n        ('prompt_eval_count' in (ollamaResponse as unknown as Record<string, unknown>) && (ollamaResponse as any).prompt_eval_count !== undefined)\n      ) {\n        const r = ollamaResponse as unknown as Record<string, unknown>;\n        const prompt = toNum(r.prompt_eval_count);\n        const evalc = toNum(r.eval_count);\n        openAIChunk.usage = {\n          prompt_tokens: prompt,\n          completion_tokens: evalc,\n          total_tokens: prompt + evalc,\n        };\n      }\n    } else {\n      openAIChunk.choices[0].finish_reason = null;\n    }\n\n  if (ollamaResponse.tool_calls && !ollamaResponse.done) {\n      openAIChunk.choices[0].delta = {\n        tool_calls: ollamaResponse.tool_calls.map((tc, index) => ({\n          index: index,\n          id: `call_ollama_${Date.now()}_${index}`,\n          type: \"function\",\n          function: {\n            name: tc.function?.name || \"\",\n    arguments: JSON.stringify(tc.function?.arguments ?? {}),\n          },\n        })),\n      };\n\n      openAIChunk.choices[0].delta.content = '';\n      openAIChunk.choices[0].finish_reason = null;\n    } else if (!ollamaResponse.response && !ollamaResponse.done) {\n      openAIChunk.choices[0].delta.content = \"\";\n    } else if (\n      !ollamaResponse.response &&\n      ollamaResponse.done &&\n      !openAIChunk.choices[0].finish_reason\n    ) {\n      openAIChunk.choices[0].finish_reason = \"stop\";\n    }\n\n    if (openAIChunk.choices[0].delta.content === undefined) {\n      openAIChunk.choices[0].delta.content = '';\n    }\n\n    return openAIChunk;\n  }\n\n    const openAIResponse: OpenAIResponse = {\n    id: id,\n    object: \"chat.completion\",\n    created: ('created_at' in ollamaResponse && ollamaResponse.created_at)\n      ? Math.floor(new Date(ollamaResponse.created_at).getTime() / 1000)\n      : now,\n  model: ollamaResponse.model ?? \"ollama-model\",\n    choices: [\n      {\n        index: 0,\n        message: {\n          role: \"assistant\",\n          content: ollamaResponse.response ?? null,\n        },\n        finish_reason: \"stop\",\n        logprobs: null,\n      },\n    ],\n    usage: {\n      prompt_tokens: toNum((ollamaResponse as unknown as Record<string, unknown>).prompt_eval_count),\n      completion_tokens: toNum((ollamaResponse as unknown as Record<string, unknown>).eval_count),\n      total_tokens:\n        toNum((ollamaResponse as unknown as Record<string, unknown>).prompt_eval_count) +\n        toNum((ollamaResponse as unknown as Record<string, unknown>).eval_count),\n    },\n  };\n\n  if (ollamaResponse.response) {\n    const toolCall = extractToolCallXMLParser(\n      ollamaResponse.response,\n      knownToolNames,\n    );\n    if (toolCall) {\n      logger.debug(\n        \"[CONVERT] Detected XML tool call in Ollama response:\",\n        toolCall,\n      );\n      openAIResponse.choices[0].message.content = null;\n      openAIResponse.choices[0].message.tool_calls = [\n        {\n          id: `call_ollama_${Date.now()}`,\n          type: \"function\",\n          function: {\n            name: toolCall.name,\n            arguments: JSON.stringify(toolCall.arguments || {}),\n          },\n        },\n      ];\n      openAIResponse.choices[0].finish_reason = \"tool_calls\";\n    }\n  } else if (ollamaResponse.tool_calls) {\n    logger.debug(\n      \"[CONVERT] Detected structured tool calls in Ollama response:\",\n      ollamaResponse.tool_calls,\n    );\n    openAIResponse.choices[0].message.content = ollamaResponse.response || null;\n    openAIResponse.choices[0].message.tool_calls =\n      ollamaResponse.tool_calls.map((tc, index) => ({\n        id: `call_ollama_${Date.now()}_${index}`,\n        type: \"function\",\n        function: {\n          name: tc.function.name,\n          arguments: JSON.stringify(tc.function.arguments || {}),\n        },\n      }));\n    openAIResponse.choices[0].finish_reason = \"tool_calls\";\n\n    if (!openAIResponse.choices[0].message.content) {\n      openAIResponse.choices[0].message.content = null;\n    }\n  }\n\n  if (\n    openAIResponse.choices[0].message.content === undefined &&\n    !openAIResponse.choices[0].message.tool_calls\n  ) {\n    openAIResponse.choices[0].message.content = null;\n  }\n\n  return openAIResponse;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/openai/detector.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":2,"column":41,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":2,"endColumn":53}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function isOpenAIFormat(obj: unknown): obj is Record<string, unknown> {\n  if (obj && typeof obj === \"object\" && obj !== null) {\n    const record = obj as Record<string, unknown>;\n    \n    // Check for OpenAI request format (messages array) or response format (choices array)\n    if (Array.isArray(record.messages) || Array.isArray(record.choices)) {\n      return true;\n    }\n\n    // Check for streaming format\n    if (record.object === \"chat.completion.chunk\" && Array.isArray(record.choices)) {\n      return true;\n    }\n  }\n  return false;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/openai/requestConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/format/openai/responseConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/formatConverters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/headerUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/parsingChallengeCapturer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/promptUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":16,"column":7,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":16,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always false, since `\"function\" !== \"function\"` is false.","line":20,"column":11,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":20,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":20,"column":43,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":20,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":20,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":20,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":27,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":27,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":27,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":27,"endColumn":21},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":27,"column":11,"nodeType":null,"messageId":"preferOptionalChain","endLine":27,"endColumn":46,"suggestions":[{"fix":{"range":[732,767],"text":"parameters?.properties"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":27,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":27,"endColumn":46},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":27,"column":25,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":27,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":50,"column":7,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":50,"endColumn":12},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":50,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":50,"endColumn":12},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":53,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":53,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":53,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":53,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":53,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":53,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1575,1577],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":59,"column":9,"nodeType":"ChainExpression","messageId":"alwaysTruthy","endLine":59,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":59,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":59,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":59,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":59,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1749,1751],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":65,"column":9,"nodeType":"ChainExpression","messageId":"alwaysTruthy","endLine":65,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":65,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":65,"endColumn":42},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":65,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":65,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1922,1924],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":219,"column":7,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":219,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":222,"column":13,"nodeType":"ArrowFunctionExpression","messageId":"conditionErrorOther","endLine":222,"endColumn":55,"suggestions":[{"messageId":"explicitBooleanReturnType","fix":{"range":[9089,9089],"text":": boolean"},"desc":"Add an explicit `boolean` return type annotation."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"function\" === \"function\"` is true.","line":222,"column":20,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":222,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":222,"column":45,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":222,"endColumn":55},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":234,"column":14,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":234,"endColumn":16,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9537,9539],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":234,"column":36,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":234,"endColumn":66},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":234,"column":43,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":234,"endColumn":45,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9566,9568],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":244,"column":7,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":244,"endColumn":24}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OpenAITool, OpenAIMessage } from \"../types/index.js\";\n\ninterface ToolParameter {\n  type?: string;\n  description?: string;\n  [key: string]: unknown;\n}\n\ninterface ExampleTool {\n  name: string;\n  desc: string;\n  example: string;\n}\n\nfunction formatToolsForBackendPromptXML(tools?: OpenAITool[]): string {\n  if (tools === null || tools === undefined || tools.length === 0) { return \"\"; }\n\n  const toolDescriptions = tools\n    .map((toolSpec) => {\n      if (toolSpec.type !== \"function\" || !toolSpec.function) {return \"\";}\n\n      const { name, description, parameters } = toolSpec.function;\n      let result = `Tool Name: ${name}\\nDescription: ${\n  description ?? \"No description provided\"\n      }\\nParameters:`;\n\n      if (parameters && parameters.properties) {\n        const props = parameters.properties as Record<string, ToolParameter>;\n        const required = parameters.required ?? [];\n\n        Object.keys(props).forEach((paramName) => {\n          const param = props[paramName];\n          const paramDesc = param.description ?? \"No description\";\n          const isRequired = Array.isArray(required) && required.includes(paramName);\n\n          result += `\\n* ${paramName} (${param.type ?? \"any\"}): ${paramDesc}${\n            isRequired ? \" (required)\" : \"\"\n          }`;\n        });\n      } else {\n        result += \"\\n* No parameters defined\";\n      }\n\n      return result;\n    })\n    .join(\"\\n\\n\");\n\n  const exampleTools: ExampleTool[] = [];\n\n  if (tools && tools.length > 0) {\n    const noParamTool = tools.find(\n      (t) =>\n        !t.function.parameters?.properties ||\n        Object.keys(t.function.parameters.properties).length === 0,\n    );\n\n    const singleParamTool = tools.find(\n      (t) =>\n        t.function.parameters?.properties &&\n        Object.keys(t.function.parameters.properties).length === 1,\n    );\n\n    const multiParamTool = tools.find(\n      (t) =>\n        t.function.parameters?.properties &&\n        Object.keys(t.function.parameters.properties).length > 1,\n    );\n\n  if (noParamTool) {\n      exampleTools.push({\n        name: noParamTool.function.name,\n        desc: \"Tool with no parameters\",\n        example: `<toolbridge:calls>\\n  <${noParamTool.function.name}></${noParamTool.function.name}>\\n</toolbridge:calls>`,\n      });\n    }\n\n    if (singleParamTool) {\n      const paramName = Object.keys(\n        singleParamTool.function.parameters.properties,\n      )[0];\n      const paramProps = singleParamTool.function.parameters.properties as Record<string, ToolParameter>;\n      const paramType = paramProps[paramName].type ?? \"string\";\n      let paramValue = \"example value\";\n\n  if (paramType === \"number\") { paramValue = \"42\"; }\n  else if (paramType === \"boolean\") { paramValue = \"true\"; }\n  else if (paramName.includes(\"query\")) { paramValue = \"What is the capital of France?\"; }\n  else if (paramName.includes(\"url\")) { paramValue = \"https://example.com\"; }\n\n      exampleTools.push({\n        name: singleParamTool.function.name,\n        desc: `Tool with a single ${paramType} parameter: '${paramName}'`,\n        example: `<toolbridge:calls>\\n  <${singleParamTool.function.name}>\\n    <${paramName}>${paramValue}</${paramName}>\\n  </${singleParamTool.function.name}>\\n</toolbridge:calls>`,\n      });\n    }\n\n  if (multiParamTool) {\n      const params = Object.entries(\n        multiParamTool.function.parameters.properties as Record<string, ToolParameter>,\n      );\n    const paramLines = params\n        .map(([name, schema]) => {\n      const type = schema.type ?? \"string\";\n          let value = \"example\";\n\n          if (type === \"number\") { value = \"42\"; }\n          else if (type === \"boolean\") { value = \"true\"; }\n          else if (name.includes(\"date\")) { value = \"2025-05-15\"; }\n          else if (name.includes(\"email\")) { value = \"user@example.com\"; }\n          else if (name.includes(\"url\")) { value = \"https://example.com\"; }\n          else if (name.includes(\"name\")) { value = \"Example Name\"; }\n\n          return `  <${name}>${value}</${name}>`;\n        })\n        .join(\"\\n\");\n\n      exampleTools.push({\n        name: multiParamTool.function.name,\n        desc: `Tool with ${params.length} parameters of various types`,\n        example: `<toolbridge:calls>\\n  <${multiParamTool.function.name}>\\n${paramLines.split('\\n').map(line => '  ' + line).join('\\n')}\\n  </${multiParamTool.function.name}>\\n</toolbridge:calls>`,\n      });\n    }\n  }\n\n  if (exampleTools.length < 2) {\n    if (!exampleTools.some((t) => t.desc.includes(\"no parameters\"))) {\n      exampleTools.push({\n        name: \"getCurrentWeather\",\n        desc: \"Generic example: Tool with no parameters\",\n        example: \"<toolbridge:calls>\\n  <getCurrentWeather></getCurrentWeather>\\n</toolbridge:calls>\",\n      });\n    }\n\n    if (!exampleTools.some((t) => t.desc.includes(\"single\"))) {\n      exampleTools.push({\n        name: \"searchWeb\",\n        desc: \"Generic example: Tool with a single string parameter\",\n        example:\n          \"<toolbridge:calls>\\n  <searchWeb>\\n    <query>What is the capital of France?</query>\\n  </searchWeb>\\n</toolbridge:calls>\",\n      });\n    }\n\n    if (!exampleTools.some((t) => t.desc.includes(\"various types\"))) {\n      exampleTools.push({\n        name: \"bookFlight\",\n        desc: \"Generic example: Tool with multiple parameters of different types\",\n        example:\n          \"<toolbridge:calls>\\n  <bookFlight>\\n    <destination>Tokyo</destination>\\n    <departureDate>2025-05-15</departureDate>\\n    <returnDate>2025-05-30</returnDate>\\n    <passengers>2</passengers>\\n    <businessClass>true</businessClass>\\n  </bookFlight>\\n</toolbridge:calls>\",\n      });\n    }\n  }\n\n  exampleTools.push({\n    name: \"createUserProfile\",\n    desc: \"Advanced example: Tool with nested object parameters\",\n    example:\n      \"<toolbridge:calls>\\n  <createUserProfile>\\n    <userData>\\n      <n>John Doe</n>\\n      <email>john.doe@example.com</email>\\n      <preferences>\\n        <theme>dark</theme>\\n        <notifications>true</notifications>\\n      </preferences>\\n    </userData>\\n  </createUserProfile>\\n</toolbridge:calls>\",\n  });\n\n  exampleTools.push({\n    name: \"insert_edit_into_file\",\n    desc: \"Tool with raw HTML content in parameters (never escape HTML and other such tags)\",\n    example:\n      '<toolbridge:calls>\\n  <insert_edit_into_file>\\n    <explanation>Update HTML content</explanation>\\n    <filePath>/path/to/file.html</filePath>\\n    <code><div class=\"container\">\\n    <h1>Raw HTML tags</h1>\\n    <p>This content has <b>unescaped</b> HTML tags</p>\\n  </div></code>\\n  </insert_edit_into_file>\\n</toolbridge:calls>',\n  });\n\n  const examplesText = exampleTools\n    .map((tool, index) => `Example ${index + 1}: ${tool.desc}\\n${tool.example}`)\n    .join(\"\\n\\n\");\n\n  return `# TOOL USAGE INSTRUCTIONS\n\n## Available Tools\nYou have access to the following tools:\n\n${toolDescriptions}\n\n## Response Format\nWhen using a tool, you MUST wrap your tool calls in <toolbridge:calls> tags.\nONLY content within these wrapper tags will be parsed as tool calls.\nOutput the raw XML for the tool call without any additional text, code blocks, or explanations.\n\n## Examples of Correct Tool Usage\n${examplesText}\n\n## Critical Rules\n1. ALWAYS wrap tool calls in <toolbridge:calls>...</toolbridge:calls> tags\n2. ONLY output raw XML when calling a tool - no explanations, backticks, or code blocks\n3. Never mention XML format or tools to users - they are internal only\n4. Always use the EXACT tool name as specified above - do NOT create new tool names\n5. For HTML content in parameters: ALWAYS use raw tags (<div>, <p>, etc.) - NEVER use HTML entities (&lt;div&gt;)\n\n## XML Formatting Requirements\n- ALL tool calls MUST be wrapped in <toolbridge:calls>...</toolbridge:calls> tags\n- Content outside these wrapper tags will NOT be parsed as tool calls\n- Root element (inside wrapper) MUST be the EXACT tool name as listed above\n- Each parameter must be a child element\n- For arrays: repeat the element name for each value (e.g., '<tags>tag1</tags><tags>tag2</tags>')\n- For empty values: use '<param></param>' or self-closing '<param/>'\n- For boolean values: use '<param>true</param>' or '<param>false</param>'\n- For HTML/code content: include raw HTML tags directly (<div>, <span>, etc.) - never use HTML entities\n- For object parameters: use proper nesting of elements\n- Ensure every opening tag has a matching closing tag\n\n## When to Use Tools\n- When the user's request requires specific capabilities provided by a tool\n- When the context or workflow explicitly calls for tool usage\n- When you need to perform actions outside your standard capabilities\n\n## Handling Errors\n- If a tool call fails, carefully review the error message\n- Correct any formatting issues or invalid parameters\n- Retry with proper parameters as indicated by the error\n\nRemember that tools are invisible to the user - focus on addressing their needs, not explaining the tools.`;\n}\n\nfunction createToolReminderMessage(tools?: OpenAITool[]): string {\n  if (tools === null || tools === undefined || tools.length === 0) {return \"\";}\n\n  const toolNames = tools\n    .filter((t) => t.type === \"function\" && t.function)\n    .map((t) => t.function.name)\n    .join(\", \");\n\n  return `REMINDER: You have access to these tools: ${toolNames}. \n  \nUse ONLY these EXACT tool names with XML format.\nOutput raw XML only when calling tools - no code blocks or backticks.\nFor HTML content: ALWAYS use raw tags (<div>) - NEVER use HTML entities (&lt;div&gt;).`;\n}\n\nfunction estimateTokenCount(message: OpenAIMessage): number {\n  if (message?.content === null || message?.content === undefined) { return 0; }\n\n  return Math.ceil(message.content.length / 4);\n}\n\nfunction needsToolReinjection(\n  messages?: OpenAIMessage[], \n  tokenCount = 0, \n  messageCount = 0\n): boolean {\n  if (messages === null || messages === undefined || messages.length === 0) {return false;}\n\n  let msgCount = 0;\n  let tokCount = 0;\n  let foundSystemMsg = false;\n\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n\n    if (msg.role === \"system\") {\n      foundSystemMsg = true;\n      break;\n    }\n\n    msgCount++;\n    tokCount += estimateTokenCount(msg);\n  }\n\n  return !foundSystemMsg || msgCount >= messageCount || tokCount >= tokenCount;\n}\n\nexport {\n  createToolReminderMessage,\n  estimateTokenCount,\n  formatToolsForBackendPromptXML,\n  needsToolReinjection,\n};","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/requestLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/sseUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":80,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":80,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OpenAIStreamChunk, ExtractedToolCall } from \"../types/index.js\";\n\nexport function formatSSEChunk(data: unknown): string {\n  return `data: ${JSON.stringify(data)}\\n\\n`;\n}\n\nexport function createChatStreamChunk(\n  id?: string | null,\n  model?: string | null,\n  contentDelta?: string | null,\n  finishReason: \"stop\" | \"length\" | \"tool_calls\" | \"content_filter\" | null = null,\n): OpenAIStreamChunk {\n  const chunk: OpenAIStreamChunk = {\n  id: id ?? `chatcmpl-proxy-stream-${Date.now()}`,\n    object: \"chat.completion.chunk\",\n    created: Math.floor(Date.now() / 1000),\n  model: model ?? \"proxied-backend-model\",\n    choices: [\n      {\n        index: 0,\n        delta: { role: \"assistant\" },\n        finish_reason: finishReason,\n        logprobs: null,\n      },\n    ],\n  };\n\n  // Ensure delta.content is always a string (OpenAIStreamChunk expects string)\n  chunk.choices[0].delta.content = contentDelta ?? '';\n\n  if (finishReason === null) {\n    delete chunk.choices[0].finish_reason;\n  }\n\n  return chunk;\n}\n\nexport function createFunctionCallStreamChunks(\n  toolCall: ExtractedToolCall,\n  id?: string | null, \n  model?: string | null\n): OpenAIStreamChunk[] {\n  const baseId = id ?? `chatcmpl-proxy-func-${Date.now()}`;\n  const created = Math.floor(Date.now() / 1000);\n  const baseModel = model ?? \"proxied-backend-model\";\n\n  const roleChunk: OpenAIStreamChunk = {\n    id: baseId,\n    object: \"chat.completion.chunk\",\n    created: created,\n    model: baseModel,\n    choices: [\n      {\n        index: 0,\n        delta: {\n          role: \"assistant\",\n        },\n        finish_reason: null,\n      },\n    ],\n  };\n\n  const toolCallId = `call_${Date.now()}`;\n  const toolCallChunk: OpenAIStreamChunk = {\n    id: baseId,\n    object: \"chat.completion.chunk\",\n    created: created,\n    model: baseModel,\n    choices: [\n      {\n        index: 0,\n        delta: {\n          tool_calls: [\n            {\n              index: 0,\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCall.name,\n                arguments: JSON.stringify(toolCall.arguments || {}),\n              },\n            },\n          ],\n        },\n        finish_reason: null,\n      },\n    ],\n  };\n\n  const finishChunk: OpenAIStreamChunk = {\n    id: baseId,\n    object: \"chat.completion.chunk\",\n    created: created,\n    model: baseModel,\n    choices: [\n      {\n        index: 0,\n        delta: {},\n        finish_reason: \"tool_calls\",\n      },\n    ],\n  };\n\n  return [roleChunk, toolCallChunk, finishChunk];\n}\n\nexport function createFinalToolCallChunk(\n  id?: string | null, \n  model?: string | null\n): OpenAIStreamChunk {\n  return {\n  id: id ?? `chatcmpl-proxy-toolend-${Date.now()}`,\n    object: \"chat.completion.chunk\",\n    created: Math.floor(Date.now() / 1000),\n  model: model ?? \"proxied-backend-model\",\n    choices: [\n      {\n        index: 0,\n        delta: {},\n        finish_reason: \"tool_calls\",\n        logprobs: null,\n      },\n    ],\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/streamUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/xmlToolParser.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":212,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":214,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[6401,6520],"text":"wrappedContent ??= extractBetweenTags(textForParsing, WRAPPER_START_ALT, WRAPPER_END_ALT);"},"desc":"Fix to nullish coalescing operator (`??=`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import logger from \"./logger.js\";\n\nimport type { ExtractedToolCall } from \"../types/index.js\";\n\n/**\n * Robust XML Tool Call Parser with Wrapper Tags\n * \n * This parser ONLY processes tool calls within specific wrapper tags,\n * making it immune to false positives from regular XML/HTML content.\n */\n\n// Configurable wrapper tags - using namespace approach for maximum uniqueness\nconst WRAPPER_START = '<toolbridge:calls>';\nconst WRAPPER_END = '</toolbridge:calls>';\nconst WRAPPER_START_ALT = '<__toolcall__>';  // Alternative for backwards compatibility\nconst WRAPPER_END_ALT = '</__toolcall__>';\n\n// Helper: extract content between two tags (hoisted so callers below can use it)\n\n/**\n * Extract content between specific tags\n * Looks for the LAST complete wrapper to avoid getting wrapper tags mentioned in thinking\n */\nfunction extractBetweenTags(text: string, startTag: string, endTag: string): string | null {\n  // Find all occurrences of the wrapper tags\n  const startIndices: number[] = [];\n  let searchIndex = 0;\n  \n  while (searchIndex < text.length) {\n    const index = text.indexOf(startTag, searchIndex);\n    if (index === -1) {break;}\n    startIndices.push(index);\n    searchIndex = index + 1;\n  }\n  \n  // No start tags found\n  if (startIndices.length === 0) {return null;}\n  \n  // Try from the last occurrence first (most likely to be the actual tool call)\n  for (let i = startIndices.length - 1; i >= 0; i--) {\n    const startIndex = startIndices[i];\n    const contentStart = startIndex + startTag.length;\n    const endIndex = text.indexOf(endTag, contentStart);\n    \n    if (endIndex !== -1) {\n      const content = text.substring(contentStart, endIndex).trim();\n      \n      // Quick validation: should start with < and contain a tool name\n      if (content.startsWith('<') && content.includes('>')) {\n        return content;\n      }\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Parse tool call XML (only called for content within wrapper tags)\n */\n/**\n * Parse tool call XML (only called for content within wrapper tags)\n */\n\n/**\n * Extract nested object from XML\n */\n/**\n * Parse primitive values (string, number, boolean)\n */\nfunction parseValue(value: string): string | number | boolean {\n  const trimmed = value.trim();\n\n  // Boolean\n  if (trimmed.toLowerCase() === 'true') {return true;}\n  if (trimmed.toLowerCase() === 'false') {return false;}\n\n  // Number\n  if (!isNaN(Number(trimmed)) && trimmed !== '') {\n    return Number(trimmed);\n  }\n\n  // String (default)\n  return trimmed;\n}\n\n\n/**\n * Extract nested object from XML\n */\nfunction extractNestedObject(xml: string): Record<string, unknown> {\n  const obj: Record<string, unknown> = {};\n  const paramRegex = /<([a-zA-Z0-9_.-]+)>([\\s\\S]*?)<\\/\\1>/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = paramRegex.exec(xml)) !== null) {\n    const key = match[1];\n    let value: unknown = match[2];\n\n    // Check if this is another nested object\n    if (typeof value === 'string' && value.includes('<') && value.includes('>')) {\n      value = extractNestedObject(value);\n    } else {\n      value = parseValue(value as string);\n    }\n\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n/**\n * Extract parameters from tool XML\n */\nfunction extractParameters(xml: string, toolName: string): Record<string, unknown> {\n  const params: Record<string, unknown> = {};\n\n  // Create regex to extract content within tool tags\n  const contentRegex = new RegExp(\n    `<\\\\s*${toolName}[^>]*>([\\\\s\\\\S]*?)<\\\\/${toolName}>`,\n    'i'\n  );\n\n  const contentMatch = xml.match(contentRegex);\n  if (!contentMatch?.[1]) {\n    return params;\n  }\n\n  const content = contentMatch[1];\n\n  // Extract each parameter\n  const paramRegex = /<([a-zA-Z0-9_.-]+)>([\\s\\S]*?)<\\/\\1>/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = paramRegex.exec(content)) !== null) {\n    const paramName = match[1];\n    let paramValue: unknown = match[2];\n\n    // Handle nested objects\n    if (typeof paramValue === 'string' && paramValue.includes('<') && paramValue.includes('>')) {\n      // This is a nested object, parse recursively\n      paramValue = extractNestedObject(paramValue);\n    } else {\n      // Parse primitive values\n      paramValue = parseValue(paramValue as string);\n    }\n\n    params[paramName] = paramValue;\n  }\n\n  return params;\n}\n\nfunction parseToolCallXML(xml: string, knownToolNames: string[]): ExtractedToolCall | null {\n  // Find the root element\n  const rootMatch = xml.match(/^<\\s*([a-zA-Z0-9_.-]+)/);\n  if (!rootMatch?.[1]) {\n    logger.debug(\"[XML Tool Parser] No valid root element in wrapped content\");\n    return null;\n  }\n  \n  const toolName = rootMatch[1];\n  \n  // CRITICAL: Validate tool name against known tools\n  if (!knownToolNames.includes(toolName)) {\n    logger.warn(`[XML Tool Parser] Tool '${toolName}' not in known tools list`);\n    return null;\n  }\n  \n  logger.debug(`[XML Tool Parser] Valid tool found: ${toolName}`);\n  \n  // Extract parameters\n  try {\n    const params = extractParameters(xml, toolName);\n    return {\n      name: toolName,\n      arguments: params\n    };\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    logger.error(`[XML Tool Parser] Failed to extract parameters: ${errorMessage}`);\n    return null;\n  }\n}\n\nexport function extractToolCallFromWrapper(\n  text: string | null | undefined,\n  knownToolNames: string[] = []\n): ExtractedToolCall | null {\n  if (!text || typeof text !== \"string\") {\n    return null;\n  }\n\n  // Create a clean copy for parsing ONLY (preserve original for display)\n  let textForParsing = text;\n\n  // Remove thinking tags ONLY for parsing - keep them in actual response\n  // This ensures parser works while preserving reasoning for users who want it\n  textForParsing = textForParsing.replace(/think[\\s\\S]*?\\/think/g, '');\n  textForParsing = textForParsing.replace(/<thinking>[\\s\\S]*?<\\/thinking>/gi, '');\n  textForParsing = textForParsing.replace(/<think>[\\s\\S]*?<\\/think>/gi, '');\n  textForParsing = textForParsing.replace(/\\[thinking\\][\\s\\S]*?\\[\\/thinking\\]/gi, '');\n\n  logger.debug(`[XML Tool Parser] Checking for wrapped tool calls (original: ${text.length} chars, cleaned for parsing: ${textForParsing.length} chars)`);\n\n  // Check for primary wrapper in the cleaned text\n  let wrappedContent = extractBetweenTags(textForParsing, WRAPPER_START, WRAPPER_END);\n\n  // Fallback to alternative wrapper (use original text)\n  if (!wrappedContent) {\n    wrappedContent = extractBetweenTags(textForParsing, WRAPPER_START_ALT, WRAPPER_END_ALT);\n  }\n\n  // If no wrapper found, return null immediately (no parsing attempted)\n  if (!wrappedContent) {\n    logger.debug(\"[XML Tool Parser] No wrapper tags found - skipping parse\");\n    return null;\n  }\n\n  logger.debug(`[XML Tool Parser] Found wrapped content: ${wrappedContent.substring(0, 100)}...`);\n\n  // Now parse the wrapped content for tool calls\n  return parseToolCallXML(wrappedContent, knownToolNames);\n}\n\n/**\n * Check if text contains wrapper tags (quick check without parsing)\n */\nexport function hasToolCallWrapper(text: string | null | undefined): boolean {\n  if (!text) {return false;}\n  return text.includes(WRAPPER_START) || text.includes(WRAPPER_START_ALT);\n}\n\n/**\n * Get the wrapper tags for system prompt\n */\nexport function getWrapperTags(): {\n  start: string;\n  end: string;\n  example: string;\n} {\n  return {\n    start: WRAPPER_START,\n    end: WRAPPER_END,\n    example: `${WRAPPER_START}\\n  <tool_name>\\n    <parameter>value</parameter>\\n  </tool_name>\\n${WRAPPER_END}`\n  };\n}\n\nexport default {\n  extractToolCallFromWrapper,\n  hasToolCallWrapper,\n  getWrapperTags\n};","usedDeprecatedRules":[]},{"filePath":"/Users/m3hdi/toolbridge/src/utils/xmlUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":60,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":60,"endColumn":23},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":60,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":60,"endColumn":23},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":67,"column":11,"nodeType":null,"messageId":"preferOptionalChain","endLine":67,"endColumn":54,"suggestions":[{"fix":{"range":[2306,2349],"text":"potentialToolMatch?.[0]"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":91,"column":5,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":91,"endColumn":19},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":91,"column":5,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":91,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4967,4970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4967,4970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5195,5198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5195,5198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":228,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":228,"endColumn":57,"suggestions":[{"fix":{"range":[6877,6925],"text":"_previousState?.mightBeToolCall"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":424,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":424,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[12344,12346],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":425,"column":10,"nodeType":null,"messageId":"preferOptionalChain","endLine":425,"endColumn":61,"suggestions":[{"fix":{"range":[12356,12407],"text":"_previousState?.identifiedToolName"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { detectPotentialToolCall } from \"../handlers/toolCallHandler.js\";\n\nimport logger from \"./logger.js\";\n\nimport type { \n  ExtractedToolCall, \n  ToolCallDetectionResult,\n  PartialExtractionResult,\n  PartialToolCallState\n} from \"../types/index.js\";\n\nexport function extractToolCallXMLParser(\n  text: string | null | undefined, \n  knownToolNames: string[] = []\n): ExtractedToolCall | null {\n  if (!text || typeof text !== \"string\") {\n    logger.debug(\"[XML Parser] Empty or invalid input text.\");\n    return null;\n  }\n\n  logger.debug(\n    `[XML Parser] Attempting to extract tool call from text (length: ${text.length})`,\n  );\n\n  let processedText = text;\n\n  const codeBlockRegex = /```(?:xml|markup|)[\\s\\n]?([\\s\\S]*?)[\\s\\n]?```/i;\n  const codeBlockMatch = codeBlockRegex.exec(text);\n  if (codeBlockMatch?.[1]) {\n    processedText = codeBlockMatch[1];\n    logger.debug(\"[XML Parser] Extracted content from XML code block.\");\n  }\n\n  const xmlCommentRegex = /<!--\\s*([\\s\\S]*?)\\s*-->/;\n  const xmlCommentMatch = xmlCommentRegex.exec(processedText);\n  const commentContent = xmlCommentMatch?.[1]?.trim();\n  if (commentContent && commentContent.startsWith(\"<\") && commentContent.endsWith(\">\")) {\n    processedText = commentContent;\n    logger.debug(\"[XML Parser] Extracted content from XML comment.\");\n  }\n\n  const firstTagIndex = processedText.indexOf(\"<\");\n  if (firstTagIndex > 0) {\n    const removed = processedText.substring(0, firstTagIndex);\n    processedText = processedText.substring(firstTagIndex);\n    logger.debug(\n      `[XML Parser] Removed leading non-XML content: \"${removed.substring(0, 30)}...\"`,\n    );\n  } else if (firstTagIndex === -1) {\n    logger.debug(\"[XML Parser] No '<' character found. Not XML.\");\n    return null;\n  }\n\n  const trimmedText = processedText.trim();\n  if (!trimmedText.startsWith(\"<\") || !trimmedText.endsWith(\">\")) {\n    logger.debug(\n      \"[XML Parser] Text does not appear to be enclosed in XML tags after preprocessing.\",\n    );\n\n    if (knownToolNames && knownToolNames.length > 0) {\n      const toolRegexPattern = knownToolNames\n        .map((name) => `<\\\\s*${name}[\\\\s\\\\S]*?<\\\\/${name}>`)\n        .join(\"|\");\n      const toolFindRegex = new RegExp(`(${toolRegexPattern})`, \"i\");\n      const potentialToolMatch = processedText.match(toolFindRegex);\n\n      if (potentialToolMatch && potentialToolMatch[0]) {\n        const extractedTool = potentialToolMatch[0];\n        logger.debug(\n          \"[XML Parser] Extracted potential tool call from mixed content\",\n        );\n        processedText = extractedTool;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  const rootElementMatch = trimmedText.match(/^<\\s*([a-zA-Z0-9_.-]+)/);\n  if (!rootElementMatch?.[1]) {\n    logger.debug(\n      `[XML Parser] Could not extract root element name from: ${trimmedText.substring(0, 50)}...`,\n    );\n    return null;\n  }\n  const rootElementName = rootElementMatch[1];\n\n  const isKnownTool =\n    knownToolNames &&\n    knownToolNames.length > 0 &&\n    knownToolNames.some(\n      (tool) => tool.toLowerCase() === rootElementName.toLowerCase(),\n    );\n  if (!isKnownTool) {\n    logger.debug(\n      `[XML Parser] Root element '${rootElementName}' is not in knownToolNames list, ignoring.`,\n    );\n    return null;\n  }\n\n  logger.debug(\n    `[XML Parser] Root element: '${rootElementName}'. Using REGEX strategy for known tool.`,\n  );\n\n  try {\n    const toolFindRegex = new RegExp(\n      `<\\\\s*${rootElementName}[\\\\s\\\\S]*?<\\\\/${rootElementName}>`,\n      \"i\",\n    );\n    const potentialToolMatch = trimmedText.match(toolFindRegex);\n    const textToProcess = potentialToolMatch\n      ? potentialToolMatch[0]\n      : trimmedText;\n\n    const rootContentRegex = new RegExp(\n      `<\\\\s*${rootElementName}(?:\\\\s+[^>]*)?>([\\\\s\\\\S]*?)<\\\\/${rootElementName}>\\\\s*$`,\n      \"i\",\n    );\n    let rootContentMatch = rootContentRegex.exec(textToProcess);\n\n    if (typeof rootContentMatch?.[1] === \"undefined\") {\n      logger.warn(\n        `[XML Parser] Regex failed to find content within <${rootElementName}>...</${rootElementName}> tags.`,\n      );\n\n      if (!trimmedText.includes(`</${rootElementName}>`)) {\n        const fixedText = `${trimmedText}</${rootElementName}>`;\n        const fixedMatch = rootContentRegex.exec(fixedText);\n        if (typeof fixedMatch?.[1] !== \"undefined\") {\n          logger.debug(\n            `[XML Parser] Added missing closing tag </${rootElementName}> and re-matched.`,\n          );\n          rootContentMatch = fixedMatch;\n        } else {\n          logger.error(\n            `[XML Parser] Missing closing tag </${rootElementName}> - cannot reliably fix it.`,\n          );\n          return null;\n        }\n      } else {\n        logger.error(\n          `[XML Parser] Could not extract content for tool '${rootElementName}', structure might be invalid.`,\n        );\n        return null;\n      }\n    }\n\n    const rootContent = rootContentMatch[1];\n    const finalArgs: Record<string, any> = {};\n\n    const paramPattern = /<([a-zA-Z0-9_.-]+)>([\\s\\S]*?)<\\/\\1>/g;\n    let paramMatch;\n\n    while ((paramMatch = paramPattern.exec(rootContent)) !== null) {\n      const paramName = paramMatch[1];\n      let paramValue: any = paramMatch[2];\n\n      const lowerVal = paramValue.toLowerCase();\n      if (lowerVal === \"true\") {\n        paramValue = true;\n      } else if (lowerVal === \"false\") {\n        paramValue = false;\n      } else if (!isNaN(paramValue) && paramValue.trim() !== \"\") {\n        paramValue = Number(paramValue);\n      }\n\n      finalArgs[paramName] = paramValue;\n    }\n\n    logger.debug(\n      `[XML Parser] Successfully extracted parameters via regex for '${rootElementName}': ${Object.keys(finalArgs).join(\", \")}`,\n    );\n    return { name: rootElementName, arguments: finalArgs };\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    logger.error(\n      `[XML Parser] Error during REGEX parsing for tool '${rootElementName}':`,\n      errorMessage,\n    );\n    return null;\n  }\n}\n\nexport function attemptPartialToolCallExtraction(\n  content: string,\n  knownToolNames: string[] = [],\n  _previousState: PartialToolCallState | null = null,\n): PartialExtractionResult {\n  const MAX_BUFFER_SIZE = 10 * 1024;\n\n  const commonHtmlTags = [\n    \"div\",\n    \"span\",\n    \"p\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"style\",\n    \"script\",\n    \"link\",\n    \"meta\",\n    \"title\",\n    \"head\",\n    \"body\",\n    \"html\",\n    \"form\",\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n  ];\n\n  const htmlStartRegex = new RegExp(`^\\\\s*<(${commonHtmlTags.join(\"|\")})\\\\b`);\n  const htmlMatch = content.match(htmlStartRegex);\n\n  if (htmlMatch) {\n    const htmlTag = htmlMatch[1];\n    logger.debug(\n      `[XML Parser] Content starts with common HTML tag \"${htmlTag}\" - skipping extraction`,\n    );\n\n    if (_previousState && _previousState.mightBeToolCall) {\n      logger.debug(\n        `[XML Parser] Previously buffered content is now confirmed to be HTML. Resetting buffer.`,\n      );\n    }\n\n    for (const toolName of knownToolNames) {\n      const toolStartIndex = content.indexOf(`<${toolName}`);\n      if (toolStartIndex > 0) {\n        const closingTagPattern = new RegExp(`</${toolName}>`, \"i\");\n        const closingMatch = content.match(closingTagPattern);\n\n        if (closingMatch?.index !== undefined && closingMatch.index > toolStartIndex) {\n          const endIndex = closingMatch.index + closingMatch[0].length;\n          const toolCallContent = content.substring(toolStartIndex, endIndex);\n\n          const extracted = extractToolCallXMLParser(\n            toolCallContent,\n            knownToolNames,\n          );\n\n          if (\n            extracted &&\n            extracted.name.toLowerCase() === toolName.toLowerCase()\n          ) {\n            logger.debug(\n              `[XML Parser] Found tool call '${toolName}' after HTML content`,\n            );\n            return {\n              complete: true,\n              toolCall: extracted,\n              content: toolCallContent,\n            };\n          }\n        }\n      }\n    }\n\n    return {\n      complete: false,\n      partialState: {\n        rootTag: null,\n        isPotential: false,\n        mightBeToolCall: false,\n        buffer: \"\",\n        identifiedToolName: null,\n      },\n    };\n  }\n\n  if (content.length > MAX_BUFFER_SIZE) {\n    logger.debug(\n      `[XML Parser] Buffer size (${content.length} chars) exceeds maximum (${MAX_BUFFER_SIZE}). Resetting buffer.`,\n    );\n\n    const lastPart = content.substring(content.length - MAX_BUFFER_SIZE);\n    const prelimDetection: ToolCallDetectionResult = detectPotentialToolCall(lastPart, knownToolNames);\n\n    if (!prelimDetection.mightBeToolCall) {\n      return {\n        complete: false,\n        partialState: {\n          rootTag: null,\n          isPotential: false,\n          mightBeToolCall: false,\n          buffer: \"\",\n          identifiedToolName: null,\n        },\n      };\n    }\n\n    content = lastPart;\n  }\n\n  const detection: ToolCallDetectionResult = detectPotentialToolCall(content, knownToolNames);\n\n  if (detection.rootTagName && !detection.mightBeToolCall) {\n    logger.debug(\n      `[XML Parser] Tag \"${detection.rootTagName}\" confirmed not to be a tool call. Not buffering content.`,\n    );\n\n    return {\n      complete: false,\n      partialState: {\n        rootTag: null,\n        isPotential: false,\n        mightBeToolCall: false,\n        buffer: \"\",\n        identifiedToolName: null,\n      },\n    };\n  }\n\n  if (\n    _previousState &&\n    _previousState.mightBeToolCall &&\n    !detection.mightBeToolCall\n  ) {\n    logger.debug(\n      `[XML Parser] Previously buffered content is now confirmed not to be a tool call. Resetting buffer.`,\n    );\n\n    return {\n      complete: false,\n      partialState: {\n        rootTag: null,\n        isPotential: false,\n        mightBeToolCall: false,\n        buffer: \"\",\n        identifiedToolName: null,\n      },\n    };\n  }\n\n  if (detection.mightBeToolCall) {\n    try {\n      if (detection.isCompletedXml) {\n        const extracted = extractToolCallXMLParser(content, knownToolNames);\n        if (extracted) {\n          return {\n            complete: true,\n            toolCall: extracted,\n            content: content,\n          };\n        }\n      }\n\n      if (detection.rootTagName) {\n        for (const toolName of knownToolNames) {\n          if (toolName.toLowerCase() === detection.rootTagName.toLowerCase()) {\n            const tagRegex = new RegExp(\n              `<${toolName}[^>]*?>([\\\\s\\\\S]*?)<\\\\/${toolName}>`,\n              \"gi\",\n            );\n            let match;\n\n            while ((match = tagRegex.exec(content)) !== null) {\n              const potentialTool = match[0];\n              const extracted = extractToolCallXMLParser(\n                potentialTool,\n                knownToolNames,\n              );\n\n              if (\n                extracted &&\n                extracted.name.toLowerCase() === toolName.toLowerCase()\n              ) {\n                logger.debug(\n                  `[XML Parser] Found embedded tool call for '${toolName}'`,\n                );\n                return {\n                  complete: true,\n                  toolCall: extracted,\n                  content: potentialTool,\n                };\n              }\n            }\n          }\n        }\n      }\n    } catch (err: unknown) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      logger.debug(\"[XML Parser] Error during tool call extraction:\", errorMessage);\n    }\n  }\n\n  if (\n    _previousState &&\n    _previousState.mightBeToolCall &&\n    !detection.mightBeToolCall &&\n    detection.rootTagName\n  ) {\n    logger.debug(\n      `[XML Parser] Previously buffered content is now confirmed not to be a tool call. Resetting buffer.`,\n    );\n\n    return {\n      complete: false,\n      partialState: {\n        rootTag: null,\n        isPotential: false,\n        mightBeToolCall: false,\n        buffer: \"\",\n        identifiedToolName: null,\n      },\n    };\n  }\n\n  return {\n    complete: false,\n    partialState: {\n      rootTag: detection.rootTagName,\n      isPotential: detection.isPotential,\n      mightBeToolCall: detection.mightBeToolCall,\n      buffer: detection.mightBeToolCall ? content : \"\",\n      identifiedToolName:\n        detection.rootTagName ||\n        (_previousState && _previousState.identifiedToolName),\n    },\n  };\n}","usedDeprecatedRules":[]}]